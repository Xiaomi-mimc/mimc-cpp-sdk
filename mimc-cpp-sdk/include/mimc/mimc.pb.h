// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging-protobuf/xiaomi-mimc/src/main/proto/mimc.proto

#ifndef PROTOBUF_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto__INCLUDED
#define PROTOBUF_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mimc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

class FilterRequest;
class FilterResponse;
class PullMessageRequest;
class TopicMessage;
class QueryAppinfoRequest;
class Appinfo;
class MIMCPacket;
class MIMCPacketList;
class MIMCPacketAck;
class MIMCP2PMessage;
class MIMCP2TMessage;
class MIMCSequenceAck;
class MIMCPull;
class MIMCUser;
class MIMCGroup;

enum ErrorCode {
  OK = 1,
  INTERNAL_ERROR = 2
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = OK;
const ErrorCode ErrorCode_MAX = INTERNAL_ERROR;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum MIMC_MSG_TYPE {
  P2P_MESSAGE = 1,
  P2T_MESSAGE = 2,
  SEQUENCE_ACK = 3,
  PACKET_ACK = 4,
  PULL = 5,
  COMPOUND = 6
};
bool MIMC_MSG_TYPE_IsValid(int value);
const MIMC_MSG_TYPE MIMC_MSG_TYPE_MIN = P2P_MESSAGE;
const MIMC_MSG_TYPE MIMC_MSG_TYPE_MAX = COMPOUND;
const int MIMC_MSG_TYPE_ARRAYSIZE = MIMC_MSG_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MIMC_MSG_TYPE_descriptor();
inline const ::std::string& MIMC_MSG_TYPE_Name(MIMC_MSG_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MIMC_MSG_TYPE_descriptor(), value);
}
inline bool MIMC_MSG_TYPE_Parse(
    const ::std::string& name, MIMC_MSG_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MIMC_MSG_TYPE>(
    MIMC_MSG_TYPE_descriptor(), name, value);
}
// ===================================================================

class FilterRequest : public ::google::protobuf::Message {
 public:
  FilterRequest();
  virtual ~FilterRequest();

  FilterRequest(const FilterRequest& from);

  inline FilterRequest& operator=(const FilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterRequest& default_instance();

  void Swap(FilterRequest* other);

  // implements Message ----------------------------------------------

  FilterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterRequest& from);
  void MergeFrom(const FilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .mimc.MIMCPacket packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::mimc::MIMCPacket& packet() const;
  inline ::mimc::MIMCPacket* mutable_packet();
  inline ::mimc::MIMCPacket* release_packet();
  inline void set_allocated_packet(::mimc::MIMCPacket* packet);

  // @@protoc_insertion_point(class_scope:mimc.FilterRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_packet();
  inline void clear_has_packet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::mimc::MIMCPacket* packet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static FilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class FilterResponse : public ::google::protobuf::Message {
 public:
  FilterResponse();
  virtual ~FilterResponse();

  FilterResponse(const FilterResponse& from);

  inline FilterResponse& operator=(const FilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterResponse& default_instance();

  void Swap(FilterResponse* other);

  // implements Message ----------------------------------------------

  FilterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterResponse& from);
  void MergeFrom(const FilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .mimc.MIMC_MSG_TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mimc::MIMC_MSG_TYPE type() const;
  inline void set_type(::mimc::MIMC_MSG_TYPE value);

  // optional .mimc.ErrorCode errorCode = 3;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 3;
  inline ::mimc::ErrorCode errorcode() const;
  inline void set_errorcode(::mimc::ErrorCode value);

  // optional bool isFilter = 4;
  inline bool has_isfilter() const;
  inline void clear_isfilter();
  static const int kIsFilterFieldNumber = 4;
  inline bool isfilter() const;
  inline void set_isfilter(bool value);

  // @@protoc_insertion_point(class_scope:mimc.FilterResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_isfilter();
  inline void clear_has_isfilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  int type_;
  int errorcode_;
  bool isfilter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static FilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class PullMessageRequest : public ::google::protobuf::Message {
 public:
  PullMessageRequest();
  virtual ~PullMessageRequest();

  PullMessageRequest(const PullMessageRequest& from);

  inline PullMessageRequest& operator=(const PullMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PullMessageRequest& default_instance();

  void Swap(PullMessageRequest* other);

  // implements Message ----------------------------------------------

  PullMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullMessageRequest& from);
  void MergeFrom(const PullMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.PullMessageRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static PullMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class TopicMessage : public ::google::protobuf::Message {
 public:
  TopicMessage();
  virtual ~TopicMessage();

  TopicMessage(const TopicMessage& from);

  inline TopicMessage& operator=(const TopicMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicMessage& default_instance();

  void Swap(TopicMessage* other);

  // implements Message ----------------------------------------------

  TopicMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicMessage& from);
  void MergeFrom(const TopicMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 topicId = 1;
  inline bool has_topicid() const;
  inline void clear_topicid();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::uint64 topicid() const;
  inline void set_topicid(::google::protobuf::uint64 value);

  // required .mimc.MIMCPacket packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::mimc::MIMCPacket& packet() const;
  inline ::mimc::MIMCPacket* mutable_packet();
  inline ::mimc::MIMCPacket* release_packet();
  inline void set_allocated_packet(::mimc::MIMCPacket* packet);

  // optional int64 uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.TopicMessage)
 private:
  inline void set_has_topicid();
  inline void clear_has_topicid();
  inline void set_has_packet();
  inline void clear_has_packet();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 topicid_;
  ::mimc::MIMCPacket* packet_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static TopicMessage* default_instance_;
};
// -------------------------------------------------------------------

class QueryAppinfoRequest : public ::google::protobuf::Message {
 public:
  QueryAppinfoRequest();
  virtual ~QueryAppinfoRequest();

  QueryAppinfoRequest(const QueryAppinfoRequest& from);

  inline QueryAppinfoRequest& operator=(const QueryAppinfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryAppinfoRequest& default_instance();

  void Swap(QueryAppinfoRequest* other);

  // implements Message ----------------------------------------------

  QueryAppinfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryAppinfoRequest& from);
  void MergeFrom(const QueryAppinfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint64 appid() const;
  inline void set_appid(::google::protobuf::uint64 value);

  // optional string context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // @@protoc_insertion_point(class_scope:mimc.QueryAppinfoRequest)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 appid_;
  ::std::string* context_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static QueryAppinfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class Appinfo : public ::google::protobuf::Message {
 public:
  Appinfo();
  virtual ~Appinfo();

  Appinfo(const Appinfo& from);

  inline Appinfo& operator=(const Appinfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Appinfo& default_instance();

  void Swap(Appinfo* other);

  // implements Message ----------------------------------------------

  Appinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Appinfo& from);
  void MergeFrom(const Appinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint64 appid() const;
  inline void set_appid(::google::protobuf::uint64 value);

  // optional string msgCallbackUrl = 2;
  inline bool has_msgcallbackurl() const;
  inline void clear_msgcallbackurl();
  static const int kMsgCallbackUrlFieldNumber = 2;
  inline const ::std::string& msgcallbackurl() const;
  inline void set_msgcallbackurl(const ::std::string& value);
  inline void set_msgcallbackurl(const char* value);
  inline void set_msgcallbackurl(const char* value, size_t size);
  inline ::std::string* mutable_msgcallbackurl();
  inline ::std::string* release_msgcallbackurl();
  inline void set_allocated_msgcallbackurl(::std::string* msgcallbackurl);

  // optional string offlineMsgCallbackUrl = 3;
  inline bool has_offlinemsgcallbackurl() const;
  inline void clear_offlinemsgcallbackurl();
  static const int kOfflineMsgCallbackUrlFieldNumber = 3;
  inline const ::std::string& offlinemsgcallbackurl() const;
  inline void set_offlinemsgcallbackurl(const ::std::string& value);
  inline void set_offlinemsgcallbackurl(const char* value);
  inline void set_offlinemsgcallbackurl(const char* value, size_t size);
  inline ::std::string* mutable_offlinemsgcallbackurl();
  inline ::std::string* release_offlinemsgcallbackurl();
  inline void set_allocated_offlinemsgcallbackurl(::std::string* offlinemsgcallbackurl);

  // optional uint64 uuidTTL = 4;
  inline bool has_uuidttl() const;
  inline void clear_uuidttl();
  static const int kUuidTTLFieldNumber = 4;
  inline ::google::protobuf::uint64 uuidttl() const;
  inline void set_uuidttl(::google::protobuf::uint64 value);

  // optional string context = 5;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 5;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // optional string messageFilter = 6;
  inline bool has_messagefilter() const;
  inline void clear_messagefilter();
  static const int kMessageFilterFieldNumber = 6;
  inline const ::std::string& messagefilter() const;
  inline void set_messagefilter(const ::std::string& value);
  inline void set_messagefilter(const char* value);
  inline void set_messagefilter(const char* value, size_t size);
  inline ::std::string* mutable_messagefilter();
  inline ::std::string* release_messagefilter();
  inline void set_allocated_messagefilter(::std::string* messagefilter);

  // @@protoc_insertion_point(class_scope:mimc.Appinfo)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_msgcallbackurl();
  inline void clear_has_msgcallbackurl();
  inline void set_has_offlinemsgcallbackurl();
  inline void clear_has_offlinemsgcallbackurl();
  inline void set_has_uuidttl();
  inline void clear_has_uuidttl();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_messagefilter();
  inline void clear_has_messagefilter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 appid_;
  ::std::string* msgcallbackurl_;
  ::std::string* offlinemsgcallbackurl_;
  ::google::protobuf::uint64 uuidttl_;
  ::std::string* context_;
  ::std::string* messagefilter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static Appinfo* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacket : public ::google::protobuf::Message {
 public:
  MIMCPacket();
  virtual ~MIMCPacket();

  MIMCPacket(const MIMCPacket& from);

  inline MIMCPacket& operator=(const MIMCPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCPacket& default_instance();

  void Swap(MIMCPacket* other);

  // implements Message ----------------------------------------------

  MIMCPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCPacket& from);
  void MergeFrom(const MIMCPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string packetId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional int64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional .mimc.MIMC_MSG_TYPE type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::mimc::MIMC_MSG_TYPE type() const;
  inline void set_type(::mimc::MIMC_MSG_TYPE value);

  // optional bytes payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacket)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packetid_;
  ::std::string* package_;
  ::google::protobuf::int64 sequence_;
  ::std::string* payload_;
  ::google::protobuf::int64 timestamp_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacket* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacketList : public ::google::protobuf::Message {
 public:
  MIMCPacketList();
  virtual ~MIMCPacketList();

  MIMCPacketList(const MIMCPacketList& from);

  inline MIMCPacketList& operator=(const MIMCPacketList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCPacketList& default_instance();

  void Swap(MIMCPacketList* other);

  // implements Message ----------------------------------------------

  MIMCPacketList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCPacketList& from);
  void MergeFrom(const MIMCPacketList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 maxSequence = 3;
  inline bool has_maxsequence() const;
  inline void clear_maxsequence();
  static const int kMaxSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 maxsequence() const;
  inline void set_maxsequence(::google::protobuf::int64 value);

  // repeated .mimc.MIMCPacket packets = 4;
  inline int packets_size() const;
  inline void clear_packets();
  static const int kPacketsFieldNumber = 4;
  inline const ::mimc::MIMCPacket& packets(int index) const;
  inline ::mimc::MIMCPacket* mutable_packets(int index);
  inline ::mimc::MIMCPacket* add_packets();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >&
      packets() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >*
      mutable_packets();

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacketList)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_maxsequence();
  inline void clear_has_maxsequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 maxsequence_;
  ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket > packets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacketList* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacketAck : public ::google::protobuf::Message {
 public:
  MIMCPacketAck();
  virtual ~MIMCPacketAck();

  MIMCPacketAck(const MIMCPacketAck& from);

  inline MIMCPacketAck& operator=(const MIMCPacketAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCPacketAck& default_instance();

  void Swap(MIMCPacketAck* other);

  // implements Message ----------------------------------------------

  MIMCPacketAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCPacketAck& from);
  void MergeFrom(const MIMCPacketAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string packetId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional int64 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 sequence = 4;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string package = 6;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 6;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional string errorMsg = 7;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 7;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  inline void set_allocated_errormsg(::std::string* errormsg);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacketAck)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packetid_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* package_;
  ::std::string* errormsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacketAck* default_instance_;
};
// -------------------------------------------------------------------

class MIMCP2PMessage : public ::google::protobuf::Message {
 public:
  MIMCP2PMessage();
  virtual ~MIMCP2PMessage();

  MIMCP2PMessage(const MIMCP2PMessage& from);

  inline MIMCP2PMessage& operator=(const MIMCP2PMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCP2PMessage& default_instance();

  void Swap(MIMCP2PMessage* other);

  // implements Message ----------------------------------------------

  MIMCP2PMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCP2PMessage& from);
  void MergeFrom(const MIMCP2PMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // optional .mimc.MIMCUser to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCUser& to() const;
  inline ::mimc::MIMCUser* mutable_to();
  inline ::mimc::MIMCUser* release_to();
  inline void set_allocated_to(::mimc::MIMCUser* to);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCP2PMessage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mimc::MIMCUser* from_;
  ::mimc::MIMCUser* to_;
  ::std::string* payload_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCP2PMessage* default_instance_;
};
// -------------------------------------------------------------------

class MIMCP2TMessage : public ::google::protobuf::Message {
 public:
  MIMCP2TMessage();
  virtual ~MIMCP2TMessage();

  MIMCP2TMessage(const MIMCP2TMessage& from);

  inline MIMCP2TMessage& operator=(const MIMCP2TMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCP2TMessage& default_instance();

  void Swap(MIMCP2TMessage* other);

  // implements Message ----------------------------------------------

  MIMCP2TMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCP2TMessage& from);
  void MergeFrom(const MIMCP2TMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // optional .mimc.MIMCGroup to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCGroup& to() const;
  inline ::mimc::MIMCGroup* mutable_to();
  inline ::mimc::MIMCGroup* release_to();
  inline void set_allocated_to(::mimc::MIMCGroup* to);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCP2TMessage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mimc::MIMCUser* from_;
  ::mimc::MIMCGroup* to_;
  ::std::string* payload_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCP2TMessage* default_instance_;
};
// -------------------------------------------------------------------

class MIMCSequenceAck : public ::google::protobuf::Message {
 public:
  MIMCSequenceAck();
  virtual ~MIMCSequenceAck();

  MIMCSequenceAck(const MIMCSequenceAck& from);

  inline MIMCSequenceAck& operator=(const MIMCSequenceAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCSequenceAck& default_instance();

  void Swap(MIMCSequenceAck* other);

  // implements Message ----------------------------------------------

  MIMCSequenceAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCSequenceAck& from);
  void MergeFrom(const MIMCSequenceAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCSequenceAck)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCSequenceAck* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPull : public ::google::protobuf::Message {
 public:
  MIMCPull();
  virtual ~MIMCPull();

  MIMCPull(const MIMCPull& from);

  inline MIMCPull& operator=(const MIMCPull& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCPull& default_instance();

  void Swap(MIMCPull* other);

  // implements Message ----------------------------------------------

  MIMCPull* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCPull& from);
  void MergeFrom(const MIMCPull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPull)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPull* default_instance_;
};
// -------------------------------------------------------------------

class MIMCUser : public ::google::protobuf::Message {
 public:
  MIMCUser();
  virtual ~MIMCUser();

  MIMCUser(const MIMCUser& from);

  inline MIMCUser& operator=(const MIMCUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCUser& default_instance();

  void Swap(MIMCUser* other);

  // implements Message ----------------------------------------------

  MIMCUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCUser& from);
  void MergeFrom(const MIMCUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional string appAccount = 2;
  inline bool has_appaccount() const;
  inline void clear_appaccount();
  static const int kAppAccountFieldNumber = 2;
  inline const ::std::string& appaccount() const;
  inline void set_appaccount(const ::std::string& value);
  inline void set_appaccount(const char* value);
  inline void set_appaccount(const char* value, size_t size);
  inline ::std::string* mutable_appaccount();
  inline ::std::string* release_appaccount();
  inline void set_allocated_appaccount(::std::string* appaccount);

  // optional int64 uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.MIMCUser)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_appaccount();
  inline void clear_has_appaccount();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 appid_;
  ::std::string* appaccount_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCUser* default_instance_;
};
// -------------------------------------------------------------------

class MIMCGroup : public ::google::protobuf::Message {
 public:
  MIMCGroup();
  virtual ~MIMCGroup();

  MIMCGroup(const MIMCGroup& from);

  inline MIMCGroup& operator=(const MIMCGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MIMCGroup& default_instance();

  void Swap(MIMCGroup* other);

  // implements Message ----------------------------------------------

  MIMCGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MIMCGroup& from);
  void MergeFrom(const MIMCGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional int64 topicId = 2;
  inline bool has_topicid() const;
  inline void clear_topicid();
  static const int kTopicIdFieldNumber = 2;
  inline ::google::protobuf::int64 topicid() const;
  inline void set_topicid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCGroup)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_topicid();
  inline void clear_has_topicid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 appid_;
  ::google::protobuf::int64 topicid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_AssignDesc_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();
  friend void protobuf_ShutdownFile_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCGroup* default_instance_;
};
// ===================================================================


// ===================================================================

// FilterRequest

// required string id = 1;
inline bool FilterRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FilterRequest::id() const {
  return *id_;
}
inline void FilterRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FilterRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mimc.MIMCPacket packet = 2;
inline bool FilterRequest::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterRequest::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterRequest::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterRequest::clear_packet() {
  if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
  clear_has_packet();
}
inline const ::mimc::MIMCPacket& FilterRequest::packet() const {
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
}
inline ::mimc::MIMCPacket* FilterRequest::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) packet_ = new ::mimc::MIMCPacket;
  return packet_;
}
inline ::mimc::MIMCPacket* FilterRequest::release_packet() {
  clear_has_packet();
  ::mimc::MIMCPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void FilterRequest::set_allocated_packet(::mimc::MIMCPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
}

// -------------------------------------------------------------------

// FilterResponse

// required string id = 1;
inline bool FilterResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FilterResponse::id() const {
  return *id_;
}
inline void FilterResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FilterResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mimc.MIMC_MSG_TYPE type = 2;
inline bool FilterResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::MIMC_MSG_TYPE FilterResponse::type() const {
  return static_cast< ::mimc::MIMC_MSG_TYPE >(type_);
}
inline void FilterResponse::set_type(::mimc::MIMC_MSG_TYPE value) {
  assert(::mimc::MIMC_MSG_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mimc.ErrorCode errorCode = 3;
inline bool FilterResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterResponse::clear_errorcode() {
  errorcode_ = 1;
  clear_has_errorcode();
}
inline ::mimc::ErrorCode FilterResponse::errorcode() const {
  return static_cast< ::mimc::ErrorCode >(errorcode_);
}
inline void FilterResponse::set_errorcode(::mimc::ErrorCode value) {
  assert(::mimc::ErrorCode_IsValid(value));
  set_has_errorcode();
  errorcode_ = value;
}

// optional bool isFilter = 4;
inline bool FilterResponse::has_isfilter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterResponse::set_has_isfilter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterResponse::clear_has_isfilter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterResponse::clear_isfilter() {
  isfilter_ = false;
  clear_has_isfilter();
}
inline bool FilterResponse::isfilter() const {
  return isfilter_;
}
inline void FilterResponse::set_isfilter(bool value) {
  set_has_isfilter();
  isfilter_ = value;
}

// -------------------------------------------------------------------

// PullMessageRequest

// required uint64 uuid = 1;
inline bool PullMessageRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullMessageRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullMessageRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullMessageRequest::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 PullMessageRequest::uuid() const {
  return uuid_;
}
inline void PullMessageRequest::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool PullMessageRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullMessageRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullMessageRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullMessageRequest::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& PullMessageRequest::resource() const {
  return *resource_;
}
inline void PullMessageRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PullMessageRequest::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PullMessageRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullMessageRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* PullMessageRequest::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PullMessageRequest::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TopicMessage

// required uint64 topicId = 1;
inline bool TopicMessage::has_topicid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicMessage::set_has_topicid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicMessage::clear_has_topicid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicMessage::clear_topicid() {
  topicid_ = GOOGLE_ULONGLONG(0);
  clear_has_topicid();
}
inline ::google::protobuf::uint64 TopicMessage::topicid() const {
  return topicid_;
}
inline void TopicMessage::set_topicid(::google::protobuf::uint64 value) {
  set_has_topicid();
  topicid_ = value;
}

// required .mimc.MIMCPacket packet = 2;
inline bool TopicMessage::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicMessage::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicMessage::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicMessage::clear_packet() {
  if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
  clear_has_packet();
}
inline const ::mimc::MIMCPacket& TopicMessage::packet() const {
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
}
inline ::mimc::MIMCPacket* TopicMessage::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) packet_ = new ::mimc::MIMCPacket;
  return packet_;
}
inline ::mimc::MIMCPacket* TopicMessage::release_packet() {
  clear_has_packet();
  ::mimc::MIMCPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void TopicMessage::set_allocated_packet(::mimc::MIMCPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
}

// optional int64 uuid = 3;
inline bool TopicMessage::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicMessage::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicMessage::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicMessage::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 TopicMessage::uuid() const {
  return uuid_;
}
inline void TopicMessage::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 4;
inline bool TopicMessage::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicMessage::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicMessage::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicMessage::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& TopicMessage::resource() const {
  return *resource_;
}
inline void TopicMessage::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TopicMessage::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TopicMessage::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicMessage::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* TopicMessage::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopicMessage::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryAppinfoRequest

// required uint64 appId = 1;
inline bool QueryAppinfoRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAppinfoRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAppinfoRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAppinfoRequest::clear_appid() {
  appid_ = GOOGLE_ULONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::uint64 QueryAppinfoRequest::appid() const {
  return appid_;
}
inline void QueryAppinfoRequest::set_appid(::google::protobuf::uint64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string context = 2;
inline bool QueryAppinfoRequest::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryAppinfoRequest::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryAppinfoRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryAppinfoRequest::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& QueryAppinfoRequest::context() const {
  return *context_;
}
inline void QueryAppinfoRequest::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void QueryAppinfoRequest::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void QueryAppinfoRequest::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryAppinfoRequest::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* QueryAppinfoRequest::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryAppinfoRequest::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Appinfo

// required uint64 appId = 1;
inline bool Appinfo::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Appinfo::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Appinfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Appinfo::clear_appid() {
  appid_ = GOOGLE_ULONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::uint64 Appinfo::appid() const {
  return appid_;
}
inline void Appinfo::set_appid(::google::protobuf::uint64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string msgCallbackUrl = 2;
inline bool Appinfo::has_msgcallbackurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Appinfo::set_has_msgcallbackurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Appinfo::clear_has_msgcallbackurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Appinfo::clear_msgcallbackurl() {
  if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_->clear();
  }
  clear_has_msgcallbackurl();
}
inline const ::std::string& Appinfo::msgcallbackurl() const {
  return *msgcallbackurl_;
}
inline void Appinfo::set_msgcallbackurl(const ::std::string& value) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(value);
}
inline void Appinfo::set_msgcallbackurl(const char* value) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(value);
}
inline void Appinfo::set_msgcallbackurl(const char* value, size_t size) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_msgcallbackurl() {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  return msgcallbackurl_;
}
inline ::std::string* Appinfo::release_msgcallbackurl() {
  clear_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcallbackurl_;
    msgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_msgcallbackurl(::std::string* msgcallbackurl) {
  if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcallbackurl_;
  }
  if (msgcallbackurl) {
    set_has_msgcallbackurl();
    msgcallbackurl_ = msgcallbackurl;
  } else {
    clear_has_msgcallbackurl();
    msgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string offlineMsgCallbackUrl = 3;
inline bool Appinfo::has_offlinemsgcallbackurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Appinfo::set_has_offlinemsgcallbackurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Appinfo::clear_has_offlinemsgcallbackurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Appinfo::clear_offlinemsgcallbackurl() {
  if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_->clear();
  }
  clear_has_offlinemsgcallbackurl();
}
inline const ::std::string& Appinfo::offlinemsgcallbackurl() const {
  return *offlinemsgcallbackurl_;
}
inline void Appinfo::set_offlinemsgcallbackurl(const ::std::string& value) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(value);
}
inline void Appinfo::set_offlinemsgcallbackurl(const char* value) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(value);
}
inline void Appinfo::set_offlinemsgcallbackurl(const char* value, size_t size) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_offlinemsgcallbackurl() {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  return offlinemsgcallbackurl_;
}
inline ::std::string* Appinfo::release_offlinemsgcallbackurl() {
  clear_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offlinemsgcallbackurl_;
    offlinemsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_offlinemsgcallbackurl(::std::string* offlinemsgcallbackurl) {
  if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete offlinemsgcallbackurl_;
  }
  if (offlinemsgcallbackurl) {
    set_has_offlinemsgcallbackurl();
    offlinemsgcallbackurl_ = offlinemsgcallbackurl;
  } else {
    clear_has_offlinemsgcallbackurl();
    offlinemsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uuidTTL = 4;
inline bool Appinfo::has_uuidttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Appinfo::set_has_uuidttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Appinfo::clear_has_uuidttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Appinfo::clear_uuidttl() {
  uuidttl_ = GOOGLE_ULONGLONG(0);
  clear_has_uuidttl();
}
inline ::google::protobuf::uint64 Appinfo::uuidttl() const {
  return uuidttl_;
}
inline void Appinfo::set_uuidttl(::google::protobuf::uint64 value) {
  set_has_uuidttl();
  uuidttl_ = value;
}

// optional string context = 5;
inline bool Appinfo::has_context() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Appinfo::set_has_context() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Appinfo::clear_has_context() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Appinfo::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& Appinfo::context() const {
  return *context_;
}
inline void Appinfo::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void Appinfo::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void Appinfo::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* Appinfo::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string messageFilter = 6;
inline bool Appinfo::has_messagefilter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Appinfo::set_has_messagefilter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Appinfo::clear_has_messagefilter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Appinfo::clear_messagefilter() {
  if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
    messagefilter_->clear();
  }
  clear_has_messagefilter();
}
inline const ::std::string& Appinfo::messagefilter() const {
  return *messagefilter_;
}
inline void Appinfo::set_messagefilter(const ::std::string& value) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(value);
}
inline void Appinfo::set_messagefilter(const char* value) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(value);
}
inline void Appinfo::set_messagefilter(const char* value, size_t size) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_messagefilter() {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  return messagefilter_;
}
inline ::std::string* Appinfo::release_messagefilter() {
  clear_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagefilter_;
    messagefilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_messagefilter(::std::string* messagefilter) {
  if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
    delete messagefilter_;
  }
  if (messagefilter) {
    set_has_messagefilter();
    messagefilter_ = messagefilter;
  } else {
    clear_has_messagefilter();
    messagefilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCPacket

// optional string packetId = 1;
inline bool MIMCPacket::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacket::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacket::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacket::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& MIMCPacket::packetid() const {
  return *packetid_;
}
inline void MIMCPacket::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacket::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacket::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* MIMCPacket::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string package = 2;
inline bool MIMCPacket::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacket::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacket::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacket::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& MIMCPacket::package() const {
  return *package_;
}
inline void MIMCPacket::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacket::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacket::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* MIMCPacket::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 3;
inline bool MIMCPacket::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacket::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacket::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacket::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCPacket::sequence() const {
  return sequence_;
}
inline void MIMCPacket::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional .mimc.MIMC_MSG_TYPE type = 4;
inline bool MIMCPacket::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCPacket::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCPacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCPacket::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::MIMC_MSG_TYPE MIMCPacket::type() const {
  return static_cast< ::mimc::MIMC_MSG_TYPE >(type_);
}
inline void MIMCPacket::set_type(::mimc::MIMC_MSG_TYPE value) {
  assert(::mimc::MIMC_MSG_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes payload = 5;
inline bool MIMCPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCPacket::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCPacket::payload() const {
  return *payload_;
}
inline void MIMCPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCPacket::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCPacket::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 6;
inline bool MIMCPacket::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MIMCPacket::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MIMCPacket::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MIMCPacket::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MIMCPacket::timestamp() const {
  return timestamp_;
}
inline void MIMCPacket::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// MIMCPacketList

// optional int64 uuid = 1;
inline bool MIMCPacketList::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacketList::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacketList::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacketList::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPacketList::uuid() const {
  return uuid_;
}
inline void MIMCPacketList::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCPacketList::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacketList::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacketList::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacketList::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPacketList::resource() const {
  return *resource_;
}
inline void MIMCPacketList::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketList::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketList::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketList::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPacketList::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketList::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 maxSequence = 3;
inline bool MIMCPacketList::has_maxsequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacketList::set_has_maxsequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacketList::clear_has_maxsequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacketList::clear_maxsequence() {
  maxsequence_ = GOOGLE_LONGLONG(0);
  clear_has_maxsequence();
}
inline ::google::protobuf::int64 MIMCPacketList::maxsequence() const {
  return maxsequence_;
}
inline void MIMCPacketList::set_maxsequence(::google::protobuf::int64 value) {
  set_has_maxsequence();
  maxsequence_ = value;
}

// repeated .mimc.MIMCPacket packets = 4;
inline int MIMCPacketList::packets_size() const {
  return packets_.size();
}
inline void MIMCPacketList::clear_packets() {
  packets_.Clear();
}
inline const ::mimc::MIMCPacket& MIMCPacketList::packets(int index) const {
  return packets_.Get(index);
}
inline ::mimc::MIMCPacket* MIMCPacketList::mutable_packets(int index) {
  return packets_.Mutable(index);
}
inline ::mimc::MIMCPacket* MIMCPacketList::add_packets() {
  return packets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >&
MIMCPacketList::packets() const {
  return packets_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >*
MIMCPacketList::mutable_packets() {
  return &packets_;
}

// -------------------------------------------------------------------

// MIMCPacketAck

// optional string packetId = 1;
inline bool MIMCPacketAck::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacketAck::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacketAck::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacketAck::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& MIMCPacketAck::packetid() const {
  return *packetid_;
}
inline void MIMCPacketAck::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacketAck::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacketAck::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* MIMCPacketAck::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 uuid = 2;
inline bool MIMCPacketAck::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacketAck::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacketAck::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacketAck::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPacketAck::uuid() const {
  return uuid_;
}
inline void MIMCPacketAck::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 3;
inline bool MIMCPacketAck::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacketAck::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacketAck::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacketAck::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPacketAck::resource() const {
  return *resource_;
}
inline void MIMCPacketAck::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketAck::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketAck::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPacketAck::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 4;
inline bool MIMCPacketAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCPacketAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCPacketAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCPacketAck::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCPacketAck::sequence() const {
  return sequence_;
}
inline void MIMCPacketAck::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int64 timestamp = 5;
inline bool MIMCPacketAck::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCPacketAck::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCPacketAck::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCPacketAck::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MIMCPacketAck::timestamp() const {
  return timestamp_;
}
inline void MIMCPacketAck::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string package = 6;
inline bool MIMCPacketAck::has_package() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MIMCPacketAck::set_has_package() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MIMCPacketAck::clear_has_package() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MIMCPacketAck::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& MIMCPacketAck::package() const {
  return *package_;
}
inline void MIMCPacketAck::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacketAck::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacketAck::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* MIMCPacketAck::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string errorMsg = 7;
inline bool MIMCPacketAck::has_errormsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MIMCPacketAck::set_has_errormsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MIMCPacketAck::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MIMCPacketAck::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& MIMCPacketAck::errormsg() const {
  return *errormsg_;
}
inline void MIMCPacketAck::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void MIMCPacketAck::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void MIMCPacketAck::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* MIMCPacketAck::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errormsg_;
  }
  if (errormsg) {
    set_has_errormsg();
    errormsg_ = errormsg;
  } else {
    clear_has_errormsg();
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCP2PMessage

// optional .mimc.MIMCUser from = 1;
inline bool MIMCP2PMessage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCP2PMessage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCP2PMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCP2PMessage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& MIMCP2PMessage::from() const {
  return from_ != NULL ? *from_ : *default_instance_->from_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void MIMCP2PMessage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// optional .mimc.MIMCUser to = 2;
inline bool MIMCP2PMessage::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCP2PMessage::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCP2PMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCP2PMessage::clear_to() {
  if (to_ != NULL) to_->::mimc::MIMCUser::Clear();
  clear_has_to();
}
inline const ::mimc::MIMCUser& MIMCP2PMessage::to() const {
  return to_ != NULL ? *to_ : *default_instance_->to_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::mutable_to() {
  set_has_to();
  if (to_ == NULL) to_ = new ::mimc::MIMCUser;
  return to_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::release_to() {
  clear_has_to();
  ::mimc::MIMCUser* temp = to_;
  to_ = NULL;
  return temp;
}
inline void MIMCP2PMessage::set_allocated_to(::mimc::MIMCUser* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
}

// optional bytes payload = 3;
inline bool MIMCP2PMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCP2PMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCP2PMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCP2PMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCP2PMessage::payload() const {
  return *payload_;
}
inline void MIMCP2PMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2PMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2PMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2PMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCP2PMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2PMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool MIMCP2PMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCP2PMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCP2PMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCP2PMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool MIMCP2PMessage::isstore() const {
  return isstore_;
}
inline void MIMCP2PMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// -------------------------------------------------------------------

// MIMCP2TMessage

// optional .mimc.MIMCUser from = 1;
inline bool MIMCP2TMessage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCP2TMessage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCP2TMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCP2TMessage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& MIMCP2TMessage::from() const {
  return from_ != NULL ? *from_ : *default_instance_->from_;
}
inline ::mimc::MIMCUser* MIMCP2TMessage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* MIMCP2TMessage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void MIMCP2TMessage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// optional .mimc.MIMCGroup to = 2;
inline bool MIMCP2TMessage::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCP2TMessage::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCP2TMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCP2TMessage::clear_to() {
  if (to_ != NULL) to_->::mimc::MIMCGroup::Clear();
  clear_has_to();
}
inline const ::mimc::MIMCGroup& MIMCP2TMessage::to() const {
  return to_ != NULL ? *to_ : *default_instance_->to_;
}
inline ::mimc::MIMCGroup* MIMCP2TMessage::mutable_to() {
  set_has_to();
  if (to_ == NULL) to_ = new ::mimc::MIMCGroup;
  return to_;
}
inline ::mimc::MIMCGroup* MIMCP2TMessage::release_to() {
  clear_has_to();
  ::mimc::MIMCGroup* temp = to_;
  to_ = NULL;
  return temp;
}
inline void MIMCP2TMessage::set_allocated_to(::mimc::MIMCGroup* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
}

// optional bytes payload = 3;
inline bool MIMCP2TMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCP2TMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCP2TMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCP2TMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCP2TMessage::payload() const {
  return *payload_;
}
inline void MIMCP2TMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2TMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2TMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2TMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCP2TMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2TMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool MIMCP2TMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCP2TMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCP2TMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCP2TMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool MIMCP2TMessage::isstore() const {
  return isstore_;
}
inline void MIMCP2TMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// -------------------------------------------------------------------

// MIMCSequenceAck

// optional int64 uuid = 1;
inline bool MIMCSequenceAck::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCSequenceAck::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCSequenceAck::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCSequenceAck::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCSequenceAck::uuid() const {
  return uuid_;
}
inline void MIMCSequenceAck::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCSequenceAck::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCSequenceAck::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCSequenceAck::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCSequenceAck::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCSequenceAck::resource() const {
  return *resource_;
}
inline void MIMCSequenceAck::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCSequenceAck::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCSequenceAck::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCSequenceAck::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCSequenceAck::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCSequenceAck::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 3;
inline bool MIMCSequenceAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCSequenceAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCSequenceAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCSequenceAck::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCSequenceAck::sequence() const {
  return sequence_;
}
inline void MIMCSequenceAck::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// -------------------------------------------------------------------

// MIMCPull

// optional int64 uuid = 1;
inline bool MIMCPull::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPull::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPull::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPull::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPull::uuid() const {
  return uuid_;
}
inline void MIMCPull::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCPull::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPull::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPull::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPull::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPull::resource() const {
  return *resource_;
}
inline void MIMCPull::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPull::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPull::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPull::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPull::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPull::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCUser

// optional int64 appId = 1;
inline bool MIMCUser::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCUser::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCUser::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCUser::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 MIMCUser::appid() const {
  return appid_;
}
inline void MIMCUser::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string appAccount = 2;
inline bool MIMCUser::has_appaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCUser::set_has_appaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCUser::clear_has_appaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCUser::clear_appaccount() {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    appaccount_->clear();
  }
  clear_has_appaccount();
}
inline const ::std::string& MIMCUser::appaccount() const {
  return *appaccount_;
}
inline void MIMCUser::set_appaccount(const ::std::string& value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void MIMCUser::set_appaccount(const char* value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void MIMCUser::set_appaccount(const char* value, size_t size) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCUser::mutable_appaccount() {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  return appaccount_;
}
inline ::std::string* MIMCUser::release_appaccount() {
  clear_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appaccount_;
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCUser::set_allocated_appaccount(::std::string* appaccount) {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete appaccount_;
  }
  if (appaccount) {
    set_has_appaccount();
    appaccount_ = appaccount;
  } else {
    clear_has_appaccount();
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 uuid = 3;
inline bool MIMCUser::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCUser::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCUser::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCUser::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCUser::uuid() const {
  return uuid_;
}
inline void MIMCUser::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 4;
inline bool MIMCUser::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCUser::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCUser::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCUser::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCUser::resource() const {
  return *resource_;
}
inline void MIMCUser::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCUser::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCUser::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCUser::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCUser::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCUser::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCGroup

// optional int64 appId = 1;
inline bool MIMCGroup::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCGroup::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCGroup::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCGroup::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 MIMCGroup::appid() const {
  return appid_;
}
inline void MIMCGroup::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional int64 topicId = 2;
inline bool MIMCGroup::has_topicid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCGroup::set_has_topicid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCGroup::clear_has_topicid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCGroup::clear_topicid() {
  topicid_ = GOOGLE_LONGLONG(0);
  clear_has_topicid();
}
inline ::google::protobuf::int64 MIMCGroup::topicid() const {
  return topicid_;
}
inline void MIMCGroup::set_topicid(::google::protobuf::int64 value) {
  set_has_topicid();
  topicid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mimc::ErrorCode>() {
  return ::mimc::ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mimc::MIMC_MSG_TYPE>() {
  return ::mimc::MIMC_MSG_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messaging_2dprotobuf_2fxiaomi_2dmimc_2fsrc_2fmain_2fproto_2fmimc_2eproto__INCLUDED
