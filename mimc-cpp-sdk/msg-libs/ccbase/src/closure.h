// This file was GENERATED by command:
//     pump.py closure.h.pump
// DO NOT EDIT BY HAND!!!

#ifndef _CCB_CLOSURE_H
#define _CCB_CLOSURE_H

#include <assert.h>
#include <atomic>
#include <utility>
#include "ccbase/common.h"

namespace ccb {

// Closure base class
class ClosureBase
{
public:
  virtual ~ClosureBase() {}
  virtual bool IsPermanent() const = 0;
};

// Closure template
template <typename Signature>
class Closure : public ClosureBase
{
public:
};

template <typename Signature>
class ClosureFunc
{
public:
};

// Closure specified for 0 arguments
template <
  typename R >
class Closure<R ()>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run() = 0;
  virtual Closure<R ()>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R ()>;
};

// forward declaraton for ClosureFunc
template <typename R, typename F> Closure<R ()>* NewPermanentClosure(F&&);

template <
  typename R >
class ClosureFunc<R ()>
{
public:
  typedef Closure<R ()> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept :
      ClosureFunc(NewPermanentClosure<R>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()() const { return p_->Run(); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 1 arguments
template <
  typename R , typename A1>
class Closure<R (A1)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1) = 0;
  virtual Closure<R (A1)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1,
    typename F> Closure<R (A1)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1>
class ClosureFunc<R (A1)>
{
public:
  typedef Closure<R (A1)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R,
      A1>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1) const { return p_->Run(a1); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 2 arguments
template <
  typename R , typename A1, typename A2>
class Closure<R (A1, A2)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2) = 0;
  virtual Closure<R (A1, A2)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1, A2)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename F> Closure<R (A1,
    A2)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2>
class ClosureFunc<R (A1, A2)>
{
public:
  typedef Closure<R (A1, A2)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1,
      A2>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1, A2 a2) const { return p_->Run(a1, a2); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 3 arguments
template <
  typename R , typename A1, typename A2, typename A3>
class Closure<R (A1, A2, A3)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3) = 0;
  virtual Closure<R (A1, A2, A3)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1, A2, A3)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3,
    typename F> Closure<R (A1, A2, A3)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3>
class ClosureFunc<R (A1, A2, A3)>
{
public:
  typedef Closure<R (A1, A2, A3)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2,
      A3>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1, A2 a2, A3 a3) const { return p_->Run(a1, a2, a3); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 4 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4>
class Closure<R (A1, A2, A3, A4)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4) = 0;
  virtual Closure<R (A1, A2, A3, A4)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1, A2, A3, A4)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename F> Closure<R (A1, A2, A3, A4)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4>
class ClosureFunc<R (A1, A2, A3, A4)>
{
public:
  typedef Closure<R (A1, A2, A3, A4)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4) const { return p_->Run(a1, a2, a3,
      a4); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 5 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5>
class Closure<R (A1, A2, A3, A4, A5)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) = 0;
  virtual Closure<R (A1, A2, A3, A4, A5)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1, A2, A3, A4, A5)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename F> Closure<R (A1, A2, A3, A4,
    A5)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5>
class ClosureFunc<R (A1, A2, A3, A4, A5)>
{
public:
  typedef Closure<R (A1, A2, A3, A4, A5)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4, A5>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const { return p_->Run(a1,
      a2, a3, a4, a5); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure specified for 6 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5,
      typename A6>
class Closure<R (A1, A2, A3, A4, A5, A6)>
  : public ClosureBase
{
public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) = 0;
  virtual Closure<R (A1, A2, A3, A4, A5, A6)>* Clone() = 0;
private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R (A1, A2, A3, A4, A5, A6)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename F> Closure<R (A1, A2, A3, A4, A5,
    A6)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5,
      typename A6>
class ClosureFunc<R (A1, A2, A3, A4, A5, A6)>
{
public:
  typedef Closure<R (A1, A2, A3, A4, A5, A6)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4, A5, A6>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) { assert(!p ||
      p->IsPermanent()); }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() { if (p_) p_->DelRef(); }
  operator bool() const { return static_cast<bool>(p_); }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
      A6 a6) const { return p_->Run(a1, a2, a3, a4, a5, a6); }
  void swap(ClosureFunc& c) { std::swap(p_, c.p_); }
  void reset(ClosureType* p = nullptr) { ClosureFunc(p).swap(*this); }
  ClosureFunc& operator=(const ClosureFunc& c) { ClosureFunc(c).swap(*this);
      return *this; }
  ClosureFunc& operator=(ClosureFunc&& c) {
      ClosureFunc(std::move(c)).swap(*this); return *this; }
private:
  ClosureType* get() const { return p_; }
  ClosureType* share() const { if(p_) p_->AddRef(); return p_; }
  ClosureType* release() { ClosureType* p = get(); p_ = nullptr; return p; }
  ClosureType* p_; // only PermanentClosure
};

// Closure deleter
template <bool Enabled, typename T>
class ConditionalAutoDeleter
{
public:
  explicit ConditionalAutoDeleter(T* p)
    : p_(p)
  {
  }
  ~ConditionalAutoDeleter()
  {
    if (Enabled)
      delete p_;
  }
private:
  ConditionalAutoDeleter(const ConditionalAutoDeleter&);
  ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
private:
  T* p_;
};

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass >
class MethodClosure_Arg0_Bind0 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)();
public:
  MethodClosure_Arg0_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind0> self_deleter(this);
    return (object_->*method_)();
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)()) {
  return new MethodClosure_Arg0_Bind0<false, R, Class, MethodClass>(
    object, method);
}

template <typename R, typename Class, typename MethodClass>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)()) {
  return new MethodClosure_Arg0_Bind0<true, R, Class, MethodClass>(
    object, method);
}

template <typename R, typename Class, typename MethodClass>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)()) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R>
class FunctionClosure_Arg0_Bind0 : public Closure<R ()> {
  typedef R (*FunctionType)();
public:
  FunctionClosure_Arg0_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind0> self_deleter(this);
    return function_();
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R>
Closure<R ()>*
NewClosure(R (*function)()) {
  return new FunctionClosure_Arg0_Bind0<false, R>(function);
}

template <typename R>
Closure<R ()>*
NewPermanentClosure(R (*function)()) {
  return new FunctionClosure_Arg0_Bind0<true, R>(function);
}

template <typename R>
ClosureFunc<R ()>
BindClosure(R (*function)()) {
  return ClosureFunc<R ()>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R>
class FunctorClosure_Arg0_Bind0 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg0_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind0> self_deleter(this);
    return functor_();
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename F>
Closure<R ()>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg0_Bind0<false, typename std::decay<F>::type, R>(
    std::forward<F>(functor));
}

template <typename R, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg0_Bind0<true, typename std::decay<F>::type, R>(
    std::forward<F>(functor));
}

template <typename R, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor) {
  return ClosureFunc<R ()>(NewPermanentClosure<R>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1 , typename PreArg1>
class MethodClosure_Arg0_Bind1 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1);
public:
  MethodClosure_Arg0_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1), PreArg1 pa1) {
  return new MethodClosure_Arg0_Bind1<false, R, Class, MethodClass, Arg1,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1),
    PreArg1 pa1) {
  return new MethodClosure_Arg0_Bind1<true, R, Class, MethodClass, Arg1,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1), PreArg1 pa1) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename PreArg1>
class FunctionClosure_Arg0_Bind1 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1);
public:
  FunctionClosure_Arg0_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind1> self_deleter(this);
    return function_(pa_1);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename PreArg1>
Closure<R ()>*
NewClosure(R (*function)(Arg1), PreArg1 pa1) {
  return new FunctionClosure_Arg0_Bind1<false, R, Arg1, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename PreArg1>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1), PreArg1 pa1) {
  return new FunctionClosure_Arg0_Bind1<true, R, Arg1, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename PreArg1>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1), PreArg1 pa1) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename PreArg1>
class FunctorClosure_Arg0_Bind1 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg0_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind1> self_deleter(this);
    return functor_(pa_1);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename PreArg1, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg0_Bind1<false, typename std::decay<F>::type, R,
      Arg1, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename PreArg1, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg0_Bind1<true, typename std::decay<F>::type, R,
      Arg1, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename PreArg1, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1,
      typename PreArg2>
class MethodClosure_Arg0_Bind2 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
  MethodClosure_Arg0_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1,
    PreArg2 pa2) {
  return new MethodClosure_Arg0_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg0_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg0_Bind2 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1, Arg2);
public:
  FunctionClosure_Arg0_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind2> self_deleter(this);
    return function_(pa_1, pa_2);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg0_Bind2<false, R, Arg1, Arg2, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg0_Bind2<true, R, Arg1, Arg2, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg0_Bind2 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg0_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg0_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg0_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1, Arg2, PreArg1,
      PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg0_Bind3 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
  MethodClosure_Arg0_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg0_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg0_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctionClosure_Arg0_Bind3 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
  FunctionClosure_Arg0_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg0_Bind3<false, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg0_Bind3<true, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctorClosure_Arg0_Bind3 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg0_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg0_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg0_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class MethodClosure_Arg0_Bind4 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
  MethodClosure_Arg0_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg0_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg0_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg0_Bind4 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
  FunctionClosure_Arg0_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg0_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg0_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg0_Bind4 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg0_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg0_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg0_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg0_Bind5 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg0_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg0_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg0_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctionClosure_Arg0_Bind5 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg0_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg0_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2, pa3,
      pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg0_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2, pa3,
      pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctorClosure_Arg0_Bind5 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg0_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg0_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg0_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(std::forward<F>(functor),
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class MethodClosure_Arg0_Bind6 : public Closure<R ()> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg0_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6);
  }
  virtual Closure<R ()>* Clone() {
    return new MethodClosure_Arg0_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg0_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg0_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R ()>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg0_Bind6 : public Closure<R ()> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg0_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctionClosure_Arg0_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg0_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(function,
      pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg0_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(function,
      pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R ()>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R ()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg0_Bind6 : public Closure<R ()> {
public:
  explicit FunctorClosure_Arg0_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg0_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6);
  }
  virtual Closure<R ()>* Clone() {
    return new FunctorClosure_Arg0_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R ()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg0_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R ()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg0_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
ClosureFunc<R ()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R ()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1 >
class MethodClosure_Arg1_Bind0 : public Closure<R (Arg1)> {
  typedef R (MethodClass::*MethodType)(Arg1);
public:
  MethodClosure_Arg1_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind0> self_deleter(this);
    return (object_->*method_)(arg1);
  }
  virtual Closure<R (Arg1)>* Clone() {
    return new MethodClosure_Arg1_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R (Arg1)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1)) {
  return new MethodClosure_Arg1_Bind0<false, R, Class, MethodClass, Arg1>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R (Arg1)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1)) {
  return new MethodClosure_Arg1_Bind0<true, R, Class, MethodClass, Arg1>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1>
ClosureFunc<R (Arg1)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1)) {
  return ClosureFunc<R (Arg1)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1>
class FunctionClosure_Arg1_Bind0 : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(Arg1);
public:
  FunctionClosure_Arg1_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind0> self_deleter(this);
    return function_(arg1);
  }
  virtual Closure<R (Arg1)>* Clone() {
    return new FunctionClosure_Arg1_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1>
Closure<R (Arg1)>*
NewClosure(R (*function)(Arg1)) {
  return new FunctionClosure_Arg1_Bind0<false, R, Arg1>(function);
}

template <typename R, typename Arg1>
Closure<R (Arg1)>*
NewPermanentClosure(R (*function)(Arg1)) {
  return new FunctionClosure_Arg1_Bind0<true, R, Arg1>(function);
}

template <typename R, typename Arg1>
ClosureFunc<R (Arg1)>
BindClosure(R (*function)(Arg1)) {
  return ClosureFunc<R (Arg1)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1>
class FunctorClosure_Arg1_Bind0 : public Closure<R (Arg1)> {
public:
  explicit FunctorClosure_Arg1_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg1_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind0> self_deleter(this);
    return functor_(arg1);
  }
  virtual Closure<R (Arg1)>* Clone() {
    return new FunctorClosure_Arg1_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename F>
Closure<R (Arg1)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg1_Bind0<false, typename std::decay<F>::type, R,
      Arg1>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename F>
Closure<R (Arg1)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg1_Bind0<true, typename std::decay<F>::type, R,
      Arg1>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename F>
ClosureFunc<R (Arg1)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1)>(NewPermanentClosure<R,
      Arg1>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1>
class MethodClosure_Arg1_Bind1 : public Closure<R (Arg2)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
  MethodClosure_Arg1_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2);
  }
  virtual Closure<R (Arg2)>* Clone() {
    return new MethodClosure_Arg1_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1) {
  return new MethodClosure_Arg1_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2),
    PreArg1 pa1) {
  return new MethodClosure_Arg1_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
ClosureFunc<R (Arg2)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1) {
  return ClosureFunc<R (Arg2)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename PreArg1>
class FunctionClosure_Arg1_Bind1 : public Closure<R (Arg2)> {
  typedef R (*FunctionType)(Arg1, Arg2);
public:
  FunctionClosure_Arg1_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind1> self_deleter(this);
    return function_(pa_1, arg2);
  }
  virtual Closure<R (Arg2)>* Clone() {
    return new FunctionClosure_Arg1_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewClosure(R (*function)(Arg1, Arg2), PreArg1 pa1) {
  return new FunctionClosure_Arg1_Bind1<false, R, Arg1, Arg2,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewPermanentClosure(R (*function)(Arg1, Arg2), PreArg1 pa1) {
  return new FunctionClosure_Arg1_Bind1<true, R, Arg1, Arg2, PreArg1>(function,
      pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
ClosureFunc<R (Arg2)>
BindClosure(R (*function)(Arg1, Arg2), PreArg1 pa1) {
  return ClosureFunc<R (Arg2)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename PreArg1>
class FunctorClosure_Arg1_Bind1 : public Closure<R (Arg2)> {
public:
  explicit FunctorClosure_Arg1_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg1_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind1> self_deleter(this);
    return functor_(pa_1, arg2);
  }
  virtual Closure<R (Arg2)>* Clone() {
    return new FunctorClosure_Arg1_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
Closure<R (Arg2)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg1_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
Closure<R (Arg2)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg1_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
ClosureFunc<R (Arg2)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2)>(NewPermanentClosure<R, Arg1, Arg2,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1, typename PreArg2>
class MethodClosure_Arg1_Bind2 : public Closure<R (Arg3)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
  MethodClosure_Arg1_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3);
  }
  virtual Closure<R (Arg3)>* Clone() {
    return new MethodClosure_Arg1_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg1_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg1_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2>
class FunctionClosure_Arg1_Bind2 : public Closure<R (Arg3)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
  FunctionClosure_Arg1_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3);
  }
  virtual Closure<R (Arg3)>* Clone() {
    return new FunctionClosure_Arg1_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg1_Bind2<false, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg1_Bind2<true, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3)>
BindClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2>
class FunctorClosure_Arg1_Bind2 : public Closure<R (Arg3)> {
public:
  explicit FunctorClosure_Arg1_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg1_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3);
  }
  virtual Closure<R (Arg3)>* Clone() {
    return new FunctorClosure_Arg1_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg1_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg1_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R (Arg3)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg1_Bind3 : public Closure<R (Arg4)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
  MethodClosure_Arg1_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4);
  }
  virtual Closure<R (Arg4)>* Clone() {
    return new MethodClosure_Arg1_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg1_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg1_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg1_Bind3 : public Closure<R (Arg4)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
  FunctionClosure_Arg1_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4);
  }
  virtual Closure<R (Arg4)>* Clone() {
    return new FunctionClosure_Arg1_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg1_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg1_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return ClosureFunc<R (Arg4)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg1_Bind3 : public Closure<R (Arg4)> {
public:
  explicit FunctorClosure_Arg1_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg1_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4);
  }
  virtual Closure<R (Arg4)>* Clone() {
    return new FunctorClosure_Arg1_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R (Arg4)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg1_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R (Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg1_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
ClosureFunc<R (Arg4)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class MethodClosure_Arg1_Bind4 : public Closure<R (Arg5)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg1_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5);
  }
  virtual Closure<R (Arg5)>* Clone() {
    return new MethodClosure_Arg1_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg1_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg1_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctionClosure_Arg1_Bind4 : public Closure<R (Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg1_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5);
  }
  virtual Closure<R (Arg5)>* Clone() {
    return new FunctionClosure_Arg1_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg1_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg1_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5)>(NewPermanentClosure(function, pa1, pa2, pa3,
      pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctorClosure_Arg1_Bind4 : public Closure<R (Arg5)> {
public:
  explicit FunctorClosure_Arg1_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg1_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5);
  }
  virtual Closure<R (Arg5)>* Clone() {
    return new FunctorClosure_Arg1_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg1_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg1_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R (Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(std::forward<F>(functor), pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg1_Bind5 : public Closure<R (Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg1_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6);
  }
  virtual Closure<R (Arg6)>* Clone() {
    return new MethodClosure_Arg1_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg1_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg1_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R (Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg1_Bind5 : public Closure<R (Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg1_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6);
  }
  virtual Closure<R (Arg6)>* Clone() {
    return new FunctionClosure_Arg1_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg1_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
      pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg1_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
      pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6)>(NewPermanentClosure(function, pa1, pa2, pa3,
      pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg1_Bind5 : public Closure<R (Arg6)> {
public:
  explicit FunctorClosure_Arg1_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg1_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6);
  }
  virtual Closure<R (Arg6)>* Clone() {
    return new FunctorClosure_Arg1_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R (Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg1_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R (Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg1_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
ClosureFunc<R (Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class MethodClosure_Arg1_Bind6 : public Closure<R (Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg1_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7);
  }
  virtual Closure<R (Arg7)>* Clone() {
    return new MethodClosure_Arg1_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg1_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg1_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctionClosure_Arg1_Bind6 : public Closure<R (Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg1_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7);
  }
  virtual Closure<R (Arg7)>* Clone() {
    return new FunctionClosure_Arg1_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg1_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg1_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R (Arg7)>(NewPermanentClosure(function, pa1, pa2, pa3,
      pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctorClosure_Arg1_Bind6 : public Closure<R (Arg7)> {
public:
  explicit FunctorClosure_Arg1_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg1_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7);
  }
  virtual Closure<R (Arg7)>* Clone() {
    return new FunctorClosure_Arg1_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg1_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg1_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R (Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 >
class MethodClosure_Arg2_Bind0 : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
  MethodClosure_Arg2_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2);
  }
  virtual Closure<R (Arg1, Arg2)>* Clone() {
    return new MethodClosure_Arg2_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2)) {
  return new MethodClosure_Arg2_Bind0<false, R, Class, MethodClass, Arg1, Arg2>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2)) {
  return new MethodClosure_Arg2_Bind0<true, R, Class, MethodClass, Arg1, Arg2>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
ClosureFunc<R (Arg1, Arg2)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2)) {
  return ClosureFunc<R (Arg1, Arg2)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2>
class FunctionClosure_Arg2_Bind0 : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(Arg1, Arg2);
public:
  FunctionClosure_Arg2_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind0> self_deleter(this);
    return function_(arg1, arg2);
  }
  virtual Closure<R (Arg1, Arg2)>* Clone() {
    return new FunctionClosure_Arg2_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>*
NewClosure(R (*function)(Arg1, Arg2)) {
  return new FunctionClosure_Arg2_Bind0<false, R, Arg1, Arg2>(function);
}

template <typename R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>*
NewPermanentClosure(R (*function)(Arg1, Arg2)) {
  return new FunctionClosure_Arg2_Bind0<true, R, Arg1, Arg2>(function);
}

template <typename R, typename Arg1, typename Arg2>
ClosureFunc<R (Arg1, Arg2)>
BindClosure(R (*function)(Arg1, Arg2)) {
  return ClosureFunc<R (Arg1, Arg2)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2>
class FunctorClosure_Arg2_Bind0 : public Closure<R (Arg1, Arg2)> {
public:
  explicit FunctorClosure_Arg2_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg2_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind0> self_deleter(this);
    return functor_(arg1, arg2);
  }
  virtual Closure<R (Arg1, Arg2)>* Clone() {
    return new FunctorClosure_Arg2_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename F>
Closure<R (Arg1, Arg2)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg2_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename F>
Closure<R (Arg1, Arg2)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg2_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename F>
ClosureFunc<R (Arg1, Arg2)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1, Arg2)>(NewPermanentClosure<R, Arg1,
      Arg2>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1>
class MethodClosure_Arg2_Bind1 : public Closure<R (Arg2, Arg3)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
  MethodClosure_Arg2_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2, arg3);
  }
  virtual Closure<R (Arg2, Arg3)>* Clone() {
    return new MethodClosure_Arg2_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return new MethodClosure_Arg2_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return new MethodClosure_Arg2_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
ClosureFunc<R (Arg2, Arg3)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1>
class FunctionClosure_Arg2_Bind1 : public Closure<R (Arg2, Arg3)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
  FunctionClosure_Arg2_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind1> self_deleter(this);
    return function_(pa_1, arg2, arg3);
  }
  virtual Closure<R (Arg2, Arg3)>* Clone() {
    return new FunctionClosure_Arg2_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return new FunctionClosure_Arg2_Bind1<false, R, Arg1, Arg2, Arg3,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return new FunctionClosure_Arg2_Bind1<true, R, Arg1, Arg2, Arg3,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
ClosureFunc<R (Arg2, Arg3)>
BindClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1>
class FunctorClosure_Arg2_Bind1 : public Closure<R (Arg2, Arg3)> {
public:
  explicit FunctorClosure_Arg2_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg2_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind1> self_deleter(this);
    return functor_(pa_1, arg2, arg3);
  }
  virtual Closure<R (Arg2, Arg3)>* Clone() {
    return new FunctorClosure_Arg2_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
Closure<R (Arg2, Arg3)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg2_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
Closure<R (Arg2, Arg3)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg2_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
ClosureFunc<R (Arg2, Arg3)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg2_Bind2 : public Closure<R (Arg3, Arg4)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
  MethodClosure_Arg2_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3, arg4);
  }
  virtual Closure<R (Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg2_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg2_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg2_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
ClosureFunc<R (Arg3, Arg4)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4)>(NewPermanentClosure(object, method, pa1,
      pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2>
class FunctionClosure_Arg2_Bind2 : public Closure<R (Arg3, Arg4)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
  FunctionClosure_Arg2_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3, arg4);
  }
  virtual Closure<R (Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg2_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg2_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg2_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2>
class FunctorClosure_Arg2_Bind2 : public Closure<R (Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg2_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg2_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3, arg4);
  }
  virtual Closure<R (Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg2_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg2_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg2_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R (Arg3, Arg4)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3>
class MethodClosure_Arg2_Bind3 : public Closure<R (Arg4, Arg5)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg2_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4, arg5);
  }
  virtual Closure<R (Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg2_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg2_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg2_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg2_Bind3 : public Closure<R (Arg4, Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg2_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4, arg5);
  }
  virtual Closure<R (Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg2_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg2_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg2_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R (Arg4, Arg5)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5)>(NewPermanentClosure(function, pa1, pa2,
      pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg2_Bind3 : public Closure<R (Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg2_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg2_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4, arg5);
  }
  virtual Closure<R (Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg2_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
Closure<R (Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg2_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
Closure<R (Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg2_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
ClosureFunc<R (Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg2_Bind4 : public Closure<R (Arg5, Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg2_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5, arg6);
  }
  virtual Closure<R (Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg2_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg2_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg2_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctionClosure_Arg2_Bind4 : public Closure<R (Arg5, Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg2_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5, arg6);
  }
  virtual Closure<R (Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg2_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg2_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg2_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctorClosure_Arg2_Bind4 : public Closure<R (Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg2_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg2_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5, arg6);
  }
  virtual Closure<R (Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg2_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg2_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg2_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R (Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class MethodClosure_Arg2_Bind5 : public Closure<R (Arg6, Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg2_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7);
  }
  virtual Closure<R (Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg2_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg2_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg2_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg2_Bind5 : public Closure<R (Arg6, Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg2_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7);
  }
  virtual Closure<R (Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg2_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg2_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
      pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg2_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
      pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R (Arg6, Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg2_Bind5 : public Closure<R (Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg2_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg2_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7);
  }
  virtual Closure<R (Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg2_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R (Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg2_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R (Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg2_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
ClosureFunc<R (Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg2_Bind6 : public Closure<R (Arg7, Arg8)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8);
public:
  MethodClosure_Arg2_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8);
  }
  virtual Closure<R (Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg2_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg2_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg2_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctionClosure_Arg2_Bind6 : public Closure<R (Arg7, Arg8)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
  FunctionClosure_Arg2_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8);
  }
  virtual Closure<R (Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg2_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg2_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg2_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctorClosure_Arg2_Bind6 : public Closure<R (Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg2_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg2_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8);
  }
  virtual Closure<R (Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg2_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg2_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg2_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R (Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 >
class MethodClosure_Arg3_Bind0 : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
  MethodClosure_Arg3_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3);
  }
  virtual Closure<R (Arg1, Arg2, Arg3)>* Clone() {
    return new MethodClosure_Arg3_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_Arg3_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_Arg3_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
ClosureFunc<R (Arg1, Arg2, Arg3)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_Arg3_Bind0 : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
  FunctionClosure_Arg3_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3);
  }
  virtual Closure<R (Arg1, Arg2, Arg3)>* Clone() {
    return new FunctionClosure_Arg3_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_Arg3_Bind0<false, R, Arg1, Arg2, Arg3>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_Arg3_Bind0<true, R, Arg1, Arg2, Arg3>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3>
ClosureFunc<R (Arg1, Arg2, Arg3)>
BindClosure(R (*function)(Arg1, Arg2, Arg3)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3>
class FunctorClosure_Arg3_Bind0 : public Closure<R (Arg1, Arg2, Arg3)> {
public:
  explicit FunctorClosure_Arg3_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg3_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3);
  }
  virtual Closure<R (Arg1, Arg2, Arg3)>* Clone() {
    return new FunctorClosure_Arg3_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
Closure<R (Arg1, Arg2, Arg3)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg3_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
Closure<R (Arg1, Arg2, Arg3)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg3_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
ClosureFunc<R (Arg1, Arg2, Arg3)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1, Arg2, Arg3)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1>
class MethodClosure_Arg3_Bind1 : public Closure<R (Arg2, Arg3, Arg4)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
  MethodClosure_Arg3_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg2, Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg3_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1) {
  return new MethodClosure_Arg3_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1) {
  return new MethodClosure_Arg3_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4)>(NewPermanentClosure(object, method,
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1>
class FunctionClosure_Arg3_Bind1 : public Closure<R (Arg2, Arg3, Arg4)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
  FunctionClosure_Arg3_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind1> self_deleter(this);
    return function_(pa_1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg2, Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg3_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return new FunctionClosure_Arg3_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return new FunctionClosure_Arg3_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1>
class FunctorClosure_Arg3_Bind1 : public Closure<R (Arg2, Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg3_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg3_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind1> self_deleter(this);
    return functor_(pa_1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg2, Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg3_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg3_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg3_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
ClosureFunc<R (Arg2, Arg3, Arg4)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg3_Bind2 : public Closure<R (Arg3, Arg4, Arg5)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg3_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg3_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg3_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg3_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5)>(NewPermanentClosure(object, method,
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg3_Bind2 : public Closure<R (Arg3, Arg4, Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg3_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg3_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg3_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg3_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5)>(NewPermanentClosure(function, pa1,
      pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg3_Bind2 : public Closure<R (Arg3, Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg3_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg3_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg3_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
Closure<R (Arg3, Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg3_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
Closure<R (Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg3_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
ClosureFunc<R (Arg3, Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3>
class MethodClosure_Arg3_Bind3 : public Closure<R (Arg4, Arg5, Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg3_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg3_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg3_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg3_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3>
class FunctionClosure_Arg3_Bind3 : public Closure<R (Arg4, Arg5, Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg3_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg3_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg3_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg3_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6)>(NewPermanentClosure(function, pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3>
class FunctorClosure_Arg3_Bind3 : public Closure<R (Arg4, Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg3_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg3_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg3_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg3_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg3_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R (Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg3_Bind4 : public Closure<R (Arg5, Arg6, Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg3_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg3_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg3_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg3_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg3_Bind4 : public Closure<R (Arg5, Arg6, Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg3_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg3_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg3_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
      pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg3_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
      pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg3_Bind4 : public Closure<R (Arg5, Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg3_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg3_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg3_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R (Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg3_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R (Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg3_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
ClosureFunc<R (Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class MethodClosure_Arg3_Bind5 : public Closure<R (Arg6, Arg7, Arg8)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8);
public:
  MethodClosure_Arg3_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg3_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg3_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg3_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class FunctionClosure_Arg3_Bind5 : public Closure<R (Arg6, Arg7, Arg8)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
  FunctionClosure_Arg3_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg3_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg3_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function,
      pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg3_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function,
      pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class FunctorClosure_Arg3_Bind5 : public Closure<R (Arg6, Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg3_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg3_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg3_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg3_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg3_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
ClosureFunc<R (Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg3_Bind6 : public Closure<R (Arg7, Arg8, Arg9)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9);
public:
  MethodClosure_Arg3_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8,
        arg9);
  }
  virtual Closure<R (Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg3_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg3_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg3_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg3_Bind6 : public Closure<R (Arg7, Arg8, Arg9)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
public:
  FunctionClosure_Arg3_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg3_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg3_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg3_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
    Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg3_Bind6 : public Closure<R (Arg7, Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg3_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg3_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg3_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg3_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg3_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R (Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4,
      pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 >
class MethodClosure_Arg4_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
  MethodClosure_Arg4_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg4_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return new MethodClosure_Arg4_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4)) {
  return new MethodClosure_Arg4_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure(object,
      method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctionClosure_Arg4_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
  FunctionClosure_Arg4_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg4_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_Arg4_Bind0<false, R, Arg1, Arg2, Arg3,
      Arg4>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_Arg4_Bind0<true, R, Arg1, Arg2, Arg3,
      Arg4>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctorClosure_Arg4_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg4_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg4_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg4_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg4_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg4_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1>
class MethodClosure_Arg4_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg4_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg4_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1) {
  return new MethodClosure_Arg4_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1) {
  return new MethodClosure_Arg4_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure(object,
      method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1>
class FunctionClosure_Arg4_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg4_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind1> self_deleter(this);
    return function_(pa_1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg4_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return new FunctionClosure_Arg4_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return new FunctionClosure_Arg4_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure(function,
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1>
class FunctorClosure_Arg4_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg4_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg4_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind1> self_deleter(this);
    return functor_(pa_1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg4_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg4_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg4_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2>
class MethodClosure_Arg4_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg4_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg4_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg4_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg4_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure(object,
      method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg4_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg4_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg4_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg4_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg4_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure(function,
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg4_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg4_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg4_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg4_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg4_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg4_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(std::forward<F>(functor),
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg4_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg4_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg4_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg4_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg4_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctionClosure_Arg4_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg4_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg4_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg4_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg4_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure(function,
      pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctorClosure_Arg4_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg4_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg4_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg4_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg4_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg4_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class MethodClosure_Arg4_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8);
public:
  MethodClosure_Arg4_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg4_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg4_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg4_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg4_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
  FunctionClosure_Arg4_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg4_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg4_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
      pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg4_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
      pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg4_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg4_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg4_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg4_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg4_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg4_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg4_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9);
public:
  MethodClosure_Arg4_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8,
        arg9);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg4_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg4_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg4_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctionClosure_Arg4_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
public:
  FunctionClosure_Arg4_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg4_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg4_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg4_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
    Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctorClosure_Arg4_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg4_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg4_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg4_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg4_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg4_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4,
      pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class MethodClosure_Arg4_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10);
public:
  MethodClosure_Arg4_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8,
        arg9, arg10);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg4_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg4_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg4_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg4_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
public:
  FunctionClosure_Arg4_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg4_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg4_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg4_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg4_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10)> {
public:
  explicit FunctorClosure_Arg4_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg4_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg4_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg4_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg4_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 >
class MethodClosure_Arg5_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  MethodClosure_Arg5_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg5_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5)) {
  return new MethodClosure_Arg5_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5)) {
  return new MethodClosure_Arg5_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4,
      Arg5)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5>
class FunctionClosure_Arg5_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
  FunctionClosure_Arg5_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg5_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_Arg5_Bind0<false, R, Arg1, Arg2, Arg3, Arg4,
      Arg5>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_Arg5_Bind0<true, R, Arg1, Arg2, Arg3, Arg4,
      Arg5>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4,
      Arg5)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5>
class FunctorClosure_Arg5_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
public:
  explicit FunctorClosure_Arg5_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg5_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg5_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg5_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg5_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1>
class MethodClosure_Arg5_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg5_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg5_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1) {
  return new MethodClosure_Arg5_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1) {
  return new MethodClosure_Arg5_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1>
class FunctionClosure_Arg5_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg5_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind1> self_deleter(this);
    return function_(pa_1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg5_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1) {
  return new FunctionClosure_Arg5_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1) {
  return new FunctionClosure_Arg5_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1>
class FunctorClosure_Arg5_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
public:
  explicit FunctorClosure_Arg5_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg5_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind1> self_deleter(this);
    return functor_(pa_1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg5_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg5_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg5_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(std::forward<F>(functor),
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2>
class MethodClosure_Arg5_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg5_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg5_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg5_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg5_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2>
class FunctionClosure_Arg5_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg5_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg5_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg5_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg5_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2>
class FunctorClosure_Arg5_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
public:
  explicit FunctorClosure_Arg5_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg5_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg5_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg5_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg5_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1,
      PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg5_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8);
public:
  MethodClosure_Arg5_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg5_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg5_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg5_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg5_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
  FunctionClosure_Arg5_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg5_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg5_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg5_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg5_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
public:
  explicit FunctorClosure_Arg5_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg5_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg5_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg5_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg5_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class MethodClosure_Arg5_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9);
public:
  MethodClosure_Arg5_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8,
        arg9);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg5_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg5_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg5_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctionClosure_Arg5_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
public:
  FunctionClosure_Arg5_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg5_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg5_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4>(function,
      pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg5_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4>(function,
      pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
    Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctorClosure_Arg5_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
public:
  explicit FunctorClosure_Arg5_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg5_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg5_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg5_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg5_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg5_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10);
public:
  MethodClosure_Arg5_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8,
        arg9, arg10);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg5_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg5_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg5_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg5_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
public:
  FunctionClosure_Arg5_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg5_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg5_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg5_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg5_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
public:
  explicit FunctorClosure_Arg5_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg5_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg5_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg5_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg5_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class MethodClosure_Arg5_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10, Arg11);
public:
  MethodClosure_Arg5_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8,
        arg9, arg10, arg11);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new MethodClosure_Arg5_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg5_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg5_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctionClosure_Arg5_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11);
public:
  FunctionClosure_Arg5_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctionClosure_Arg5_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg5_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg5_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctorClosure_Arg5_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
public:
  explicit FunctorClosure_Arg5_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg5_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctorClosure_Arg5_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg5_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg5_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 >
class MethodClosure_Arg6_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  MethodClosure_Arg6_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg6_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)) {
  return new MethodClosure_Arg6_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6)) {
  return new MethodClosure_Arg6_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6>
class FunctionClosure_Arg6_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
  FunctionClosure_Arg6_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg6_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_Arg6_Bind0<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_Arg6_Bind0<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6>
class FunctorClosure_Arg6_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg6_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg6_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg6_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg6_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg6_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1>
class MethodClosure_Arg6_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7);
public:
  MethodClosure_Arg6_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg6_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1) {
  return new MethodClosure_Arg6_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1) {
  return new MethodClosure_Arg6_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1>
class FunctionClosure_Arg6_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
  FunctionClosure_Arg6_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind1> self_deleter(this);
    return function_(pa_1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg6_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return new FunctionClosure_Arg6_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return new FunctionClosure_Arg6_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1>
class FunctorClosure_Arg6_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg6_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1(pa1) {}
  explicit FunctorClosure_Arg6_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind1> self_deleter(this);
    return functor_(pa_1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg6_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg6_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg6_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg6_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7, Arg8)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8);
public:
  MethodClosure_Arg6_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg6_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg6_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg6_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2>
class FunctionClosure_Arg6_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7, Arg8)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
  FunctionClosure_Arg6_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind2> self_deleter(this);
    return function_(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg6_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg6_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg6_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2>
class FunctorClosure_Arg6_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
    Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg6_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1(pa1), pa_2(pa2) {}
  explicit FunctorClosure_Arg6_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind2> self_deleter(this);
    return functor_(pa_1, pa_2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg6_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg6_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg6_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3>
class MethodClosure_Arg6_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9);
public:
  MethodClosure_Arg6_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8,
        arg9);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg6_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg6_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new MethodClosure_Arg6_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg6_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
public:
  FunctionClosure_Arg6_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind3> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg6_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg6_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
      pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg6_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
      pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
    Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg6_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg6_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  explicit FunctorClosure_Arg6_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind3> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg6_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg6_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg6_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg6_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9, Arg10)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10);
public:
  MethodClosure_Arg6_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8,
        arg9, arg10);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg6_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg6_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg6_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctionClosure_Arg6_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9, Arg10)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
public:
  FunctionClosure_Arg6_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind4> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg6_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg6_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg6_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctorClosure_Arg6_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
    Arg9, Arg10)> {
public:
  explicit FunctorClosure_Arg6_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4) {}
  explicit FunctorClosure_Arg6_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind4> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, arg5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg6_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg6_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg6_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class MethodClosure_Arg6_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10, Arg11);
public:
  MethodClosure_Arg6_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8,
        arg9, arg10, arg11);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new MethodClosure_Arg6_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg6_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg6_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg6_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11);
public:
  FunctionClosure_Arg6_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind5> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctionClosure_Arg6_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg6_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg6_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg6_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
public:
  explicit FunctorClosure_Arg6_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  explicit FunctorClosure_Arg6_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind5> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, arg6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctorClosure_Arg6_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg6_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg6_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11,
      typename Arg12 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg6_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
  typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7, Arg8, Arg9, Arg10, Arg11, Arg12);
public:
  MethodClosure_Arg6_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1(pa1), pa_2(pa2), pa_3(pa3),
        pa_4(pa4), pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8,
        arg9, arg10, arg11, arg12);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new MethodClosure_Arg6_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg6_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg6_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename Arg12,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctionClosure_Arg6_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11, Arg12);
public:
  FunctionClosure_Arg6_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind6> self_deleter(this);
    return function_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10, arg11, arg12);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new FunctionClosure_Arg6_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
private:
  FunctionType function_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg6_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg6_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename Arg12,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctorClosure_Arg6_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
public:
  explicit FunctorClosure_Arg6_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4), pa_5(pa5),
        pa_6(pa6) {}
  explicit FunctorClosure_Arg6_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1(pa1), pa_2(pa2), pa_3(pa3), pa_4(pa4),
        pa_5(pa5), pa_6(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind6> self_deleter(this);
    return functor_(pa_1, pa_2, pa_3, pa_4, pa_5, pa_6, arg7, arg8, arg9,
        arg10, arg11, arg12);
  }
  virtual Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new FunctorClosure_Arg6_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1;
  PreArg2 pa_2;
  PreArg3 pa_3;
  PreArg4 pa_4;
  PreArg5 pa_5;
  PreArg6 pa_6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg6_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg6_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closure helper
/////////////////////////////////////////////////////////////////////////////

template <typename F>
auto NewClosure(F&& functor) -> Closure<decltype(functor())()>* {
  return new FunctorClosure_Arg0_Bind0<false, typename std::decay<F>::type,
      decltype(functor())>(std::forward<F>(functor));
}

template <typename F>
auto NewPermanentClosure(F&& functor) -> Closure<decltype(functor())()>* {
  return new FunctorClosure_Arg0_Bind0<true, typename std::decay<F>::type,
      decltype(functor())>(std::forward<F>(functor));
}

template <typename F>
auto BindClosure(F&& functor) -> ClosureFunc<decltype(functor())()> {
  return

      ClosureFunc<decltype(functor())()>(NewPermanentClosure(std::forward<F>(functor)));
}

} // namespace ccb

#endif // _CCB_CLOSURE_H
