// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ims_push_service.proto

#ifndef PROTOBUF_ims_5fpush_5fservice_2eproto__INCLUDED
#define PROTOBUF_ims_5fpush_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "control_message.pb.h"
// @@protoc_insertion_point(includes)

namespace ims {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

class ClientHeader;
class XMMsgConn;
class XMMsgConnResp;
class XMMsgBind;
class XMMsgBindResp;
class XMMsgPing;
class XMMsgNotify;

enum ClientHeader_MSG_DIR_FLAG {
  ClientHeader_MSG_DIR_FLAG_CS_ONEWAY = 1,
  ClientHeader_MSG_DIR_FLAG_CS_REQ = 2,
  ClientHeader_MSG_DIR_FLAG_CS_RESP = 3,
  ClientHeader_MSG_DIR_FLAG_SC_ONEWAY = 4,
  ClientHeader_MSG_DIR_FLAG_SC_REQ = 5,
  ClientHeader_MSG_DIR_FLAG_SC_RESP = 6
};
bool ClientHeader_MSG_DIR_FLAG_IsValid(int value);
const ClientHeader_MSG_DIR_FLAG ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_MIN = ClientHeader_MSG_DIR_FLAG_CS_ONEWAY;
const ClientHeader_MSG_DIR_FLAG ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_MAX = ClientHeader_MSG_DIR_FLAG_SC_RESP;
const int ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_ARRAYSIZE = ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_MAX + 1;

// ===================================================================

class ClientHeader : public ::google::protobuf::MessageLite {
 public:
  ClientHeader();
  virtual ~ClientHeader();

  ClientHeader(const ClientHeader& from);

  inline ClientHeader& operator=(const ClientHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientHeader* other);

  // implements Message ----------------------------------------------

  ClientHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientHeader& from);
  void MergeFrom(const ClientHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientHeader_MSG_DIR_FLAG MSG_DIR_FLAG;
  static const MSG_DIR_FLAG CS_ONEWAY = ClientHeader_MSG_DIR_FLAG_CS_ONEWAY;
  static const MSG_DIR_FLAG CS_REQ = ClientHeader_MSG_DIR_FLAG_CS_REQ;
  static const MSG_DIR_FLAG CS_RESP = ClientHeader_MSG_DIR_FLAG_CS_RESP;
  static const MSG_DIR_FLAG SC_ONEWAY = ClientHeader_MSG_DIR_FLAG_SC_ONEWAY;
  static const MSG_DIR_FLAG SC_REQ = ClientHeader_MSG_DIR_FLAG_SC_REQ;
  static const MSG_DIR_FLAG SC_RESP = ClientHeader_MSG_DIR_FLAG_SC_RESP;
  static inline bool MSG_DIR_FLAG_IsValid(int value) {
    return ClientHeader_MSG_DIR_FLAG_IsValid(value);
  }
  static const MSG_DIR_FLAG MSG_DIR_FLAG_MIN =
    ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_MIN;
  static const MSG_DIR_FLAG MSG_DIR_FLAG_MAX =
    ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_MAX;
  static const int MSG_DIR_FLAG_ARRAYSIZE =
    ClientHeader_MSG_DIR_FLAG_MSG_DIR_FLAG_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 chid = 1;
  inline bool has_chid() const;
  inline void clear_chid();
  static const int kChidFieldNumber = 1;
  inline ::google::protobuf::int32 chid() const;
  inline void set_chid(::google::protobuf::int32 value);

  // optional int64 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string server = 3;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 3;
  inline const ::std::string& server() const;
  inline void set_server(const ::std::string& value);
  inline void set_server(const char* value);
  inline void set_server(const char* value, size_t size);
  inline ::std::string* mutable_server();
  inline ::std::string* release_server();
  inline void set_allocated_server(::std::string* server);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional string cmd = 5;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 5;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // optional string subcmd = 6;
  inline bool has_subcmd() const;
  inline void clear_subcmd();
  static const int kSubcmdFieldNumber = 6;
  inline const ::std::string& subcmd() const;
  inline void set_subcmd(const ::std::string& value);
  inline void set_subcmd(const char* value);
  inline void set_subcmd(const char* value, size_t size);
  inline ::std::string* mutable_subcmd();
  inline ::std::string* release_subcmd();
  inline void set_allocated_subcmd(::std::string* subcmd);

  // optional string id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .ims.ClientHeader.MSG_DIR_FLAG dir_flag = 8;
  inline bool has_dir_flag() const;
  inline void clear_dir_flag();
  static const int kDirFlagFieldNumber = 8;
  inline ::ims::ClientHeader_MSG_DIR_FLAG dir_flag() const;
  inline void set_dir_flag(::ims::ClientHeader_MSG_DIR_FLAG value);

  // optional int32 cipher = 9;
  inline bool has_cipher() const;
  inline void clear_cipher();
  static const int kCipherFieldNumber = 9;
  inline ::google::protobuf::int32 cipher() const;
  inline void set_cipher(::google::protobuf::int32 value);

  // optional int32 err_code = 10;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 10;
  inline ::google::protobuf::int32 err_code() const;
  inline void set_err_code(::google::protobuf::int32 value);

  // optional string err_str = 11;
  inline bool has_err_str() const;
  inline void clear_err_str();
  static const int kErrStrFieldNumber = 11;
  inline const ::std::string& err_str() const;
  inline void set_err_str(const ::std::string& value);
  inline void set_err_str(const char* value);
  inline void set_err_str(const char* value, size_t size);
  inline ::std::string* mutable_err_str();
  inline ::std::string* release_err_str();
  inline void set_allocated_err_str(::std::string* err_str);

  // @@protoc_insertion_point(class_scope:ims.ClientHeader)
 private:
  inline void set_has_chid();
  inline void clear_has_chid();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_subcmd();
  inline void clear_has_subcmd();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dir_flag();
  inline void clear_has_dir_flag();
  inline void set_has_cipher();
  inline void clear_has_cipher();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_err_str();
  inline void clear_has_err_str();

  ::google::protobuf::int64 uuid_;
  ::std::string* server_;
  ::std::string* resource_;
  ::google::protobuf::int32 chid_;
  int dir_flag_;
  ::std::string* cmd_;
  ::std::string* subcmd_;
  ::std::string* id_;
  ::google::protobuf::int32 cipher_;
  ::google::protobuf::int32 err_code_;
  ::std::string* err_str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ClientHeader* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgConn : public ::google::protobuf::MessageLite {
 public:
  XMMsgConn();
  virtual ~XMMsgConn();

  XMMsgConn(const XMMsgConn& from);

  inline XMMsgConn& operator=(const XMMsgConn& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgConn& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgConn* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgConn* other);

  // implements Message ----------------------------------------------

  XMMsgConn* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgConn& from);
  void MergeFrom(const XMMsgConn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional string model = 2;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 2;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string os = 3;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 3;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string udid = 4;
  inline bool has_udid() const;
  inline void clear_udid();
  static const int kUdidFieldNumber = 4;
  inline const ::std::string& udid() const;
  inline void set_udid(const ::std::string& value);
  inline void set_udid(const char* value);
  inline void set_udid(const char* value, size_t size);
  inline ::std::string* mutable_udid();
  inline ::std::string* release_udid();
  inline void set_allocated_udid(::std::string* udid);

  // optional int32 sdk = 5;
  inline bool has_sdk() const;
  inline void clear_sdk();
  static const int kSdkFieldNumber = 5;
  inline ::google::protobuf::int32 sdk() const;
  inline void set_sdk(::google::protobuf::int32 value);

  // optional string connpt = 6;
  inline bool has_connpt() const;
  inline void clear_connpt();
  static const int kConnptFieldNumber = 6;
  inline const ::std::string& connpt() const;
  inline void set_connpt(const ::std::string& value);
  inline void set_connpt(const char* value);
  inline void set_connpt(const char* value, size_t size);
  inline ::std::string* mutable_connpt();
  inline ::std::string* release_connpt();
  inline void set_allocated_connpt(::std::string* connpt);

  // optional string host = 7;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 7;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string locale = 8;
  inline bool has_locale() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 8;
  inline const ::std::string& locale() const;
  inline void set_locale(const ::std::string& value);
  inline void set_locale(const char* value);
  inline void set_locale(const char* value, size_t size);
  inline ::std::string* mutable_locale();
  inline ::std::string* release_locale();
  inline void set_allocated_locale(::std::string* locale);

  // optional .protocol.PushServiceConfigMsg psc = 9;
  inline bool has_psc() const;
  inline void clear_psc();
  static const int kPscFieldNumber = 9;
  inline const ::protocol::PushServiceConfigMsg& psc() const;
  inline ::protocol::PushServiceConfigMsg* mutable_psc();
  inline ::protocol::PushServiceConfigMsg* release_psc();
  inline void set_allocated_psc(::protocol::PushServiceConfigMsg* psc);

  // optional int32 andver = 10;
  inline bool has_andver() const;
  inline void clear_andver();
  static const int kAndverFieldNumber = 10;
  inline ::google::protobuf::int32 andver() const;
  inline void set_andver(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ims.XMMsgConn)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_udid();
  inline void clear_has_udid();
  inline void set_has_sdk();
  inline void clear_has_sdk();
  inline void set_has_connpt();
  inline void clear_has_connpt();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_locale();
  inline void clear_has_locale();
  inline void set_has_psc();
  inline void clear_has_psc();
  inline void set_has_andver();
  inline void clear_has_andver();

  ::std::string* model_;
  ::std::string* os_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::int32 sdk_;
  ::std::string* udid_;
  ::std::string* connpt_;
  ::std::string* host_;
  ::std::string* locale_;
  ::protocol::PushServiceConfigMsg* psc_;
  ::google::protobuf::int32 andver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgConn* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgConnResp : public ::google::protobuf::MessageLite {
 public:
  XMMsgConnResp();
  virtual ~XMMsgConnResp();

  XMMsgConnResp(const XMMsgConnResp& from);

  inline XMMsgConnResp& operator=(const XMMsgConnResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgConnResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgConnResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgConnResp* other);

  // implements Message ----------------------------------------------

  XMMsgConnResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgConnResp& from);
  void MergeFrom(const XMMsgConnResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string challenge = 1;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 1;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const char* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  inline void set_allocated_challenge(::std::string* challenge);

  // optional string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional .protocol.PushServiceConfigMsg psc = 3;
  inline bool has_psc() const;
  inline void clear_psc();
  static const int kPscFieldNumber = 3;
  inline const ::protocol::PushServiceConfigMsg& psc() const;
  inline ::protocol::PushServiceConfigMsg* mutable_psc();
  inline ::protocol::PushServiceConfigMsg* release_psc();
  inline void set_allocated_psc(::protocol::PushServiceConfigMsg* psc);

  // @@protoc_insertion_point(class_scope:ims.XMMsgConnResp)
 private:
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_psc();
  inline void clear_has_psc();

  ::std::string* challenge_;
  ::std::string* host_;
  ::protocol::PushServiceConfigMsg* psc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgConnResp* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgBind : public ::google::protobuf::MessageLite {
 public:
  XMMsgBind();
  virtual ~XMMsgBind();

  XMMsgBind(const XMMsgBind& from);

  inline XMMsgBind& operator=(const XMMsgBind& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgBind& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgBind* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgBind* other);

  // implements Message ----------------------------------------------

  XMMsgBind* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgBind& from);
  void MergeFrom(const XMMsgBind& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string kick = 2;
  inline bool has_kick() const;
  inline void clear_kick();
  static const int kKickFieldNumber = 2;
  inline const ::std::string& kick() const;
  inline void set_kick(const ::std::string& value);
  inline void set_kick(const char* value);
  inline void set_kick(const char* value, size_t size);
  inline ::std::string* mutable_kick();
  inline ::std::string* release_kick();
  inline void set_allocated_kick(::std::string* kick);

  // optional string method = 3;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 3;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional string client_attrs = 4;
  inline bool has_client_attrs() const;
  inline void clear_client_attrs();
  static const int kClientAttrsFieldNumber = 4;
  inline const ::std::string& client_attrs() const;
  inline void set_client_attrs(const ::std::string& value);
  inline void set_client_attrs(const char* value);
  inline void set_client_attrs(const char* value, size_t size);
  inline ::std::string* mutable_client_attrs();
  inline ::std::string* release_client_attrs();
  inline void set_allocated_client_attrs(::std::string* client_attrs);

  // optional string cloud_attrs = 5;
  inline bool has_cloud_attrs() const;
  inline void clear_cloud_attrs();
  static const int kCloudAttrsFieldNumber = 5;
  inline const ::std::string& cloud_attrs() const;
  inline void set_cloud_attrs(const ::std::string& value);
  inline void set_cloud_attrs(const char* value);
  inline void set_cloud_attrs(const char* value, size_t size);
  inline ::std::string* mutable_cloud_attrs();
  inline ::std::string* release_cloud_attrs();
  inline void set_allocated_cloud_attrs(::std::string* cloud_attrs);

  // optional string sig = 6;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 6;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const char* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // @@protoc_insertion_point(class_scope:ims.XMMsgBind)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_kick();
  inline void clear_has_kick();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_client_attrs();
  inline void clear_has_client_attrs();
  inline void set_has_cloud_attrs();
  inline void clear_has_cloud_attrs();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::std::string* token_;
  ::std::string* kick_;
  ::std::string* method_;
  ::std::string* client_attrs_;
  ::std::string* cloud_attrs_;
  ::std::string* sig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgBind* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgBindResp : public ::google::protobuf::MessageLite {
 public:
  XMMsgBindResp();
  virtual ~XMMsgBindResp();

  XMMsgBindResp(const XMMsgBindResp& from);

  inline XMMsgBindResp& operator=(const XMMsgBindResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgBindResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgBindResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgBindResp* other);

  // implements Message ----------------------------------------------

  XMMsgBindResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgBindResp& from);
  void MergeFrom(const XMMsgBindResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // optional string error_type = 2;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 2;
  inline const ::std::string& error_type() const;
  inline void set_error_type(const ::std::string& value);
  inline void set_error_type(const char* value);
  inline void set_error_type(const char* value, size_t size);
  inline ::std::string* mutable_error_type();
  inline ::std::string* release_error_type();
  inline void set_allocated_error_type(::std::string* error_type);

  // optional string error_reason = 3;
  inline bool has_error_reason() const;
  inline void clear_error_reason();
  static const int kErrorReasonFieldNumber = 3;
  inline const ::std::string& error_reason() const;
  inline void set_error_reason(const ::std::string& value);
  inline void set_error_reason(const char* value);
  inline void set_error_reason(const char* value, size_t size);
  inline ::std::string* mutable_error_reason();
  inline ::std::string* release_error_reason();
  inline void set_allocated_error_reason(::std::string* error_reason);

  // optional string error_desc = 4;
  inline bool has_error_desc() const;
  inline void clear_error_desc();
  static const int kErrorDescFieldNumber = 4;
  inline const ::std::string& error_desc() const;
  inline void set_error_desc(const ::std::string& value);
  inline void set_error_desc(const char* value);
  inline void set_error_desc(const char* value, size_t size);
  inline ::std::string* mutable_error_desc();
  inline ::std::string* release_error_desc();
  inline void set_allocated_error_desc(::std::string* error_desc);

  // @@protoc_insertion_point(class_scope:ims.XMMsgBindResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_error_reason();
  inline void clear_has_error_reason();
  inline void set_has_error_desc();
  inline void clear_has_error_desc();

  ::std::string* error_type_;
  ::std::string* error_reason_;
  ::std::string* error_desc_;
  bool result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgBindResp* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgPing : public ::google::protobuf::MessageLite {
 public:
  XMMsgPing();
  virtual ~XMMsgPing();

  XMMsgPing(const XMMsgPing& from);

  inline XMMsgPing& operator=(const XMMsgPing& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgPing* other);

  // implements Message ----------------------------------------------

  XMMsgPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgPing& from);
  void MergeFrom(const XMMsgPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes stats = 1;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 1;
  inline const ::std::string& stats() const;
  inline void set_stats(const ::std::string& value);
  inline void set_stats(const char* value);
  inline void set_stats(const void* value, size_t size);
  inline ::std::string* mutable_stats();
  inline ::std::string* release_stats();
  inline void set_allocated_stats(::std::string* stats);

  // optional .protocol.PushServiceConfigMsg psc = 2;
  inline bool has_psc() const;
  inline void clear_psc();
  static const int kPscFieldNumber = 2;
  inline const ::protocol::PushServiceConfigMsg& psc() const;
  inline ::protocol::PushServiceConfigMsg* mutable_psc();
  inline ::protocol::PushServiceConfigMsg* release_psc();
  inline void set_allocated_psc(::protocol::PushServiceConfigMsg* psc);

  // @@protoc_insertion_point(class_scope:ims.XMMsgPing)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_psc();
  inline void clear_has_psc();

  ::std::string* stats_;
  ::protocol::PushServiceConfigMsg* psc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgPing* default_instance_;
};
// -------------------------------------------------------------------

class XMMsgNotify : public ::google::protobuf::MessageLite {
 public:
  XMMsgNotify();
  virtual ~XMMsgNotify();

  XMMsgNotify(const XMMsgNotify& from);

  inline XMMsgNotify& operator=(const XMMsgNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const XMMsgNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XMMsgNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XMMsgNotify* other);

  // implements Message ----------------------------------------------

  XMMsgNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XMMsgNotify& from);
  void MergeFrom(const XMMsgNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 err_code = 1;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 1;
  inline ::google::protobuf::int32 err_code() const;
  inline void set_err_code(::google::protobuf::int32 value);

  // optional string err_str = 2;
  inline bool has_err_str() const;
  inline void clear_err_str();
  static const int kErrStrFieldNumber = 2;
  inline const ::std::string& err_str() const;
  inline void set_err_str(const ::std::string& value);
  inline void set_err_str(const char* value);
  inline void set_err_str(const char* value, size_t size);
  inline ::std::string* mutable_err_str();
  inline ::std::string* release_err_str();
  inline void set_allocated_err_str(::std::string* err_str);

  // @@protoc_insertion_point(class_scope:ims.XMMsgNotify)
 private:
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_err_str();
  inline void clear_has_err_str();

  ::std::string* err_str_;
  ::google::protobuf::int32 err_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ims_5fpush_5fservice_2eproto();
  #endif
  friend void protobuf_AssignDesc_ims_5fpush_5fservice_2eproto();
  friend void protobuf_ShutdownFile_ims_5fpush_5fservice_2eproto();

  void InitAsDefaultInstance();
  static XMMsgNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientHeader

// optional int32 chid = 1;
inline bool ClientHeader::has_chid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientHeader::set_has_chid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientHeader::clear_has_chid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientHeader::clear_chid() {
  chid_ = 0;
  clear_has_chid();
}
inline ::google::protobuf::int32 ClientHeader::chid() const {
  return chid_;
}
inline void ClientHeader::set_chid(::google::protobuf::int32 value) {
  set_has_chid();
  chid_ = value;
}

// optional int64 uuid = 2;
inline bool ClientHeader::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientHeader::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientHeader::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientHeader::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 ClientHeader::uuid() const {
  return uuid_;
}
inline void ClientHeader::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string server = 3;
inline bool ClientHeader::has_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientHeader::set_has_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientHeader::clear_has_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientHeader::clear_server() {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    server_->clear();
  }
  clear_has_server();
}
inline const ::std::string& ClientHeader::server() const {
  return *server_;
}
inline void ClientHeader::set_server(const ::std::string& value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void ClientHeader::set_server(const char* value) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(value);
}
inline void ClientHeader::set_server(const char* value, size_t size) {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  server_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_server() {
  set_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    server_ = new ::std::string;
  }
  return server_;
}
inline ::std::string* ClientHeader::release_server() {
  clear_has_server();
  if (server_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_;
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_server(::std::string* server) {
  if (server_ != &::google::protobuf::internal::kEmptyString) {
    delete server_;
  }
  if (server) {
    set_has_server();
    server_ = server;
  } else {
    clear_has_server();
    server_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resource = 4;
inline bool ClientHeader::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientHeader::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientHeader::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientHeader::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& ClientHeader::resource() const {
  return *resource_;
}
inline void ClientHeader::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void ClientHeader::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void ClientHeader::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* ClientHeader::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cmd = 5;
inline bool ClientHeader::has_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientHeader::set_has_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientHeader::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientHeader::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& ClientHeader::cmd() const {
  return *cmd_;
}
inline void ClientHeader::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void ClientHeader::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void ClientHeader::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* ClientHeader::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string subcmd = 6;
inline bool ClientHeader::has_subcmd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientHeader::set_has_subcmd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientHeader::clear_has_subcmd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientHeader::clear_subcmd() {
  if (subcmd_ != &::google::protobuf::internal::kEmptyString) {
    subcmd_->clear();
  }
  clear_has_subcmd();
}
inline const ::std::string& ClientHeader::subcmd() const {
  return *subcmd_;
}
inline void ClientHeader::set_subcmd(const ::std::string& value) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(value);
}
inline void ClientHeader::set_subcmd(const char* value) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(value);
}
inline void ClientHeader::set_subcmd(const char* value, size_t size) {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  subcmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_subcmd() {
  set_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    subcmd_ = new ::std::string;
  }
  return subcmd_;
}
inline ::std::string* ClientHeader::release_subcmd() {
  clear_has_subcmd();
  if (subcmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subcmd_;
    subcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_subcmd(::std::string* subcmd) {
  if (subcmd_ != &::google::protobuf::internal::kEmptyString) {
    delete subcmd_;
  }
  if (subcmd) {
    set_has_subcmd();
    subcmd_ = subcmd;
  } else {
    clear_has_subcmd();
    subcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 7;
inline bool ClientHeader::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientHeader::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientHeader::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ClientHeader::id() const {
  return *id_;
}
inline void ClientHeader::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientHeader::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ClientHeader::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ClientHeader::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ims.ClientHeader.MSG_DIR_FLAG dir_flag = 8;
inline bool ClientHeader::has_dir_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientHeader::set_has_dir_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientHeader::clear_has_dir_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientHeader::clear_dir_flag() {
  dir_flag_ = 1;
  clear_has_dir_flag();
}
inline ::ims::ClientHeader_MSG_DIR_FLAG ClientHeader::dir_flag() const {
  return static_cast< ::ims::ClientHeader_MSG_DIR_FLAG >(dir_flag_);
}
inline void ClientHeader::set_dir_flag(::ims::ClientHeader_MSG_DIR_FLAG value) {
  assert(::ims::ClientHeader_MSG_DIR_FLAG_IsValid(value));
  set_has_dir_flag();
  dir_flag_ = value;
}

// optional int32 cipher = 9;
inline bool ClientHeader::has_cipher() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientHeader::set_has_cipher() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientHeader::clear_has_cipher() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientHeader::clear_cipher() {
  cipher_ = 0;
  clear_has_cipher();
}
inline ::google::protobuf::int32 ClientHeader::cipher() const {
  return cipher_;
}
inline void ClientHeader::set_cipher(::google::protobuf::int32 value) {
  set_has_cipher();
  cipher_ = value;
}

// optional int32 err_code = 10;
inline bool ClientHeader::has_err_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientHeader::set_has_err_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientHeader::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientHeader::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::google::protobuf::int32 ClientHeader::err_code() const {
  return err_code_;
}
inline void ClientHeader::set_err_code(::google::protobuf::int32 value) {
  set_has_err_code();
  err_code_ = value;
}

// optional string err_str = 11;
inline bool ClientHeader::has_err_str() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientHeader::set_has_err_str() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientHeader::clear_has_err_str() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientHeader::clear_err_str() {
  if (err_str_ != &::google::protobuf::internal::kEmptyString) {
    err_str_->clear();
  }
  clear_has_err_str();
}
inline const ::std::string& ClientHeader::err_str() const {
  return *err_str_;
}
inline void ClientHeader::set_err_str(const ::std::string& value) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(value);
}
inline void ClientHeader::set_err_str(const char* value) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(value);
}
inline void ClientHeader::set_err_str(const char* value, size_t size) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientHeader::mutable_err_str() {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  return err_str_;
}
inline ::std::string* ClientHeader::release_err_str() {
  clear_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_str_;
    err_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientHeader::set_allocated_err_str(::std::string* err_str) {
  if (err_str_ != &::google::protobuf::internal::kEmptyString) {
    delete err_str_;
  }
  if (err_str) {
    set_has_err_str();
    err_str_ = err_str;
  } else {
    clear_has_err_str();
    err_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// XMMsgConn

// optional uint32 version = 1;
inline bool XMMsgConn::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgConn::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgConn::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgConn::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 XMMsgConn::version() const {
  return version_;
}
inline void XMMsgConn::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional string model = 2;
inline bool XMMsgConn::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgConn::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgConn::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgConn::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& XMMsgConn::model() const {
  return *model_;
}
inline void XMMsgConn::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void XMMsgConn::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void XMMsgConn::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* XMMsgConn::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string os = 3;
inline bool XMMsgConn::has_os() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XMMsgConn::set_has_os() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XMMsgConn::clear_has_os() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XMMsgConn::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& XMMsgConn::os() const {
  return *os_;
}
inline void XMMsgConn::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void XMMsgConn::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void XMMsgConn::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* XMMsgConn::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string udid = 4;
inline bool XMMsgConn::has_udid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XMMsgConn::set_has_udid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XMMsgConn::clear_has_udid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XMMsgConn::clear_udid() {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    udid_->clear();
  }
  clear_has_udid();
}
inline const ::std::string& XMMsgConn::udid() const {
  return *udid_;
}
inline void XMMsgConn::set_udid(const ::std::string& value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void XMMsgConn::set_udid(const char* value) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(value);
}
inline void XMMsgConn::set_udid(const char* value, size_t size) {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  udid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_udid() {
  set_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    udid_ = new ::std::string;
  }
  return udid_;
}
inline ::std::string* XMMsgConn::release_udid() {
  clear_has_udid();
  if (udid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udid_;
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_udid(::std::string* udid) {
  if (udid_ != &::google::protobuf::internal::kEmptyString) {
    delete udid_;
  }
  if (udid) {
    set_has_udid();
    udid_ = udid;
  } else {
    clear_has_udid();
    udid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sdk = 5;
inline bool XMMsgConn::has_sdk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XMMsgConn::set_has_sdk() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XMMsgConn::clear_has_sdk() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XMMsgConn::clear_sdk() {
  sdk_ = 0;
  clear_has_sdk();
}
inline ::google::protobuf::int32 XMMsgConn::sdk() const {
  return sdk_;
}
inline void XMMsgConn::set_sdk(::google::protobuf::int32 value) {
  set_has_sdk();
  sdk_ = value;
}

// optional string connpt = 6;
inline bool XMMsgConn::has_connpt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XMMsgConn::set_has_connpt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XMMsgConn::clear_has_connpt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XMMsgConn::clear_connpt() {
  if (connpt_ != &::google::protobuf::internal::kEmptyString) {
    connpt_->clear();
  }
  clear_has_connpt();
}
inline const ::std::string& XMMsgConn::connpt() const {
  return *connpt_;
}
inline void XMMsgConn::set_connpt(const ::std::string& value) {
  set_has_connpt();
  if (connpt_ == &::google::protobuf::internal::kEmptyString) {
    connpt_ = new ::std::string;
  }
  connpt_->assign(value);
}
inline void XMMsgConn::set_connpt(const char* value) {
  set_has_connpt();
  if (connpt_ == &::google::protobuf::internal::kEmptyString) {
    connpt_ = new ::std::string;
  }
  connpt_->assign(value);
}
inline void XMMsgConn::set_connpt(const char* value, size_t size) {
  set_has_connpt();
  if (connpt_ == &::google::protobuf::internal::kEmptyString) {
    connpt_ = new ::std::string;
  }
  connpt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_connpt() {
  set_has_connpt();
  if (connpt_ == &::google::protobuf::internal::kEmptyString) {
    connpt_ = new ::std::string;
  }
  return connpt_;
}
inline ::std::string* XMMsgConn::release_connpt() {
  clear_has_connpt();
  if (connpt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = connpt_;
    connpt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_connpt(::std::string* connpt) {
  if (connpt_ != &::google::protobuf::internal::kEmptyString) {
    delete connpt_;
  }
  if (connpt) {
    set_has_connpt();
    connpt_ = connpt;
  } else {
    clear_has_connpt();
    connpt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 7;
inline bool XMMsgConn::has_host() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XMMsgConn::set_has_host() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XMMsgConn::clear_has_host() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XMMsgConn::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& XMMsgConn::host() const {
  return *host_;
}
inline void XMMsgConn::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void XMMsgConn::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void XMMsgConn::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* XMMsgConn::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locale = 8;
inline bool XMMsgConn::has_locale() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void XMMsgConn::set_has_locale() {
  _has_bits_[0] |= 0x00000080u;
}
inline void XMMsgConn::clear_has_locale() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void XMMsgConn::clear_locale() {
  if (locale_ != &::google::protobuf::internal::kEmptyString) {
    locale_->clear();
  }
  clear_has_locale();
}
inline const ::std::string& XMMsgConn::locale() const {
  return *locale_;
}
inline void XMMsgConn::set_locale(const ::std::string& value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void XMMsgConn::set_locale(const char* value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void XMMsgConn::set_locale(const char* value, size_t size) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConn::mutable_locale() {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  return locale_;
}
inline ::std::string* XMMsgConn::release_locale() {
  clear_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_;
    locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConn::set_allocated_locale(::std::string* locale) {
  if (locale_ != &::google::protobuf::internal::kEmptyString) {
    delete locale_;
  }
  if (locale) {
    set_has_locale();
    locale_ = locale;
  } else {
    clear_has_locale();
    locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocol.PushServiceConfigMsg psc = 9;
inline bool XMMsgConn::has_psc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void XMMsgConn::set_has_psc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void XMMsgConn::clear_has_psc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void XMMsgConn::clear_psc() {
  if (psc_ != NULL) psc_->::protocol::PushServiceConfigMsg::Clear();
  clear_has_psc();
}
inline const ::protocol::PushServiceConfigMsg& XMMsgConn::psc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return psc_ != NULL ? *psc_ : *default_instance().psc_;
#else
  return psc_ != NULL ? *psc_ : *default_instance_->psc_;
#endif
}
inline ::protocol::PushServiceConfigMsg* XMMsgConn::mutable_psc() {
  set_has_psc();
  if (psc_ == NULL) psc_ = new ::protocol::PushServiceConfigMsg;
  return psc_;
}
inline ::protocol::PushServiceConfigMsg* XMMsgConn::release_psc() {
  clear_has_psc();
  ::protocol::PushServiceConfigMsg* temp = psc_;
  psc_ = NULL;
  return temp;
}
inline void XMMsgConn::set_allocated_psc(::protocol::PushServiceConfigMsg* psc) {
  delete psc_;
  psc_ = psc;
  if (psc) {
    set_has_psc();
  } else {
    clear_has_psc();
  }
}

// optional int32 andver = 10;
inline bool XMMsgConn::has_andver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void XMMsgConn::set_has_andver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void XMMsgConn::clear_has_andver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void XMMsgConn::clear_andver() {
  andver_ = 0;
  clear_has_andver();
}
inline ::google::protobuf::int32 XMMsgConn::andver() const {
  return andver_;
}
inline void XMMsgConn::set_andver(::google::protobuf::int32 value) {
  set_has_andver();
  andver_ = value;
}

// -------------------------------------------------------------------

// XMMsgConnResp

// optional string challenge = 1;
inline bool XMMsgConnResp::has_challenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgConnResp::set_has_challenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgConnResp::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgConnResp::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& XMMsgConnResp::challenge() const {
  return *challenge_;
}
inline void XMMsgConnResp::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void XMMsgConnResp::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void XMMsgConnResp::set_challenge(const char* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConnResp::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* XMMsgConnResp::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConnResp::set_allocated_challenge(::std::string* challenge) {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (challenge) {
    set_has_challenge();
    challenge_ = challenge;
  } else {
    clear_has_challenge();
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 2;
inline bool XMMsgConnResp::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgConnResp::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgConnResp::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgConnResp::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& XMMsgConnResp::host() const {
  return *host_;
}
inline void XMMsgConnResp::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void XMMsgConnResp::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void XMMsgConnResp::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgConnResp::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* XMMsgConnResp::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgConnResp::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocol.PushServiceConfigMsg psc = 3;
inline bool XMMsgConnResp::has_psc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XMMsgConnResp::set_has_psc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XMMsgConnResp::clear_has_psc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XMMsgConnResp::clear_psc() {
  if (psc_ != NULL) psc_->::protocol::PushServiceConfigMsg::Clear();
  clear_has_psc();
}
inline const ::protocol::PushServiceConfigMsg& XMMsgConnResp::psc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return psc_ != NULL ? *psc_ : *default_instance().psc_;
#else
  return psc_ != NULL ? *psc_ : *default_instance_->psc_;
#endif
}
inline ::protocol::PushServiceConfigMsg* XMMsgConnResp::mutable_psc() {
  set_has_psc();
  if (psc_ == NULL) psc_ = new ::protocol::PushServiceConfigMsg;
  return psc_;
}
inline ::protocol::PushServiceConfigMsg* XMMsgConnResp::release_psc() {
  clear_has_psc();
  ::protocol::PushServiceConfigMsg* temp = psc_;
  psc_ = NULL;
  return temp;
}
inline void XMMsgConnResp::set_allocated_psc(::protocol::PushServiceConfigMsg* psc) {
  delete psc_;
  psc_ = psc;
  if (psc) {
    set_has_psc();
  } else {
    clear_has_psc();
  }
}

// -------------------------------------------------------------------

// XMMsgBind

// optional string token = 1;
inline bool XMMsgBind::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgBind::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgBind::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgBind::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& XMMsgBind::token() const {
  return *token_;
}
inline void XMMsgBind::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void XMMsgBind::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void XMMsgBind::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* XMMsgBind::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string kick = 2;
inline bool XMMsgBind::has_kick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgBind::set_has_kick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgBind::clear_has_kick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgBind::clear_kick() {
  if (kick_ != &::google::protobuf::internal::kEmptyString) {
    kick_->clear();
  }
  clear_has_kick();
}
inline const ::std::string& XMMsgBind::kick() const {
  return *kick_;
}
inline void XMMsgBind::set_kick(const ::std::string& value) {
  set_has_kick();
  if (kick_ == &::google::protobuf::internal::kEmptyString) {
    kick_ = new ::std::string;
  }
  kick_->assign(value);
}
inline void XMMsgBind::set_kick(const char* value) {
  set_has_kick();
  if (kick_ == &::google::protobuf::internal::kEmptyString) {
    kick_ = new ::std::string;
  }
  kick_->assign(value);
}
inline void XMMsgBind::set_kick(const char* value, size_t size) {
  set_has_kick();
  if (kick_ == &::google::protobuf::internal::kEmptyString) {
    kick_ = new ::std::string;
  }
  kick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_kick() {
  set_has_kick();
  if (kick_ == &::google::protobuf::internal::kEmptyString) {
    kick_ = new ::std::string;
  }
  return kick_;
}
inline ::std::string* XMMsgBind::release_kick() {
  clear_has_kick();
  if (kick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = kick_;
    kick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_kick(::std::string* kick) {
  if (kick_ != &::google::protobuf::internal::kEmptyString) {
    delete kick_;
  }
  if (kick) {
    set_has_kick();
    kick_ = kick;
  } else {
    clear_has_kick();
    kick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string method = 3;
inline bool XMMsgBind::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XMMsgBind::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XMMsgBind::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XMMsgBind::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& XMMsgBind::method() const {
  return *method_;
}
inline void XMMsgBind::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void XMMsgBind::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void XMMsgBind::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* XMMsgBind::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_attrs = 4;
inline bool XMMsgBind::has_client_attrs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XMMsgBind::set_has_client_attrs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XMMsgBind::clear_has_client_attrs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XMMsgBind::clear_client_attrs() {
  if (client_attrs_ != &::google::protobuf::internal::kEmptyString) {
    client_attrs_->clear();
  }
  clear_has_client_attrs();
}
inline const ::std::string& XMMsgBind::client_attrs() const {
  return *client_attrs_;
}
inline void XMMsgBind::set_client_attrs(const ::std::string& value) {
  set_has_client_attrs();
  if (client_attrs_ == &::google::protobuf::internal::kEmptyString) {
    client_attrs_ = new ::std::string;
  }
  client_attrs_->assign(value);
}
inline void XMMsgBind::set_client_attrs(const char* value) {
  set_has_client_attrs();
  if (client_attrs_ == &::google::protobuf::internal::kEmptyString) {
    client_attrs_ = new ::std::string;
  }
  client_attrs_->assign(value);
}
inline void XMMsgBind::set_client_attrs(const char* value, size_t size) {
  set_has_client_attrs();
  if (client_attrs_ == &::google::protobuf::internal::kEmptyString) {
    client_attrs_ = new ::std::string;
  }
  client_attrs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_client_attrs() {
  set_has_client_attrs();
  if (client_attrs_ == &::google::protobuf::internal::kEmptyString) {
    client_attrs_ = new ::std::string;
  }
  return client_attrs_;
}
inline ::std::string* XMMsgBind::release_client_attrs() {
  clear_has_client_attrs();
  if (client_attrs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_attrs_;
    client_attrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_client_attrs(::std::string* client_attrs) {
  if (client_attrs_ != &::google::protobuf::internal::kEmptyString) {
    delete client_attrs_;
  }
  if (client_attrs) {
    set_has_client_attrs();
    client_attrs_ = client_attrs;
  } else {
    clear_has_client_attrs();
    client_attrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cloud_attrs = 5;
inline bool XMMsgBind::has_cloud_attrs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XMMsgBind::set_has_cloud_attrs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XMMsgBind::clear_has_cloud_attrs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XMMsgBind::clear_cloud_attrs() {
  if (cloud_attrs_ != &::google::protobuf::internal::kEmptyString) {
    cloud_attrs_->clear();
  }
  clear_has_cloud_attrs();
}
inline const ::std::string& XMMsgBind::cloud_attrs() const {
  return *cloud_attrs_;
}
inline void XMMsgBind::set_cloud_attrs(const ::std::string& value) {
  set_has_cloud_attrs();
  if (cloud_attrs_ == &::google::protobuf::internal::kEmptyString) {
    cloud_attrs_ = new ::std::string;
  }
  cloud_attrs_->assign(value);
}
inline void XMMsgBind::set_cloud_attrs(const char* value) {
  set_has_cloud_attrs();
  if (cloud_attrs_ == &::google::protobuf::internal::kEmptyString) {
    cloud_attrs_ = new ::std::string;
  }
  cloud_attrs_->assign(value);
}
inline void XMMsgBind::set_cloud_attrs(const char* value, size_t size) {
  set_has_cloud_attrs();
  if (cloud_attrs_ == &::google::protobuf::internal::kEmptyString) {
    cloud_attrs_ = new ::std::string;
  }
  cloud_attrs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_cloud_attrs() {
  set_has_cloud_attrs();
  if (cloud_attrs_ == &::google::protobuf::internal::kEmptyString) {
    cloud_attrs_ = new ::std::string;
  }
  return cloud_attrs_;
}
inline ::std::string* XMMsgBind::release_cloud_attrs() {
  clear_has_cloud_attrs();
  if (cloud_attrs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cloud_attrs_;
    cloud_attrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_cloud_attrs(::std::string* cloud_attrs) {
  if (cloud_attrs_ != &::google::protobuf::internal::kEmptyString) {
    delete cloud_attrs_;
  }
  if (cloud_attrs) {
    set_has_cloud_attrs();
    cloud_attrs_ = cloud_attrs;
  } else {
    clear_has_cloud_attrs();
    cloud_attrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sig = 6;
inline bool XMMsgBind::has_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XMMsgBind::set_has_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XMMsgBind::clear_has_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XMMsgBind::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& XMMsgBind::sig() const {
  return *sig_;
}
inline void XMMsgBind::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void XMMsgBind::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void XMMsgBind::set_sig(const char* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBind::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* XMMsgBind::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBind::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// XMMsgBindResp

// optional bool result = 1;
inline bool XMMsgBindResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgBindResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgBindResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgBindResp::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool XMMsgBindResp::result() const {
  return result_;
}
inline void XMMsgBindResp::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// optional string error_type = 2;
inline bool XMMsgBindResp::has_error_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgBindResp::set_has_error_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgBindResp::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgBindResp::clear_error_type() {
  if (error_type_ != &::google::protobuf::internal::kEmptyString) {
    error_type_->clear();
  }
  clear_has_error_type();
}
inline const ::std::string& XMMsgBindResp::error_type() const {
  return *error_type_;
}
inline void XMMsgBindResp::set_error_type(const ::std::string& value) {
  set_has_error_type();
  if (error_type_ == &::google::protobuf::internal::kEmptyString) {
    error_type_ = new ::std::string;
  }
  error_type_->assign(value);
}
inline void XMMsgBindResp::set_error_type(const char* value) {
  set_has_error_type();
  if (error_type_ == &::google::protobuf::internal::kEmptyString) {
    error_type_ = new ::std::string;
  }
  error_type_->assign(value);
}
inline void XMMsgBindResp::set_error_type(const char* value, size_t size) {
  set_has_error_type();
  if (error_type_ == &::google::protobuf::internal::kEmptyString) {
    error_type_ = new ::std::string;
  }
  error_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBindResp::mutable_error_type() {
  set_has_error_type();
  if (error_type_ == &::google::protobuf::internal::kEmptyString) {
    error_type_ = new ::std::string;
  }
  return error_type_;
}
inline ::std::string* XMMsgBindResp::release_error_type() {
  clear_has_error_type();
  if (error_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_type_;
    error_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBindResp::set_allocated_error_type(::std::string* error_type) {
  if (error_type_ != &::google::protobuf::internal::kEmptyString) {
    delete error_type_;
  }
  if (error_type) {
    set_has_error_type();
    error_type_ = error_type;
  } else {
    clear_has_error_type();
    error_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_reason = 3;
inline bool XMMsgBindResp::has_error_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XMMsgBindResp::set_has_error_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XMMsgBindResp::clear_has_error_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XMMsgBindResp::clear_error_reason() {
  if (error_reason_ != &::google::protobuf::internal::kEmptyString) {
    error_reason_->clear();
  }
  clear_has_error_reason();
}
inline const ::std::string& XMMsgBindResp::error_reason() const {
  return *error_reason_;
}
inline void XMMsgBindResp::set_error_reason(const ::std::string& value) {
  set_has_error_reason();
  if (error_reason_ == &::google::protobuf::internal::kEmptyString) {
    error_reason_ = new ::std::string;
  }
  error_reason_->assign(value);
}
inline void XMMsgBindResp::set_error_reason(const char* value) {
  set_has_error_reason();
  if (error_reason_ == &::google::protobuf::internal::kEmptyString) {
    error_reason_ = new ::std::string;
  }
  error_reason_->assign(value);
}
inline void XMMsgBindResp::set_error_reason(const char* value, size_t size) {
  set_has_error_reason();
  if (error_reason_ == &::google::protobuf::internal::kEmptyString) {
    error_reason_ = new ::std::string;
  }
  error_reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBindResp::mutable_error_reason() {
  set_has_error_reason();
  if (error_reason_ == &::google::protobuf::internal::kEmptyString) {
    error_reason_ = new ::std::string;
  }
  return error_reason_;
}
inline ::std::string* XMMsgBindResp::release_error_reason() {
  clear_has_error_reason();
  if (error_reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_reason_;
    error_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBindResp::set_allocated_error_reason(::std::string* error_reason) {
  if (error_reason_ != &::google::protobuf::internal::kEmptyString) {
    delete error_reason_;
  }
  if (error_reason) {
    set_has_error_reason();
    error_reason_ = error_reason;
  } else {
    clear_has_error_reason();
    error_reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_desc = 4;
inline bool XMMsgBindResp::has_error_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XMMsgBindResp::set_has_error_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XMMsgBindResp::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XMMsgBindResp::clear_error_desc() {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    error_desc_->clear();
  }
  clear_has_error_desc();
}
inline const ::std::string& XMMsgBindResp::error_desc() const {
  return *error_desc_;
}
inline void XMMsgBindResp::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void XMMsgBindResp::set_error_desc(const char* value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void XMMsgBindResp::set_error_desc(const char* value, size_t size) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgBindResp::mutable_error_desc() {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  return error_desc_;
}
inline ::std::string* XMMsgBindResp::release_error_desc() {
  clear_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_desc_;
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgBindResp::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete error_desc_;
  }
  if (error_desc) {
    set_has_error_desc();
    error_desc_ = error_desc;
  } else {
    clear_has_error_desc();
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// XMMsgPing

// optional bytes stats = 1;
inline bool XMMsgPing::has_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgPing::set_has_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgPing::clear_has_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgPing::clear_stats() {
  if (stats_ != &::google::protobuf::internal::kEmptyString) {
    stats_->clear();
  }
  clear_has_stats();
}
inline const ::std::string& XMMsgPing::stats() const {
  return *stats_;
}
inline void XMMsgPing::set_stats(const ::std::string& value) {
  set_has_stats();
  if (stats_ == &::google::protobuf::internal::kEmptyString) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void XMMsgPing::set_stats(const char* value) {
  set_has_stats();
  if (stats_ == &::google::protobuf::internal::kEmptyString) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void XMMsgPing::set_stats(const void* value, size_t size) {
  set_has_stats();
  if (stats_ == &::google::protobuf::internal::kEmptyString) {
    stats_ = new ::std::string;
  }
  stats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgPing::mutable_stats() {
  set_has_stats();
  if (stats_ == &::google::protobuf::internal::kEmptyString) {
    stats_ = new ::std::string;
  }
  return stats_;
}
inline ::std::string* XMMsgPing::release_stats() {
  clear_has_stats();
  if (stats_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stats_;
    stats_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgPing::set_allocated_stats(::std::string* stats) {
  if (stats_ != &::google::protobuf::internal::kEmptyString) {
    delete stats_;
  }
  if (stats) {
    set_has_stats();
    stats_ = stats;
  } else {
    clear_has_stats();
    stats_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocol.PushServiceConfigMsg psc = 2;
inline bool XMMsgPing::has_psc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgPing::set_has_psc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgPing::clear_has_psc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgPing::clear_psc() {
  if (psc_ != NULL) psc_->::protocol::PushServiceConfigMsg::Clear();
  clear_has_psc();
}
inline const ::protocol::PushServiceConfigMsg& XMMsgPing::psc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return psc_ != NULL ? *psc_ : *default_instance().psc_;
#else
  return psc_ != NULL ? *psc_ : *default_instance_->psc_;
#endif
}
inline ::protocol::PushServiceConfigMsg* XMMsgPing::mutable_psc() {
  set_has_psc();
  if (psc_ == NULL) psc_ = new ::protocol::PushServiceConfigMsg;
  return psc_;
}
inline ::protocol::PushServiceConfigMsg* XMMsgPing::release_psc() {
  clear_has_psc();
  ::protocol::PushServiceConfigMsg* temp = psc_;
  psc_ = NULL;
  return temp;
}
inline void XMMsgPing::set_allocated_psc(::protocol::PushServiceConfigMsg* psc) {
  delete psc_;
  psc_ = psc;
  if (psc) {
    set_has_psc();
  } else {
    clear_has_psc();
  }
}

// -------------------------------------------------------------------

// XMMsgNotify

// optional int32 err_code = 1;
inline bool XMMsgNotify::has_err_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XMMsgNotify::set_has_err_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XMMsgNotify::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XMMsgNotify::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::google::protobuf::int32 XMMsgNotify::err_code() const {
  return err_code_;
}
inline void XMMsgNotify::set_err_code(::google::protobuf::int32 value) {
  set_has_err_code();
  err_code_ = value;
}

// optional string err_str = 2;
inline bool XMMsgNotify::has_err_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XMMsgNotify::set_has_err_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XMMsgNotify::clear_has_err_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XMMsgNotify::clear_err_str() {
  if (err_str_ != &::google::protobuf::internal::kEmptyString) {
    err_str_->clear();
  }
  clear_has_err_str();
}
inline const ::std::string& XMMsgNotify::err_str() const {
  return *err_str_;
}
inline void XMMsgNotify::set_err_str(const ::std::string& value) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(value);
}
inline void XMMsgNotify::set_err_str(const char* value) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(value);
}
inline void XMMsgNotify::set_err_str(const char* value, size_t size) {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  err_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XMMsgNotify::mutable_err_str() {
  set_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    err_str_ = new ::std::string;
  }
  return err_str_;
}
inline ::std::string* XMMsgNotify::release_err_str() {
  clear_has_err_str();
  if (err_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_str_;
    err_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XMMsgNotify::set_allocated_err_str(::std::string* err_str) {
  if (err_str_ != &::google::protobuf::internal::kEmptyString) {
    delete err_str_;
  }
  if (err_str) {
    set_has_err_str();
    err_str_ = err_str;
  } else {
    clear_has_err_str();
    err_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ims

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ims_5fpush_5fservice_2eproto__INCLUDED
