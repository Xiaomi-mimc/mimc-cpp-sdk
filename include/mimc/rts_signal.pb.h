// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rts_signal.proto

#ifndef PROTOBUF_rts_5fsignal_2eproto__INCLUDED
#define PROTOBUF_rts_5fsignal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mimc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rts_5fsignal_2eproto();
void protobuf_AssignDesc_rts_5fsignal_2eproto();
void protobuf_ShutdownFile_rts_5fsignal_2eproto();

class UserInfo;
class ChatInfo;
class XmqRTSExchange;
class RTSMessage;
class CreateRequest;
class InviteRequest;
class InviteResponse;
class CreateResponse;
class UpdateRequest;
class UpdateResponse;
class PingRequest;
class PingResponse;
class ByeRequest;
class ByeResponse;
class UpdateChatInfo;

enum RTSMessageType {
  CREATE_REQUEST = 1,
  CREATE_RESPONSE = 2,
  INVITE_REQUEST = 3,
  INVITE_RESPONSE = 4,
  UPDATE_REQUEST = 5,
  UPDATE_RESPONSE = 6,
  PING_REQUEST = 7,
  PING_RESPONSE = 8,
  BYE_REQUEST = 9,
  BYE_RESPONSE = 10,
  APP_USER_MESSAGE = 99
};
bool RTSMessageType_IsValid(int value);
const RTSMessageType RTSMessageType_MIN = CREATE_REQUEST;
const RTSMessageType RTSMessageType_MAX = APP_USER_MESSAGE;
const int RTSMessageType_ARRAYSIZE = RTSMessageType_MAX + 1;

enum ChatType {
  SINGLE_CHAT = 1,
  GROUP_CHAT = 2
};
bool ChatType_IsValid(int value);
const ChatType ChatType_MIN = SINGLE_CHAT;
const ChatType ChatType_MAX = GROUP_CHAT;
const int ChatType_ARRAYSIZE = ChatType_MAX + 1;

enum StreamDataType {
  A_STREAM = 1,
  V_STREAM = 2,
  AV_STREAM = 3
};
bool StreamDataType_IsValid(int value);
const StreamDataType StreamDataType_MIN = A_STREAM;
const StreamDataType StreamDataType_MAX = AV_STREAM;
const int StreamDataType_ARRAYSIZE = StreamDataType_MAX + 1;

enum RTSResult {
  SUCC = 0,
  PEER_REFUSE = 1,
  PEER_OFFLINE = 2,
  CHATID_EXIST = 3,
  CHATID_NOT_EXIST = 4,
  SDP_FAIL = 5,
  INTERNAL_ERROR1 = 6,
  PARAMETER_ERROR = 7,
  INVALID_OPERATION = 8,
  ERROR_USER_DEFINED = 99
};
bool RTSResult_IsValid(int value);
const RTSResult RTSResult_MIN = SUCC;
const RTSResult RTSResult_MAX = ERROR_USER_DEFINED;
const int RTSResult_ARRAYSIZE = RTSResult_MAX + 1;

enum ChatStatus {
  CREATING = 1,
  IN_PROCESS = 2,
  FINISH = 3
};
bool ChatStatus_IsValid(int value);
const ChatStatus ChatStatus_MIN = CREATING;
const ChatStatus ChatStatus_MAX = FINISH;
const int ChatStatus_ARRAYSIZE = ChatStatus_MAX + 1;

enum UpdateType {
  UPDATE = 1,
  DELETE = 2
};
bool UpdateType_IsValid(int value);
const UpdateType UpdateType_MIN = UPDATE;
const UpdateType UpdateType_MAX = DELETE;
const int UpdateType_ARRAYSIZE = UpdateType_MAX + 1;

// ===================================================================

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 appId = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 3;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional string appAccount = 4;
  inline bool has_appaccount() const;
  inline void clear_appaccount();
  static const int kAppAccountFieldNumber = 4;
  inline const ::std::string& appaccount() const;
  inline void set_appaccount(const ::std::string& value);
  inline void set_appaccount(const char* value);
  inline void set_appaccount(const char* value, size_t size);
  inline ::std::string* mutable_appaccount();
  inline ::std::string* release_appaccount();
  inline void set_allocated_appaccount(::std::string* appaccount);

  // optional string intranetIp = 5;
  inline bool has_intranetip() const;
  inline void clear_intranetip();
  static const int kIntranetIpFieldNumber = 5;
  inline const ::std::string& intranetip() const;
  inline void set_intranetip(const ::std::string& value);
  inline void set_intranetip(const char* value);
  inline void set_intranetip(const char* value, size_t size);
  inline ::std::string* mutable_intranetip();
  inline ::std::string* release_intranetip();
  inline void set_allocated_intranetip(::std::string* intranetip);

  // optional uint32 intranetPort = 6;
  inline bool has_intranetport() const;
  inline void clear_intranetport();
  static const int kIntranetPortFieldNumber = 6;
  inline ::google::protobuf::uint32 intranetport() const;
  inline void set_intranetport(::google::protobuf::uint32 value);

  // optional string internetIp = 7;
  inline bool has_internetip() const;
  inline void clear_internetip();
  static const int kInternetIpFieldNumber = 7;
  inline const ::std::string& internetip() const;
  inline void set_internetip(const ::std::string& value);
  inline void set_internetip(const char* value);
  inline void set_internetip(const char* value, size_t size);
  inline ::std::string* mutable_internetip();
  inline ::std::string* release_internetip();
  inline void set_allocated_internetip(::std::string* internetip);

  // optional uint32 internetPort = 8;
  inline bool has_internetport() const;
  inline void clear_internetport();
  static const int kInternetPortFieldNumber = 8;
  inline ::google::protobuf::uint32 internetport() const;
  inline void set_internetport(::google::protobuf::uint32 value);

  // optional string relayIp = 9;
  inline bool has_relayip() const;
  inline void clear_relayip();
  static const int kRelayIpFieldNumber = 9;
  inline const ::std::string& relayip() const;
  inline void set_relayip(const ::std::string& value);
  inline void set_relayip(const char* value);
  inline void set_relayip(const char* value, size_t size);
  inline ::std::string* mutable_relayip();
  inline ::std::string* release_relayip();
  inline void set_allocated_relayip(::std::string* relayip);

  // optional uint32 relayPort = 10;
  inline bool has_relayport() const;
  inline void clear_relayport();
  static const int kRelayPortFieldNumber = 10;
  inline ::google::protobuf::uint32 relayport() const;
  inline void set_relayport(::google::protobuf::uint32 value);

  // optional uint64 connId = 11;
  inline bool has_connid() const;
  inline void clear_connid();
  static const int kConnIdFieldNumber = 11;
  inline ::google::protobuf::uint64 connid() const;
  inline void set_connid(::google::protobuf::uint64 value);

  // optional bool is_tcp = 12;
  inline bool has_is_tcp() const;
  inline void clear_is_tcp();
  static const int kIsTcpFieldNumber = 12;
  inline bool is_tcp() const;
  inline void set_is_tcp(bool value);

  // @@protoc_insertion_point(class_scope:mimc.UserInfo)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_appaccount();
  inline void clear_has_appaccount();
  inline void set_has_intranetip();
  inline void clear_has_intranetip();
  inline void set_has_intranetport();
  inline void clear_has_intranetport();
  inline void set_has_internetip();
  inline void clear_has_internetip();
  inline void set_has_internetport();
  inline void clear_has_internetport();
  inline void set_has_relayip();
  inline void clear_has_relayip();
  inline void set_has_relayport();
  inline void clear_has_relayport();
  inline void set_has_connid();
  inline void clear_has_connid();
  inline void set_has_is_tcp();
  inline void clear_has_is_tcp();

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 appid_;
  ::std::string* appaccount_;
  ::std::string* intranetip_;
  ::std::string* internetip_;
  ::google::protobuf::uint32 intranetport_;
  ::google::protobuf::uint32 internetport_;
  ::std::string* relayip_;
  ::google::protobuf::uint64 connid_;
  ::google::protobuf::uint32 relayport_;
  bool is_tcp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChatInfo : public ::google::protobuf::MessageLite {
 public:
  ChatInfo();
  virtual ~ChatInfo();

  ChatInfo(const ChatInfo& from);

  inline ChatInfo& operator=(const ChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatInfo* other);

  // implements Message ----------------------------------------------

  ChatInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatInfo& from);
  void MergeFrom(const ChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 chatId = 1;
  inline bool has_chatid() const;
  inline void clear_chatid();
  static const int kChatIdFieldNumber = 1;
  inline ::google::protobuf::uint64 chatid() const;
  inline void set_chatid(::google::protobuf::uint64 value);

  // optional .mimc.ChatType chatType = 2;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChatTypeFieldNumber = 2;
  inline ::mimc::ChatType chattype() const;
  inline void set_chattype(::mimc::ChatType value);

  // optional .mimc.ChatStatus chatStatus = 3;
  inline bool has_chatstatus() const;
  inline void clear_chatstatus();
  static const int kChatStatusFieldNumber = 3;
  inline ::mimc::ChatStatus chatstatus() const;
  inline void set_chatstatus(::mimc::ChatStatus value);

  // optional int64 creatorId = 4;
  inline bool has_creatorid() const;
  inline void clear_creatorid();
  static const int kCreatorIdFieldNumber = 4;
  inline ::google::protobuf::int64 creatorid() const;
  inline void set_creatorid(::google::protobuf::int64 value);

  // optional string creatorResource = 5;
  inline bool has_creatorresource() const;
  inline void clear_creatorresource();
  static const int kCreatorResourceFieldNumber = 5;
  inline const ::std::string& creatorresource() const;
  inline void set_creatorresource(const ::std::string& value);
  inline void set_creatorresource(const char* value);
  inline void set_creatorresource(const char* value, size_t size);
  inline ::std::string* mutable_creatorresource();
  inline ::std::string* release_creatorresource();
  inline void set_allocated_creatorresource(::std::string* creatorresource);

  // repeated .mimc.UserInfo members = 6;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 6;
  inline const ::mimc::UserInfo& members(int index) const;
  inline ::mimc::UserInfo* mutable_members(int index);
  inline ::mimc::UserInfo* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:mimc.ChatInfo)
 private:
  inline void set_has_chatid();
  inline void clear_has_chatid();
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_chatstatus();
  inline void clear_has_chatstatus();
  inline void set_has_creatorid();
  inline void clear_has_creatorid();
  inline void set_has_creatorresource();
  inline void clear_has_creatorresource();

  ::google::protobuf::uint64 chatid_;
  int chattype_;
  int chatstatus_;
  ::google::protobuf::int64 creatorid_;
  ::std::string* creatorresource_;
  ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static ChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class XmqRTSExchange : public ::google::protobuf::MessageLite {
 public:
  XmqRTSExchange();
  virtual ~XmqRTSExchange();

  XmqRTSExchange(const XmqRTSExchange& from);

  inline XmqRTSExchange& operator=(const XmqRTSExchange& from) {
    CopyFrom(from);
    return *this;
  }

  static const XmqRTSExchange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const XmqRTSExchange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(XmqRTSExchange* other);

  // implements Message ----------------------------------------------

  XmqRTSExchange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const XmqRTSExchange& from);
  void MergeFrom(const XmqRTSExchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string packetId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional int64 toUuid = 3;
  inline bool has_touuid() const;
  inline void clear_touuid();
  static const int kToUuidFieldNumber = 3;
  inline ::google::protobuf::int64 touuid() const;
  inline void set_touuid(::google::protobuf::int64 value);

  // optional string toResource = 4;
  inline bool has_toresource() const;
  inline void clear_toresource();
  static const int kToResourceFieldNumber = 4;
  inline const ::std::string& toresource() const;
  inline void set_toresource(const ::std::string& value);
  inline void set_toresource(const char* value);
  inline void set_toresource(const char* value, size_t size);
  inline ::std::string* mutable_toresource();
  inline ::std::string* release_toresource();
  inline void set_allocated_toresource(::std::string* toresource);

  // optional .mimc.RTSMessage message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::mimc::RTSMessage& message() const;
  inline ::mimc::RTSMessage* mutable_message();
  inline ::mimc::RTSMessage* release_message();
  inline void set_allocated_message(::mimc::RTSMessage* message);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.XmqRTSExchange)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_touuid();
  inline void clear_has_touuid();
  inline void set_has_toresource();
  inline void clear_has_toresource();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::std::string* packetid_;
  ::std::string* package_;
  ::google::protobuf::int64 touuid_;
  ::std::string* toresource_;
  ::mimc::RTSMessage* message_;
  ::google::protobuf::int64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static XmqRTSExchange* default_instance_;
};
// -------------------------------------------------------------------

class RTSMessage : public ::google::protobuf::MessageLite {
 public:
  RTSMessage();
  virtual ~RTSMessage();

  RTSMessage(const RTSMessage& from);

  inline RTSMessage& operator=(const RTSMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const RTSMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RTSMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RTSMessage* other);

  // implements Message ----------------------------------------------

  RTSMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RTSMessage& from);
  void MergeFrom(const RTSMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.RTSMessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mimc::RTSMessageType type() const;
  inline void set_type(::mimc::RTSMessageType value);

  // optional uint64 chatId = 2;
  inline bool has_chatid() const;
  inline void clear_chatid();
  static const int kChatIdFieldNumber = 2;
  inline ::google::protobuf::uint64 chatid() const;
  inline void set_chatid(::google::protobuf::uint64 value);

  // optional .mimc.ChatType chatType = 3;
  inline bool has_chattype() const;
  inline void clear_chattype();
  static const int kChatTypeFieldNumber = 3;
  inline ::mimc::ChatType chattype() const;
  inline void set_chattype(::mimc::ChatType value);

  // optional int64 uuid = 4;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 4;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 5;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 5;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional bytes payload = 6;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 6;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 region_bucket = 7;
  inline bool has_region_bucket() const;
  inline void clear_region_bucket();
  static const int kRegionBucketFieldNumber = 7;
  inline ::google::protobuf::int64 region_bucket() const;
  inline void set_region_bucket(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.RTSMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_chatid();
  inline void clear_has_chatid();
  inline void set_has_chattype();
  inline void clear_has_chattype();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_region_bucket();
  inline void clear_has_region_bucket();

  ::google::protobuf::uint64 chatid_;
  int type_;
  int chattype_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::std::string* payload_;
  ::google::protobuf::int64 region_bucket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static RTSMessage* default_instance_;
};
// -------------------------------------------------------------------

class CreateRequest : public ::google::protobuf::MessageLite {
 public:
  CreateRequest();
  virtual ~CreateRequest();

  CreateRequest(const CreateRequest& from);

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRequest* other);

  // implements Message ----------------------------------------------

  CreateRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRequest& from);
  void MergeFrom(const CreateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.StreamDataType streamType = 1;
  inline bool has_streamtype() const;
  inline void clear_streamtype();
  static const int kStreamTypeFieldNumber = 1;
  inline ::mimc::StreamDataType streamtype() const;
  inline void set_streamtype(::mimc::StreamDataType value);

  // repeated .mimc.UserInfo members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::mimc::UserInfo& members(int index) const;
  inline ::mimc::UserInfo* mutable_members(int index);
  inline ::mimc::UserInfo* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
      mutable_members();

  // optional string sdp = 3;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 3;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // optional bytes appContent = 4;
  inline bool has_appcontent() const;
  inline void clear_appcontent();
  static const int kAppContentFieldNumber = 4;
  inline const ::std::string& appcontent() const;
  inline void set_appcontent(const ::std::string& value);
  inline void set_appcontent(const char* value);
  inline void set_appcontent(const void* value, size_t size);
  inline ::std::string* mutable_appcontent();
  inline ::std::string* release_appcontent();
  inline void set_allocated_appcontent(::std::string* appcontent);

  // @@protoc_insertion_point(class_scope:mimc.CreateRequest)
 private:
  inline void set_has_streamtype();
  inline void clear_has_streamtype();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_appcontent();
  inline void clear_has_appcontent();

  ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo > members_;
  ::std::string* sdp_;
  ::std::string* appcontent_;
  int streamtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static CreateRequest* default_instance_;
};
// -------------------------------------------------------------------

class InviteRequest : public ::google::protobuf::MessageLite {
 public:
  InviteRequest();
  virtual ~InviteRequest();

  InviteRequest(const InviteRequest& from);

  inline InviteRequest& operator=(const InviteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const InviteRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteRequest* other);

  // implements Message ----------------------------------------------

  InviteRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteRequest& from);
  void MergeFrom(const InviteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.StreamDataType streamType = 1;
  inline bool has_streamtype() const;
  inline void clear_streamtype();
  static const int kStreamTypeFieldNumber = 1;
  inline ::mimc::StreamDataType streamtype() const;
  inline void set_streamtype(::mimc::StreamDataType value);

  // repeated .mimc.UserInfo members = 2;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 2;
  inline const ::mimc::UserInfo& members(int index) const;
  inline ::mimc::UserInfo* mutable_members(int index);
  inline ::mimc::UserInfo* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
      mutable_members();

  // optional string sdp = 3;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 3;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // optional bytes appContent = 4;
  inline bool has_appcontent() const;
  inline void clear_appcontent();
  static const int kAppContentFieldNumber = 4;
  inline const ::std::string& appcontent() const;
  inline void set_appcontent(const ::std::string& value);
  inline void set_appcontent(const char* value);
  inline void set_appcontent(const void* value, size_t size);
  inline ::std::string* mutable_appcontent();
  inline ::std::string* release_appcontent();
  inline void set_allocated_appcontent(::std::string* appcontent);

  // @@protoc_insertion_point(class_scope:mimc.InviteRequest)
 private:
  inline void set_has_streamtype();
  inline void clear_has_streamtype();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_appcontent();
  inline void clear_has_appcontent();

  ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo > members_;
  ::std::string* sdp_;
  ::std::string* appcontent_;
  int streamtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static InviteRequest* default_instance_;
};
// -------------------------------------------------------------------

class InviteResponse : public ::google::protobuf::MessageLite {
 public:
  InviteResponse();
  virtual ~InviteResponse();

  InviteResponse(const InviteResponse& from);

  inline InviteResponse& operator=(const InviteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const InviteResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InviteResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InviteResponse* other);

  // implements Message ----------------------------------------------

  InviteResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InviteResponse& from);
  void MergeFrom(const InviteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.RTSResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::mimc::RTSResult result() const;
  inline void set_result(::mimc::RTSResult value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string sdp = 3;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 3;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // optional .mimc.UserInfo user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::mimc::UserInfo& user() const;
  inline ::mimc::UserInfo* mutable_user();
  inline ::mimc::UserInfo* release_user();
  inline void set_allocated_user(::mimc::UserInfo* user);

  // @@protoc_insertion_point(class_scope:mimc.InviteResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_user();
  inline void clear_has_user();

  ::std::string* errmsg_;
  ::std::string* sdp_;
  ::mimc::UserInfo* user_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static InviteResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateResponse : public ::google::protobuf::MessageLite {
 public:
  CreateResponse();
  virtual ~CreateResponse();

  CreateResponse(const CreateResponse& from);

  inline CreateResponse& operator=(const CreateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateResponse* other);

  // implements Message ----------------------------------------------

  CreateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateResponse& from);
  void MergeFrom(const CreateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.RTSResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::mimc::RTSResult result() const;
  inline void set_result(::mimc::RTSResult value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string sdp = 3;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 3;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // repeated .mimc.UserInfo members = 4;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 4;
  inline const ::mimc::UserInfo& members(int index) const;
  inline ::mimc::UserInfo* mutable_members(int index);
  inline ::mimc::UserInfo* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:mimc.CreateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_sdp();
  inline void clear_has_sdp();

  ::std::string* errmsg_;
  ::std::string* sdp_;
  ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo > members_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static CreateResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();

  UpdateRequest(const UpdateRequest& from);

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateRequest* other);

  // implements Message ----------------------------------------------

  UpdateRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::mimc::UserInfo& user() const;
  inline ::mimc::UserInfo* mutable_user();
  inline ::mimc::UserInfo* release_user();
  inline void set_allocated_user(::mimc::UserInfo* user);

  // @@protoc_insertion_point(class_scope:mimc.UpdateRequest)
 private:
  inline void set_has_user();
  inline void clear_has_user();

  ::mimc::UserInfo* user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static UpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();

  UpdateResponse(const UpdateResponse& from);

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateResponse* other);

  // implements Message ----------------------------------------------

  UpdateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateResponse& from);
  void MergeFrom(const UpdateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.RTSResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::mimc::RTSResult result() const;
  inline void set_result(::mimc::RTSResult value);

  // @@protoc_insertion_point(class_scope:mimc.UpdateResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static UpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class PingRequest : public ::google::protobuf::MessageLite {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingRequest* other);

  // implements Message ----------------------------------------------

  PingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mimc.PingRequest)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static PingRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingResponse : public ::google::protobuf::MessageLite {
 public:
  PingResponse();
  virtual ~PingResponse();

  PingResponse(const PingResponse& from);

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingResponse* other);

  // implements Message ----------------------------------------------

  PingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingResponse& from);
  void MergeFrom(const PingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mimc.PingResponse)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static PingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ByeRequest : public ::google::protobuf::MessageLite {
 public:
  ByeRequest();
  virtual ~ByeRequest();

  ByeRequest(const ByeRequest& from);

  inline ByeRequest& operator=(const ByeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ByeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ByeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ByeRequest* other);

  // implements Message ----------------------------------------------

  ByeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ByeRequest& from);
  void MergeFrom(const ByeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:mimc.ByeRequest)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::std::string* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static ByeRequest* default_instance_;
};
// -------------------------------------------------------------------

class ByeResponse : public ::google::protobuf::MessageLite {
 public:
  ByeResponse();
  virtual ~ByeResponse();

  ByeResponse(const ByeResponse& from);

  inline ByeResponse& operator=(const ByeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ByeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ByeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ByeResponse* other);

  // implements Message ----------------------------------------------

  ByeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ByeResponse& from);
  void MergeFrom(const ByeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.RTSResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::mimc::RTSResult result() const;
  inline void set_result(::mimc::RTSResult value);

  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:mimc.ByeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::std::string* reason_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static ByeResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateChatInfo : public ::google::protobuf::MessageLite {
 public:
  UpdateChatInfo();
  virtual ~UpdateChatInfo();

  UpdateChatInfo(const UpdateChatInfo& from);

  inline UpdateChatInfo& operator=(const UpdateChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateChatInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateChatInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateChatInfo* other);

  // implements Message ----------------------------------------------

  UpdateChatInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateChatInfo& from);
  void MergeFrom(const UpdateChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 chatId = 1;
  inline bool has_chatid() const;
  inline void clear_chatid();
  static const int kChatIdFieldNumber = 1;
  inline ::google::protobuf::uint64 chatid() const;
  inline void set_chatid(::google::protobuf::uint64 value);

  // optional .mimc.UpdateType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mimc::UpdateType type() const;
  inline void set_type(::mimc::UpdateType value);

  // @@protoc_insertion_point(class_scope:mimc.UpdateChatInfo)
 private:
  inline void set_has_chatid();
  inline void clear_has_chatid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint64 chatid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fsignal_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fsignal_2eproto();
  friend void protobuf_ShutdownFile_rts_5fsignal_2eproto();

  void InitAsDefaultInstance();
  static UpdateChatInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// UserInfo

// optional int64 uuid = 1;
inline bool UserInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 UserInfo::uuid() const {
  return uuid_;
}
inline void UserInfo::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool UserInfo::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& UserInfo::resource() const {
  return *resource_;
}
inline void UserInfo::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UserInfo::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UserInfo::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* UserInfo::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 appId = 3;
inline bool UserInfo::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 UserInfo::appid() const {
  return appid_;
}
inline void UserInfo::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string appAccount = 4;
inline bool UserInfo::has_appaccount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_appaccount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_appaccount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_appaccount() {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    appaccount_->clear();
  }
  clear_has_appaccount();
}
inline const ::std::string& UserInfo::appaccount() const {
  return *appaccount_;
}
inline void UserInfo::set_appaccount(const ::std::string& value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void UserInfo::set_appaccount(const char* value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void UserInfo::set_appaccount(const char* value, size_t size) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_appaccount() {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  return appaccount_;
}
inline ::std::string* UserInfo::release_appaccount() {
  clear_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appaccount_;
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_appaccount(::std::string* appaccount) {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete appaccount_;
  }
  if (appaccount) {
    set_has_appaccount();
    appaccount_ = appaccount;
  } else {
    clear_has_appaccount();
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intranetIp = 5;
inline bool UserInfo::has_intranetip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_intranetip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_intranetip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_intranetip() {
  if (intranetip_ != &::google::protobuf::internal::kEmptyString) {
    intranetip_->clear();
  }
  clear_has_intranetip();
}
inline const ::std::string& UserInfo::intranetip() const {
  return *intranetip_;
}
inline void UserInfo::set_intranetip(const ::std::string& value) {
  set_has_intranetip();
  if (intranetip_ == &::google::protobuf::internal::kEmptyString) {
    intranetip_ = new ::std::string;
  }
  intranetip_->assign(value);
}
inline void UserInfo::set_intranetip(const char* value) {
  set_has_intranetip();
  if (intranetip_ == &::google::protobuf::internal::kEmptyString) {
    intranetip_ = new ::std::string;
  }
  intranetip_->assign(value);
}
inline void UserInfo::set_intranetip(const char* value, size_t size) {
  set_has_intranetip();
  if (intranetip_ == &::google::protobuf::internal::kEmptyString) {
    intranetip_ = new ::std::string;
  }
  intranetip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_intranetip() {
  set_has_intranetip();
  if (intranetip_ == &::google::protobuf::internal::kEmptyString) {
    intranetip_ = new ::std::string;
  }
  return intranetip_;
}
inline ::std::string* UserInfo::release_intranetip() {
  clear_has_intranetip();
  if (intranetip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intranetip_;
    intranetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_intranetip(::std::string* intranetip) {
  if (intranetip_ != &::google::protobuf::internal::kEmptyString) {
    delete intranetip_;
  }
  if (intranetip) {
    set_has_intranetip();
    intranetip_ = intranetip;
  } else {
    clear_has_intranetip();
    intranetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 intranetPort = 6;
inline bool UserInfo::has_intranetport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_intranetport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_intranetport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_intranetport() {
  intranetport_ = 0u;
  clear_has_intranetport();
}
inline ::google::protobuf::uint32 UserInfo::intranetport() const {
  return intranetport_;
}
inline void UserInfo::set_intranetport(::google::protobuf::uint32 value) {
  set_has_intranetport();
  intranetport_ = value;
}

// optional string internetIp = 7;
inline bool UserInfo::has_internetip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_internetip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_internetip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_internetip() {
  if (internetip_ != &::google::protobuf::internal::kEmptyString) {
    internetip_->clear();
  }
  clear_has_internetip();
}
inline const ::std::string& UserInfo::internetip() const {
  return *internetip_;
}
inline void UserInfo::set_internetip(const ::std::string& value) {
  set_has_internetip();
  if (internetip_ == &::google::protobuf::internal::kEmptyString) {
    internetip_ = new ::std::string;
  }
  internetip_->assign(value);
}
inline void UserInfo::set_internetip(const char* value) {
  set_has_internetip();
  if (internetip_ == &::google::protobuf::internal::kEmptyString) {
    internetip_ = new ::std::string;
  }
  internetip_->assign(value);
}
inline void UserInfo::set_internetip(const char* value, size_t size) {
  set_has_internetip();
  if (internetip_ == &::google::protobuf::internal::kEmptyString) {
    internetip_ = new ::std::string;
  }
  internetip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_internetip() {
  set_has_internetip();
  if (internetip_ == &::google::protobuf::internal::kEmptyString) {
    internetip_ = new ::std::string;
  }
  return internetip_;
}
inline ::std::string* UserInfo::release_internetip() {
  clear_has_internetip();
  if (internetip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internetip_;
    internetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_internetip(::std::string* internetip) {
  if (internetip_ != &::google::protobuf::internal::kEmptyString) {
    delete internetip_;
  }
  if (internetip) {
    set_has_internetip();
    internetip_ = internetip;
  } else {
    clear_has_internetip();
    internetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 internetPort = 8;
inline bool UserInfo::has_internetport() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_internetport() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_internetport() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_internetport() {
  internetport_ = 0u;
  clear_has_internetport();
}
inline ::google::protobuf::uint32 UserInfo::internetport() const {
  return internetport_;
}
inline void UserInfo::set_internetport(::google::protobuf::uint32 value) {
  set_has_internetport();
  internetport_ = value;
}

// optional string relayIp = 9;
inline bool UserInfo::has_relayip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_relayip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_relayip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_relayip() {
  if (relayip_ != &::google::protobuf::internal::kEmptyString) {
    relayip_->clear();
  }
  clear_has_relayip();
}
inline const ::std::string& UserInfo::relayip() const {
  return *relayip_;
}
inline void UserInfo::set_relayip(const ::std::string& value) {
  set_has_relayip();
  if (relayip_ == &::google::protobuf::internal::kEmptyString) {
    relayip_ = new ::std::string;
  }
  relayip_->assign(value);
}
inline void UserInfo::set_relayip(const char* value) {
  set_has_relayip();
  if (relayip_ == &::google::protobuf::internal::kEmptyString) {
    relayip_ = new ::std::string;
  }
  relayip_->assign(value);
}
inline void UserInfo::set_relayip(const char* value, size_t size) {
  set_has_relayip();
  if (relayip_ == &::google::protobuf::internal::kEmptyString) {
    relayip_ = new ::std::string;
  }
  relayip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_relayip() {
  set_has_relayip();
  if (relayip_ == &::google::protobuf::internal::kEmptyString) {
    relayip_ = new ::std::string;
  }
  return relayip_;
}
inline ::std::string* UserInfo::release_relayip() {
  clear_has_relayip();
  if (relayip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relayip_;
    relayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_relayip(::std::string* relayip) {
  if (relayip_ != &::google::protobuf::internal::kEmptyString) {
    delete relayip_;
  }
  if (relayip) {
    set_has_relayip();
    relayip_ = relayip;
  } else {
    clear_has_relayip();
    relayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 relayPort = 10;
inline bool UserInfo::has_relayport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_relayport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_relayport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_relayport() {
  relayport_ = 0u;
  clear_has_relayport();
}
inline ::google::protobuf::uint32 UserInfo::relayport() const {
  return relayport_;
}
inline void UserInfo::set_relayport(::google::protobuf::uint32 value) {
  set_has_relayport();
  relayport_ = value;
}

// optional uint64 connId = 11;
inline bool UserInfo::has_connid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_connid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_connid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_connid() {
  connid_ = GOOGLE_ULONGLONG(0);
  clear_has_connid();
}
inline ::google::protobuf::uint64 UserInfo::connid() const {
  return connid_;
}
inline void UserInfo::set_connid(::google::protobuf::uint64 value) {
  set_has_connid();
  connid_ = value;
}

// optional bool is_tcp = 12;
inline bool UserInfo::has_is_tcp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_is_tcp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_is_tcp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_is_tcp() {
  is_tcp_ = false;
  clear_has_is_tcp();
}
inline bool UserInfo::is_tcp() const {
  return is_tcp_;
}
inline void UserInfo::set_is_tcp(bool value) {
  set_has_is_tcp();
  is_tcp_ = value;
}

// -------------------------------------------------------------------

// ChatInfo

// optional uint64 chatId = 1;
inline bool ChatInfo::has_chatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatInfo::set_has_chatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatInfo::clear_has_chatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatInfo::clear_chatid() {
  chatid_ = GOOGLE_ULONGLONG(0);
  clear_has_chatid();
}
inline ::google::protobuf::uint64 ChatInfo::chatid() const {
  return chatid_;
}
inline void ChatInfo::set_chatid(::google::protobuf::uint64 value) {
  set_has_chatid();
  chatid_ = value;
}

// optional .mimc.ChatType chatType = 2;
inline bool ChatInfo::has_chattype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatInfo::set_has_chattype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatInfo::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatInfo::clear_chattype() {
  chattype_ = 1;
  clear_has_chattype();
}
inline ::mimc::ChatType ChatInfo::chattype() const {
  return static_cast< ::mimc::ChatType >(chattype_);
}
inline void ChatInfo::set_chattype(::mimc::ChatType value) {
  assert(::mimc::ChatType_IsValid(value));
  set_has_chattype();
  chattype_ = value;
}

// optional .mimc.ChatStatus chatStatus = 3;
inline bool ChatInfo::has_chatstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatInfo::set_has_chatstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatInfo::clear_has_chatstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatInfo::clear_chatstatus() {
  chatstatus_ = 1;
  clear_has_chatstatus();
}
inline ::mimc::ChatStatus ChatInfo::chatstatus() const {
  return static_cast< ::mimc::ChatStatus >(chatstatus_);
}
inline void ChatInfo::set_chatstatus(::mimc::ChatStatus value) {
  assert(::mimc::ChatStatus_IsValid(value));
  set_has_chatstatus();
  chatstatus_ = value;
}

// optional int64 creatorId = 4;
inline bool ChatInfo::has_creatorid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatInfo::set_has_creatorid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatInfo::clear_has_creatorid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatInfo::clear_creatorid() {
  creatorid_ = GOOGLE_LONGLONG(0);
  clear_has_creatorid();
}
inline ::google::protobuf::int64 ChatInfo::creatorid() const {
  return creatorid_;
}
inline void ChatInfo::set_creatorid(::google::protobuf::int64 value) {
  set_has_creatorid();
  creatorid_ = value;
}

// optional string creatorResource = 5;
inline bool ChatInfo::has_creatorresource() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatInfo::set_has_creatorresource() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatInfo::clear_has_creatorresource() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatInfo::clear_creatorresource() {
  if (creatorresource_ != &::google::protobuf::internal::kEmptyString) {
    creatorresource_->clear();
  }
  clear_has_creatorresource();
}
inline const ::std::string& ChatInfo::creatorresource() const {
  return *creatorresource_;
}
inline void ChatInfo::set_creatorresource(const ::std::string& value) {
  set_has_creatorresource();
  if (creatorresource_ == &::google::protobuf::internal::kEmptyString) {
    creatorresource_ = new ::std::string;
  }
  creatorresource_->assign(value);
}
inline void ChatInfo::set_creatorresource(const char* value) {
  set_has_creatorresource();
  if (creatorresource_ == &::google::protobuf::internal::kEmptyString) {
    creatorresource_ = new ::std::string;
  }
  creatorresource_->assign(value);
}
inline void ChatInfo::set_creatorresource(const char* value, size_t size) {
  set_has_creatorresource();
  if (creatorresource_ == &::google::protobuf::internal::kEmptyString) {
    creatorresource_ = new ::std::string;
  }
  creatorresource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatInfo::mutable_creatorresource() {
  set_has_creatorresource();
  if (creatorresource_ == &::google::protobuf::internal::kEmptyString) {
    creatorresource_ = new ::std::string;
  }
  return creatorresource_;
}
inline ::std::string* ChatInfo::release_creatorresource() {
  clear_has_creatorresource();
  if (creatorresource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creatorresource_;
    creatorresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatInfo::set_allocated_creatorresource(::std::string* creatorresource) {
  if (creatorresource_ != &::google::protobuf::internal::kEmptyString) {
    delete creatorresource_;
  }
  if (creatorresource) {
    set_has_creatorresource();
    creatorresource_ = creatorresource;
  } else {
    clear_has_creatorresource();
    creatorresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mimc.UserInfo members = 6;
inline int ChatInfo::members_size() const {
  return members_.size();
}
inline void ChatInfo::clear_members() {
  members_.Clear();
}
inline const ::mimc::UserInfo& ChatInfo::members(int index) const {
  return members_.Get(index);
}
inline ::mimc::UserInfo* ChatInfo::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mimc::UserInfo* ChatInfo::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
ChatInfo::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
ChatInfo::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// XmqRTSExchange

// optional string packetId = 1;
inline bool XmqRTSExchange::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmqRTSExchange::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmqRTSExchange::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmqRTSExchange::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& XmqRTSExchange::packetid() const {
  return *packetid_;
}
inline void XmqRTSExchange::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void XmqRTSExchange::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void XmqRTSExchange::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmqRTSExchange::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* XmqRTSExchange::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmqRTSExchange::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string package = 2;
inline bool XmqRTSExchange::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmqRTSExchange::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmqRTSExchange::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmqRTSExchange::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& XmqRTSExchange::package() const {
  return *package_;
}
inline void XmqRTSExchange::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void XmqRTSExchange::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void XmqRTSExchange::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmqRTSExchange::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* XmqRTSExchange::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmqRTSExchange::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 toUuid = 3;
inline bool XmqRTSExchange::has_touuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmqRTSExchange::set_has_touuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmqRTSExchange::clear_has_touuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmqRTSExchange::clear_touuid() {
  touuid_ = GOOGLE_LONGLONG(0);
  clear_has_touuid();
}
inline ::google::protobuf::int64 XmqRTSExchange::touuid() const {
  return touuid_;
}
inline void XmqRTSExchange::set_touuid(::google::protobuf::int64 value) {
  set_has_touuid();
  touuid_ = value;
}

// optional string toResource = 4;
inline bool XmqRTSExchange::has_toresource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XmqRTSExchange::set_has_toresource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XmqRTSExchange::clear_has_toresource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XmqRTSExchange::clear_toresource() {
  if (toresource_ != &::google::protobuf::internal::kEmptyString) {
    toresource_->clear();
  }
  clear_has_toresource();
}
inline const ::std::string& XmqRTSExchange::toresource() const {
  return *toresource_;
}
inline void XmqRTSExchange::set_toresource(const ::std::string& value) {
  set_has_toresource();
  if (toresource_ == &::google::protobuf::internal::kEmptyString) {
    toresource_ = new ::std::string;
  }
  toresource_->assign(value);
}
inline void XmqRTSExchange::set_toresource(const char* value) {
  set_has_toresource();
  if (toresource_ == &::google::protobuf::internal::kEmptyString) {
    toresource_ = new ::std::string;
  }
  toresource_->assign(value);
}
inline void XmqRTSExchange::set_toresource(const char* value, size_t size) {
  set_has_toresource();
  if (toresource_ == &::google::protobuf::internal::kEmptyString) {
    toresource_ = new ::std::string;
  }
  toresource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmqRTSExchange::mutable_toresource() {
  set_has_toresource();
  if (toresource_ == &::google::protobuf::internal::kEmptyString) {
    toresource_ = new ::std::string;
  }
  return toresource_;
}
inline ::std::string* XmqRTSExchange::release_toresource() {
  clear_has_toresource();
  if (toresource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toresource_;
    toresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmqRTSExchange::set_allocated_toresource(::std::string* toresource) {
  if (toresource_ != &::google::protobuf::internal::kEmptyString) {
    delete toresource_;
  }
  if (toresource) {
    set_has_toresource();
    toresource_ = toresource;
  } else {
    clear_has_toresource();
    toresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mimc.RTSMessage message = 5;
inline bool XmqRTSExchange::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XmqRTSExchange::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XmqRTSExchange::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XmqRTSExchange::clear_message() {
  if (message_ != NULL) message_->::mimc::RTSMessage::Clear();
  clear_has_message();
}
inline const ::mimc::RTSMessage& XmqRTSExchange::message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return message_ != NULL ? *message_ : *default_instance().message_;
#else
  return message_ != NULL ? *message_ : *default_instance_->message_;
#endif
}
inline ::mimc::RTSMessage* XmqRTSExchange::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::mimc::RTSMessage;
  return message_;
}
inline ::mimc::RTSMessage* XmqRTSExchange::release_message() {
  clear_has_message();
  ::mimc::RTSMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void XmqRTSExchange::set_allocated_message(::mimc::RTSMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
}

// optional int64 timestamp = 6;
inline bool XmqRTSExchange::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XmqRTSExchange::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XmqRTSExchange::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XmqRTSExchange::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 XmqRTSExchange::timestamp() const {
  return timestamp_;
}
inline void XmqRTSExchange::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// RTSMessage

// optional .mimc.RTSMessageType type = 1;
inline bool RTSMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RTSMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RTSMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RTSMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::RTSMessageType RTSMessage::type() const {
  return static_cast< ::mimc::RTSMessageType >(type_);
}
inline void RTSMessage::set_type(::mimc::RTSMessageType value) {
  assert(::mimc::RTSMessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 chatId = 2;
inline bool RTSMessage::has_chatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RTSMessage::set_has_chatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RTSMessage::clear_has_chatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RTSMessage::clear_chatid() {
  chatid_ = GOOGLE_ULONGLONG(0);
  clear_has_chatid();
}
inline ::google::protobuf::uint64 RTSMessage::chatid() const {
  return chatid_;
}
inline void RTSMessage::set_chatid(::google::protobuf::uint64 value) {
  set_has_chatid();
  chatid_ = value;
}

// optional .mimc.ChatType chatType = 3;
inline bool RTSMessage::has_chattype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RTSMessage::set_has_chattype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RTSMessage::clear_has_chattype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RTSMessage::clear_chattype() {
  chattype_ = 1;
  clear_has_chattype();
}
inline ::mimc::ChatType RTSMessage::chattype() const {
  return static_cast< ::mimc::ChatType >(chattype_);
}
inline void RTSMessage::set_chattype(::mimc::ChatType value) {
  assert(::mimc::ChatType_IsValid(value));
  set_has_chattype();
  chattype_ = value;
}

// optional int64 uuid = 4;
inline bool RTSMessage::has_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RTSMessage::set_has_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RTSMessage::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RTSMessage::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 RTSMessage::uuid() const {
  return uuid_;
}
inline void RTSMessage::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 5;
inline bool RTSMessage::has_resource() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RTSMessage::set_has_resource() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RTSMessage::clear_has_resource() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RTSMessage::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& RTSMessage::resource() const {
  return *resource_;
}
inline void RTSMessage::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void RTSMessage::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void RTSMessage::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTSMessage::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* RTSMessage::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RTSMessage::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes payload = 6;
inline bool RTSMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RTSMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RTSMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RTSMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& RTSMessage::payload() const {
  return *payload_;
}
inline void RTSMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void RTSMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void RTSMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RTSMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* RTSMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RTSMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 region_bucket = 7;
inline bool RTSMessage::has_region_bucket() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RTSMessage::set_has_region_bucket() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RTSMessage::clear_has_region_bucket() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RTSMessage::clear_region_bucket() {
  region_bucket_ = GOOGLE_LONGLONG(0);
  clear_has_region_bucket();
}
inline ::google::protobuf::int64 RTSMessage::region_bucket() const {
  return region_bucket_;
}
inline void RTSMessage::set_region_bucket(::google::protobuf::int64 value) {
  set_has_region_bucket();
  region_bucket_ = value;
}

// -------------------------------------------------------------------

// CreateRequest

// optional .mimc.StreamDataType streamType = 1;
inline bool CreateRequest::has_streamtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRequest::set_has_streamtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRequest::clear_has_streamtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRequest::clear_streamtype() {
  streamtype_ = 1;
  clear_has_streamtype();
}
inline ::mimc::StreamDataType CreateRequest::streamtype() const {
  return static_cast< ::mimc::StreamDataType >(streamtype_);
}
inline void CreateRequest::set_streamtype(::mimc::StreamDataType value) {
  assert(::mimc::StreamDataType_IsValid(value));
  set_has_streamtype();
  streamtype_ = value;
}

// repeated .mimc.UserInfo members = 2;
inline int CreateRequest::members_size() const {
  return members_.size();
}
inline void CreateRequest::clear_members() {
  members_.Clear();
}
inline const ::mimc::UserInfo& CreateRequest::members(int index) const {
  return members_.Get(index);
}
inline ::mimc::UserInfo* CreateRequest::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mimc::UserInfo* CreateRequest::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
CreateRequest::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
CreateRequest::mutable_members() {
  return &members_;
}

// optional string sdp = 3;
inline bool CreateRequest::has_sdp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRequest::set_has_sdp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRequest::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRequest::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& CreateRequest::sdp() const {
  return *sdp_;
}
inline void CreateRequest::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void CreateRequest::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void CreateRequest::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRequest::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* CreateRequest::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRequest::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appContent = 4;
inline bool CreateRequest::has_appcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRequest::set_has_appcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRequest::clear_has_appcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRequest::clear_appcontent() {
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    appcontent_->clear();
  }
  clear_has_appcontent();
}
inline const ::std::string& CreateRequest::appcontent() const {
  return *appcontent_;
}
inline void CreateRequest::set_appcontent(const ::std::string& value) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(value);
}
inline void CreateRequest::set_appcontent(const char* value) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(value);
}
inline void CreateRequest::set_appcontent(const void* value, size_t size) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRequest::mutable_appcontent() {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  return appcontent_;
}
inline ::std::string* CreateRequest::release_appcontent() {
  clear_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appcontent_;
    appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRequest::set_allocated_appcontent(::std::string* appcontent) {
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete appcontent_;
  }
  if (appcontent) {
    set_has_appcontent();
    appcontent_ = appcontent;
  } else {
    clear_has_appcontent();
    appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InviteRequest

// optional .mimc.StreamDataType streamType = 1;
inline bool InviteRequest::has_streamtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteRequest::set_has_streamtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteRequest::clear_has_streamtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteRequest::clear_streamtype() {
  streamtype_ = 1;
  clear_has_streamtype();
}
inline ::mimc::StreamDataType InviteRequest::streamtype() const {
  return static_cast< ::mimc::StreamDataType >(streamtype_);
}
inline void InviteRequest::set_streamtype(::mimc::StreamDataType value) {
  assert(::mimc::StreamDataType_IsValid(value));
  set_has_streamtype();
  streamtype_ = value;
}

// repeated .mimc.UserInfo members = 2;
inline int InviteRequest::members_size() const {
  return members_.size();
}
inline void InviteRequest::clear_members() {
  members_.Clear();
}
inline const ::mimc::UserInfo& InviteRequest::members(int index) const {
  return members_.Get(index);
}
inline ::mimc::UserInfo* InviteRequest::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mimc::UserInfo* InviteRequest::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
InviteRequest::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
InviteRequest::mutable_members() {
  return &members_;
}

// optional string sdp = 3;
inline bool InviteRequest::has_sdp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteRequest::set_has_sdp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteRequest::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteRequest::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& InviteRequest::sdp() const {
  return *sdp_;
}
inline void InviteRequest::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void InviteRequest::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void InviteRequest::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteRequest::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* InviteRequest::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteRequest::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appContent = 4;
inline bool InviteRequest::has_appcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteRequest::set_has_appcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteRequest::clear_has_appcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteRequest::clear_appcontent() {
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    appcontent_->clear();
  }
  clear_has_appcontent();
}
inline const ::std::string& InviteRequest::appcontent() const {
  return *appcontent_;
}
inline void InviteRequest::set_appcontent(const ::std::string& value) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(value);
}
inline void InviteRequest::set_appcontent(const char* value) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(value);
}
inline void InviteRequest::set_appcontent(const void* value, size_t size) {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  appcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteRequest::mutable_appcontent() {
  set_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    appcontent_ = new ::std::string;
  }
  return appcontent_;
}
inline ::std::string* InviteRequest::release_appcontent() {
  clear_has_appcontent();
  if (appcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appcontent_;
    appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteRequest::set_allocated_appcontent(::std::string* appcontent) {
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete appcontent_;
  }
  if (appcontent) {
    set_has_appcontent();
    appcontent_ = appcontent;
  } else {
    clear_has_appcontent();
    appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InviteResponse

// optional .mimc.RTSResult result = 1;
inline bool InviteResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InviteResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InviteResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::mimc::RTSResult InviteResponse::result() const {
  return static_cast< ::mimc::RTSResult >(result_);
}
inline void InviteResponse::set_result(::mimc::RTSResult value) {
  assert(::mimc::RTSResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string errmsg = 2;
inline bool InviteResponse::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteResponse::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InviteResponse::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InviteResponse::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& InviteResponse::errmsg() const {
  return *errmsg_;
}
inline void InviteResponse::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void InviteResponse::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void InviteResponse::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteResponse::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* InviteResponse::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteResponse::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sdp = 3;
inline bool InviteResponse::has_sdp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteResponse::set_has_sdp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InviteResponse::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InviteResponse::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& InviteResponse::sdp() const {
  return *sdp_;
}
inline void InviteResponse::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void InviteResponse::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void InviteResponse::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InviteResponse::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* InviteResponse::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InviteResponse::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mimc.UserInfo user = 4;
inline bool InviteResponse::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InviteResponse::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InviteResponse::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InviteResponse::clear_user() {
  if (user_ != NULL) user_->::mimc::UserInfo::Clear();
  clear_has_user();
}
inline const ::mimc::UserInfo& InviteResponse::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::mimc::UserInfo* InviteResponse::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mimc::UserInfo;
  return user_;
}
inline ::mimc::UserInfo* InviteResponse::release_user() {
  clear_has_user();
  ::mimc::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void InviteResponse::set_allocated_user(::mimc::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// -------------------------------------------------------------------

// CreateResponse

// optional .mimc.RTSResult result = 1;
inline bool CreateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::mimc::RTSResult CreateResponse::result() const {
  return static_cast< ::mimc::RTSResult >(result_);
}
inline void CreateResponse::set_result(::mimc::RTSResult value) {
  assert(::mimc::RTSResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string errmsg = 2;
inline bool CreateResponse::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateResponse::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateResponse::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateResponse::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& CreateResponse::errmsg() const {
  return *errmsg_;
}
inline void CreateResponse::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void CreateResponse::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
}
inline void CreateResponse::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateResponse::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    errmsg_ = new ::std::string;
  }
  return errmsg_;
}
inline ::std::string* CreateResponse::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateResponse::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sdp = 3;
inline bool CreateResponse::has_sdp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateResponse::set_has_sdp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateResponse::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateResponse::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& CreateResponse::sdp() const {
  return *sdp_;
}
inline void CreateResponse::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void CreateResponse::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void CreateResponse::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateResponse::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* CreateResponse::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateResponse::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mimc.UserInfo members = 4;
inline int CreateResponse::members_size() const {
  return members_.size();
}
inline void CreateResponse::clear_members() {
  members_.Clear();
}
inline const ::mimc::UserInfo& CreateResponse::members(int index) const {
  return members_.Get(index);
}
inline ::mimc::UserInfo* CreateResponse::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::mimc::UserInfo* CreateResponse::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >&
CreateResponse::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UserInfo >*
CreateResponse::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// UpdateRequest

// optional .mimc.UserInfo user = 1;
inline bool UpdateRequest::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRequest::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRequest::clear_user() {
  if (user_ != NULL) user_->::mimc::UserInfo::Clear();
  clear_has_user();
}
inline const ::mimc::UserInfo& UpdateRequest::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::mimc::UserInfo* UpdateRequest::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mimc::UserInfo;
  return user_;
}
inline ::mimc::UserInfo* UpdateRequest::release_user() {
  clear_has_user();
  ::mimc::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void UpdateRequest::set_allocated_user(::mimc::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// -------------------------------------------------------------------

// UpdateResponse

// optional .mimc.RTSResult result = 1;
inline bool UpdateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::mimc::RTSResult UpdateResponse::result() const {
  return static_cast< ::mimc::RTSResult >(result_);
}
inline void UpdateResponse::set_result(::mimc::RTSResult value) {
  assert(::mimc::RTSResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// ByeRequest

// optional string reason = 1;
inline bool ByeRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByeRequest::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ByeRequest::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ByeRequest::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& ByeRequest::reason() const {
  return *reason_;
}
inline void ByeRequest::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ByeRequest::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ByeRequest::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ByeRequest::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* ByeRequest::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ByeRequest::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ByeResponse

// optional .mimc.RTSResult result = 1;
inline bool ByeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ByeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ByeResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::mimc::RTSResult ByeResponse::result() const {
  return static_cast< ::mimc::RTSResult >(result_);
}
inline void ByeResponse::set_result(::mimc::RTSResult value) {
  assert(::mimc::RTSResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string reason = 2;
inline bool ByeResponse::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ByeResponse::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ByeResponse::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ByeResponse::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& ByeResponse::reason() const {
  return *reason_;
}
inline void ByeResponse::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ByeResponse::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ByeResponse::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ByeResponse::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* ByeResponse::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ByeResponse::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateChatInfo

// optional uint64 chatId = 1;
inline bool UpdateChatInfo::has_chatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateChatInfo::set_has_chatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateChatInfo::clear_has_chatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateChatInfo::clear_chatid() {
  chatid_ = GOOGLE_ULONGLONG(0);
  clear_has_chatid();
}
inline ::google::protobuf::uint64 UpdateChatInfo::chatid() const {
  return chatid_;
}
inline void UpdateChatInfo::set_chatid(::google::protobuf::uint64 value) {
  set_has_chatid();
  chatid_ = value;
}

// optional .mimc.UpdateType type = 2;
inline bool UpdateChatInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateChatInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateChatInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateChatInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::UpdateType UpdateChatInfo::type() const {
  return static_cast< ::mimc::UpdateType >(type_);
}
inline void UpdateChatInfo::set_type(::mimc::UpdateType value) {
  assert(::mimc::UpdateType_IsValid(value));
  set_has_type();
  type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rts_5fsignal_2eproto__INCLUDED
