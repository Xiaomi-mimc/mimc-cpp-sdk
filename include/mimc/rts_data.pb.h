// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rts_data.proto

#ifndef PROTOBUF_rts_5fdata_2eproto__INCLUDED
#define PROTOBUF_rts_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mimc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rts_5fdata_2eproto();
void protobuf_AssignDesc_rts_5fdata_2eproto();
void protobuf_ShutdownFile_rts_5fdata_2eproto();

class UserPacket;
class BindRelayRequest;
class StreamConfig;
class BindRelayResponse;
class PingRelayRequest;
class PingRelayResponse;
class UnBindRelayRequest;
class UnBindRelayResponse;
class RelayKickRequest;
class RelayKickResponse;
class RouterPacket;
class BurrowPacket;

enum PKT_TYPE {
  BIND_RELAY_REQUEST = 1,
  BIND_RELAY_RESPONSE = 2,
  PING_RELAY_REQUEST = 3,
  PING_RELAY_RESPONSE = 4,
  RELAY_KICK_REQUEST = 5,
  RELAY_KICK_RESPONSE = 6,
  USER_DATA_AUDIO = 7,
  USER_DATA_VIDEO = 8,
  RELAY_CONN_REQUEST = 9,
  INTRANET_CONN_REQUEST = 10,
  INTERNET_CONN_REQUEST = 11
};
bool PKT_TYPE_IsValid(int value);
const PKT_TYPE PKT_TYPE_MIN = BIND_RELAY_REQUEST;
const PKT_TYPE PKT_TYPE_MAX = INTERNET_CONN_REQUEST;
const int PKT_TYPE_ARRAYSIZE = PKT_TYPE_MAX + 1;

enum STREAM_STRATEGY {
  FEC_STRATEGY = 1,
  ACK_STRATEGY = 2
};
bool STREAM_STRATEGY_IsValid(int value);
const STREAM_STRATEGY STREAM_STRATEGY_MIN = FEC_STRATEGY;
const STREAM_STRATEGY STREAM_STRATEGY_MAX = ACK_STRATEGY;
const int STREAM_STRATEGY_ARRAYSIZE = STREAM_STRATEGY_MAX + 1;

enum KICK_REASON {
  REALY_CHEANGED = 1
};
bool KICK_REASON_IsValid(int value);
const KICK_REASON KICK_REASON_MIN = REALY_CHEANGED;
const KICK_REASON KICK_REASON_MAX = REALY_CHEANGED;
const int KICK_REASON_ARRAYSIZE = KICK_REASON_MAX + 1;

enum STREAM_TYPE {
  SIGNAL_STREAM = 1,
  AUDIO_STREAM = 2,
  VIDEO_STREAM = 3
};
bool STREAM_TYPE_IsValid(int value);
const STREAM_TYPE STREAM_TYPE_MIN = SIGNAL_STREAM;
const STREAM_TYPE STREAM_TYPE_MAX = VIDEO_STREAM;
const int STREAM_TYPE_ARRAYSIZE = STREAM_TYPE_MAX + 1;

enum CHANNEL_TYPE {
  RELAY = 1,
  P2P = 2
};
bool CHANNEL_TYPE_IsValid(int value);
const CHANNEL_TYPE CHANNEL_TYPE_MIN = RELAY;
const CHANNEL_TYPE CHANNEL_TYPE_MAX = P2P;
const int CHANNEL_TYPE_ARRAYSIZE = CHANNEL_TYPE_MAX + 1;

enum BURROW_TYPE {
  INTRANET_BURROW_REQUEST = 1,
  INTRANET_BURROW_RESPONSE = 2,
  INTERNET_BURROW_REQUEST = 3,
  INTERNET_BURROW_RESPONSE = 4
};
bool BURROW_TYPE_IsValid(int value);
const BURROW_TYPE BURROW_TYPE_MIN = INTRANET_BURROW_REQUEST;
const BURROW_TYPE BURROW_TYPE_MAX = INTERNET_BURROW_RESPONSE;
const int BURROW_TYPE_ARRAYSIZE = BURROW_TYPE_MAX + 1;

// ===================================================================

class UserPacket : public ::google::protobuf::MessageLite {
 public:
  UserPacket();
  virtual ~UserPacket();

  UserPacket(const UserPacket& from);

  inline UserPacket& operator=(const UserPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserPacket* other);

  // implements Message ----------------------------------------------

  UserPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserPacket& from);
  void MergeFrom(const UserPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required .mimc.PKT_TYPE pkt_type = 2;
  inline bool has_pkt_type() const;
  inline void clear_pkt_type();
  static const int kPktTypeFieldNumber = 2;
  inline ::mimc::PKT_TYPE pkt_type() const;
  inline void set_pkt_type(::mimc::PKT_TYPE value);

  // required uint64 uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional uint64 call_id = 5;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 5;
  inline ::google::protobuf::uint64 call_id() const;
  inline void set_call_id(::google::protobuf::uint64 value);

  // optional bytes payload = 6;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 6;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 region_bucket = 7;
  inline bool has_region_bucket() const;
  inline void clear_region_bucket();
  static const int kRegionBucketFieldNumber = 7;
  inline ::google::protobuf::int64 region_bucket() const;
  inline void set_region_bucket(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.UserPacket)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_pkt_type();
  inline void clear_has_pkt_type();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_region_bucket();
  inline void clear_has_region_bucket();

  ::google::protobuf::uint32 version_;
  int pkt_type_;
  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::uint64 call_id_;
  ::std::string* payload_;
  ::google::protobuf::int64 region_bucket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static UserPacket* default_instance_;
};
// -------------------------------------------------------------------

class BindRelayRequest : public ::google::protobuf::MessageLite {
 public:
  BindRelayRequest();
  virtual ~BindRelayRequest();

  BindRelayRequest(const BindRelayRequest& from);

  inline BindRelayRequest& operator=(const BindRelayRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const BindRelayRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BindRelayRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BindRelayRequest* other);

  // implements Message ----------------------------------------------

  BindRelayRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BindRelayRequest& from);
  void MergeFrom(const BindRelayRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional string intranet_ip = 3;
  inline bool has_intranet_ip() const;
  inline void clear_intranet_ip();
  static const int kIntranetIpFieldNumber = 3;
  inline const ::std::string& intranet_ip() const;
  inline void set_intranet_ip(const ::std::string& value);
  inline void set_intranet_ip(const char* value);
  inline void set_intranet_ip(const char* value, size_t size);
  inline ::std::string* mutable_intranet_ip();
  inline ::std::string* release_intranet_ip();
  inline void set_allocated_intranet_ip(::std::string* intranet_ip);

  // optional int32 intranet_port = 4;
  inline bool has_intranet_port() const;
  inline void clear_intranet_port();
  static const int kIntranetPortFieldNumber = 4;
  inline ::google::protobuf::int32 intranet_port() const;
  inline void set_intranet_port(::google::protobuf::int32 value);

  // optional string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional .mimc.StreamConfig audio_stream_default_config = 6;
  inline bool has_audio_stream_default_config() const;
  inline void clear_audio_stream_default_config();
  static const int kAudioStreamDefaultConfigFieldNumber = 6;
  inline const ::mimc::StreamConfig& audio_stream_default_config() const;
  inline ::mimc::StreamConfig* mutable_audio_stream_default_config();
  inline ::mimc::StreamConfig* release_audio_stream_default_config();
  inline void set_allocated_audio_stream_default_config(::mimc::StreamConfig* audio_stream_default_config);

  // optional .mimc.StreamConfig video_stream_default_config = 7;
  inline bool has_video_stream_default_config() const;
  inline void clear_video_stream_default_config();
  static const int kVideoStreamDefaultConfigFieldNumber = 7;
  inline const ::mimc::StreamConfig& video_stream_default_config() const;
  inline ::mimc::StreamConfig* mutable_video_stream_default_config();
  inline ::mimc::StreamConfig* release_video_stream_default_config();
  inline void set_allocated_video_stream_default_config(::mimc::StreamConfig* video_stream_default_config);

  // @@protoc_insertion_point(class_scope:mimc.BindRelayRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_intranet_ip();
  inline void clear_has_intranet_ip();
  inline void set_has_intranet_port();
  inline void clear_has_intranet_port();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_audio_stream_default_config();
  inline void clear_has_audio_stream_default_config();
  inline void set_has_video_stream_default_config();
  inline void clear_has_video_stream_default_config();

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;
  ::std::string* intranet_ip_;
  ::std::string* token_;
  ::mimc::StreamConfig* audio_stream_default_config_;
  ::mimc::StreamConfig* video_stream_default_config_;
  ::google::protobuf::int32 intranet_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static BindRelayRequest* default_instance_;
};
// -------------------------------------------------------------------

class StreamConfig : public ::google::protobuf::MessageLite {
 public:
  StreamConfig();
  virtual ~StreamConfig();

  StreamConfig(const StreamConfig& from);

  inline StreamConfig& operator=(const StreamConfig& from) {
    CopyFrom(from);
    return *this;
  }

  static const StreamConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StreamConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StreamConfig* other);

  // implements Message ----------------------------------------------

  StreamConfig* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StreamConfig& from);
  void MergeFrom(const StreamConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.STREAM_STRATEGY stream_strategy = 1;
  inline bool has_stream_strategy() const;
  inline void clear_stream_strategy();
  static const int kStreamStrategyFieldNumber = 1;
  inline ::mimc::STREAM_STRATEGY stream_strategy() const;
  inline void set_stream_strategy(::mimc::STREAM_STRATEGY value);

  // optional uint32 ack_stream_wait_time_ms = 2;
  inline bool has_ack_stream_wait_time_ms() const;
  inline void clear_ack_stream_wait_time_ms();
  static const int kAckStreamWaitTimeMsFieldNumber = 2;
  inline ::google::protobuf::uint32 ack_stream_wait_time_ms() const;
  inline void set_ack_stream_wait_time_ms(::google::protobuf::uint32 value);

  // optional uint32 stream_timeout_s = 3;
  inline bool has_stream_timeout_s() const;
  inline void clear_stream_timeout_s();
  static const int kStreamTimeoutSFieldNumber = 3;
  inline ::google::protobuf::uint32 stream_timeout_s() const;
  inline void set_stream_timeout_s(::google::protobuf::uint32 value);

  // optional bool stream_is_encrypt = 4;
  inline bool has_stream_is_encrypt() const;
  inline void clear_stream_is_encrypt();
  static const int kStreamIsEncryptFieldNumber = 4;
  inline bool stream_is_encrypt() const;
  inline void set_stream_is_encrypt(bool value);

  // @@protoc_insertion_point(class_scope:mimc.StreamConfig)
 private:
  inline void set_has_stream_strategy();
  inline void clear_has_stream_strategy();
  inline void set_has_ack_stream_wait_time_ms();
  inline void clear_has_ack_stream_wait_time_ms();
  inline void set_has_stream_timeout_s();
  inline void clear_has_stream_timeout_s();
  inline void set_has_stream_is_encrypt();
  inline void clear_has_stream_is_encrypt();

  int stream_strategy_;
  ::google::protobuf::uint32 ack_stream_wait_time_ms_;
  ::google::protobuf::uint32 stream_timeout_s_;
  bool stream_is_encrypt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static StreamConfig* default_instance_;
};
// -------------------------------------------------------------------

class BindRelayResponse : public ::google::protobuf::MessageLite {
 public:
  BindRelayResponse();
  virtual ~BindRelayResponse();

  BindRelayResponse(const BindRelayResponse& from);

  inline BindRelayResponse& operator=(const BindRelayResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const BindRelayResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BindRelayResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BindRelayResponse* other);

  // implements Message ----------------------------------------------

  BindRelayResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BindRelayResponse& from);
  void MergeFrom(const BindRelayResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // required string internet_ip = 2;
  inline bool has_internet_ip() const;
  inline void clear_internet_ip();
  static const int kInternetIpFieldNumber = 2;
  inline const ::std::string& internet_ip() const;
  inline void set_internet_ip(const ::std::string& value);
  inline void set_internet_ip(const char* value);
  inline void set_internet_ip(const char* value, size_t size);
  inline ::std::string* mutable_internet_ip();
  inline ::std::string* release_internet_ip();
  inline void set_allocated_internet_ip(::std::string* internet_ip);

  // required int32 internet_port = 3;
  inline bool has_internet_port() const;
  inline void clear_internet_port();
  static const int kInternetPortFieldNumber = 3;
  inline ::google::protobuf::int32 internet_port() const;
  inline void set_internet_port(::google::protobuf::int32 value);

  // optional string relay_ip = 4;
  inline bool has_relay_ip() const;
  inline void clear_relay_ip();
  static const int kRelayIpFieldNumber = 4;
  inline const ::std::string& relay_ip() const;
  inline void set_relay_ip(const ::std::string& value);
  inline void set_relay_ip(const char* value);
  inline void set_relay_ip(const char* value, size_t size);
  inline ::std::string* mutable_relay_ip();
  inline ::std::string* release_relay_ip();
  inline void set_allocated_relay_ip(::std::string* relay_ip);

  // optional int32 relay_port = 5;
  inline bool has_relay_port() const;
  inline void clear_relay_port();
  static const int kRelayPortFieldNumber = 5;
  inline ::google::protobuf::int32 relay_port() const;
  inline void set_relay_port(::google::protobuf::int32 value);

  // optional uint32 errorno = 6;
  inline bool has_errorno() const;
  inline void clear_errorno();
  static const int kErrornoFieldNumber = 6;
  inline ::google::protobuf::uint32 errorno() const;
  inline void set_errorno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mimc.BindRelayResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_internet_ip();
  inline void clear_has_internet_ip();
  inline void set_has_internet_port();
  inline void clear_has_internet_port();
  inline void set_has_relay_ip();
  inline void clear_has_relay_ip();
  inline void set_has_relay_port();
  inline void clear_has_relay_port();
  inline void set_has_errorno();
  inline void clear_has_errorno();

  ::std::string* internet_ip_;
  bool result_;
  ::google::protobuf::int32 internet_port_;
  ::std::string* relay_ip_;
  ::google::protobuf::int32 relay_port_;
  ::google::protobuf::uint32 errorno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static BindRelayResponse* default_instance_;
};
// -------------------------------------------------------------------

class PingRelayRequest : public ::google::protobuf::MessageLite {
 public:
  PingRelayRequest();
  virtual ~PingRelayRequest();

  PingRelayRequest(const PingRelayRequest& from);

  inline PingRelayRequest& operator=(const PingRelayRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingRelayRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingRelayRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingRelayRequest* other);

  // implements Message ----------------------------------------------

  PingRelayRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingRelayRequest& from);
  void MergeFrom(const PingRelayRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.PingRelayRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static PingRelayRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingRelayResponse : public ::google::protobuf::MessageLite {
 public:
  PingRelayResponse();
  virtual ~PingRelayResponse();

  PingRelayResponse(const PingRelayResponse& from);

  inline PingRelayResponse& operator=(const PingRelayResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingRelayResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingRelayResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingRelayResponse* other);

  // implements Message ----------------------------------------------

  PingRelayResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingRelayResponse& from);
  void MergeFrom(const PingRelayResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline bool result() const;
  inline void set_result(bool value);

  // required string internet_ip = 2;
  inline bool has_internet_ip() const;
  inline void clear_internet_ip();
  static const int kInternetIpFieldNumber = 2;
  inline const ::std::string& internet_ip() const;
  inline void set_internet_ip(const ::std::string& value);
  inline void set_internet_ip(const char* value);
  inline void set_internet_ip(const char* value, size_t size);
  inline ::std::string* mutable_internet_ip();
  inline ::std::string* release_internet_ip();
  inline void set_allocated_internet_ip(::std::string* internet_ip);

  // required int32 internet_port = 3;
  inline bool has_internet_port() const;
  inline void clear_internet_port();
  static const int kInternetPortFieldNumber = 3;
  inline ::google::protobuf::int32 internet_port() const;
  inline void set_internet_port(::google::protobuf::int32 value);

  // optional uint32 errorno = 4;
  inline bool has_errorno() const;
  inline void clear_errorno();
  static const int kErrornoFieldNumber = 4;
  inline ::google::protobuf::uint32 errorno() const;
  inline void set_errorno(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mimc.PingRelayResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_internet_ip();
  inline void clear_has_internet_ip();
  inline void set_has_internet_port();
  inline void clear_has_internet_port();
  inline void set_has_errorno();
  inline void clear_has_errorno();

  ::std::string* internet_ip_;
  bool result_;
  ::google::protobuf::int32 internet_port_;
  ::google::protobuf::uint32 errorno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static PingRelayResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnBindRelayRequest : public ::google::protobuf::MessageLite {
 public:
  UnBindRelayRequest();
  virtual ~UnBindRelayRequest();

  UnBindRelayRequest(const UnBindRelayRequest& from);

  inline UnBindRelayRequest& operator=(const UnBindRelayRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnBindRelayRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnBindRelayRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnBindRelayRequest* other);

  // implements Message ----------------------------------------------

  UnBindRelayRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnBindRelayRequest& from);
  void MergeFrom(const UnBindRelayRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:mimc.UnBindRelayRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static UnBindRelayRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnBindRelayResponse : public ::google::protobuf::MessageLite {
 public:
  UnBindRelayResponse();
  virtual ~UnBindRelayResponse();

  UnBindRelayResponse(const UnBindRelayResponse& from);

  inline UnBindRelayResponse& operator=(const UnBindRelayResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnBindRelayResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnBindRelayResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnBindRelayResponse* other);

  // implements Message ----------------------------------------------

  UnBindRelayResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnBindRelayResponse& from);
  void MergeFrom(const UnBindRelayResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // @@protoc_insertion_point(class_scope:mimc.UnBindRelayResponse)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();

  bool is_ok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static UnBindRelayResponse* default_instance_;
};
// -------------------------------------------------------------------

class RelayKickRequest : public ::google::protobuf::MessageLite {
 public:
  RelayKickRequest();
  virtual ~RelayKickRequest();

  RelayKickRequest(const RelayKickRequest& from);

  inline RelayKickRequest& operator=(const RelayKickRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const RelayKickRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RelayKickRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RelayKickRequest* other);

  // implements Message ----------------------------------------------

  RelayKickRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RelayKickRequest& from);
  void MergeFrom(const RelayKickRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.KICK_REASON reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::mimc::KICK_REASON reason() const;
  inline void set_reason(::mimc::KICK_REASON value);

  // @@protoc_insertion_point(class_scope:mimc.RelayKickRequest)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  int reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static RelayKickRequest* default_instance_;
};
// -------------------------------------------------------------------

class RelayKickResponse : public ::google::protobuf::MessageLite {
 public:
  RelayKickResponse();
  virtual ~RelayKickResponse();

  RelayKickResponse(const RelayKickResponse& from);

  inline RelayKickResponse& operator=(const RelayKickResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const RelayKickResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RelayKickResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RelayKickResponse* other);

  // implements Message ----------------------------------------------

  RelayKickResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RelayKickResponse& from);
  void MergeFrom(const RelayKickResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_ok = 1;
  inline bool has_is_ok() const;
  inline void clear_is_ok();
  static const int kIsOkFieldNumber = 1;
  inline bool is_ok() const;
  inline void set_is_ok(bool value);

  // @@protoc_insertion_point(class_scope:mimc.RelayKickResponse)
 private:
  inline void set_has_is_ok();
  inline void clear_has_is_ok();

  bool is_ok_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static RelayKickResponse* default_instance_;
};
// -------------------------------------------------------------------

class RouterPacket : public ::google::protobuf::MessageLite {
 public:
  RouterPacket();
  virtual ~RouterPacket();

  RouterPacket(const RouterPacket& from);

  inline RouterPacket& operator=(const RouterPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouterPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouterPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouterPacket* other);

  // implements Message ----------------------------------------------

  RouterPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouterPacket& from);
  void MergeFrom(const RouterPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::uint64 call_id() const;
  inline void set_call_id(::google::protobuf::uint64 value);

  // optional uint64 from_uuid = 2;
  inline bool has_from_uuid() const;
  inline void clear_from_uuid();
  static const int kFromUuidFieldNumber = 2;
  inline ::google::protobuf::uint64 from_uuid() const;
  inline void set_from_uuid(::google::protobuf::uint64 value);

  // optional string from_resource = 3;
  inline bool has_from_resource() const;
  inline void clear_from_resource();
  static const int kFromResourceFieldNumber = 3;
  inline const ::std::string& from_resource() const;
  inline void set_from_resource(const ::std::string& value);
  inline void set_from_resource(const char* value);
  inline void set_from_resource(const char* value, size_t size);
  inline ::std::string* mutable_from_resource();
  inline ::std::string* release_from_resource();
  inline void set_allocated_from_resource(::std::string* from_resource);

  // optional uint64 to_uuid = 4;
  inline bool has_to_uuid() const;
  inline void clear_to_uuid();
  static const int kToUuidFieldNumber = 4;
  inline ::google::protobuf::uint64 to_uuid() const;
  inline void set_to_uuid(::google::protobuf::uint64 value);

  // optional string to_resource = 5;
  inline bool has_to_resource() const;
  inline void clear_to_resource();
  static const int kToResourceFieldNumber = 5;
  inline const ::std::string& to_resource() const;
  inline void set_to_resource(const ::std::string& value);
  inline void set_to_resource(const char* value);
  inline void set_to_resource(const char* value, size_t size);
  inline ::std::string* mutable_to_resource();
  inline ::std::string* release_to_resource();
  inline void set_allocated_to_resource(::std::string* to_resource);

  // optional uint64 to_conn_id = 6;
  inline bool has_to_conn_id() const;
  inline void clear_to_conn_id();
  static const int kToConnIdFieldNumber = 6;
  inline ::google::protobuf::uint64 to_conn_id() const;
  inline void set_to_conn_id(::google::protobuf::uint64 value);

  // optional .mimc.STREAM_TYPE stream_type = 7;
  inline bool has_stream_type() const;
  inline void clear_stream_type();
  static const int kStreamTypeFieldNumber = 7;
  inline ::mimc::STREAM_TYPE stream_type() const;
  inline void set_stream_type(::mimc::STREAM_TYPE value);

  // optional bytes payload = 8;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 8;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 region_bucket = 9;
  inline bool has_region_bucket() const;
  inline void clear_region_bucket();
  static const int kRegionBucketFieldNumber = 9;
  inline ::google::protobuf::int64 region_bucket() const;
  inline void set_region_bucket(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.RouterPacket)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_from_uuid();
  inline void clear_has_from_uuid();
  inline void set_has_from_resource();
  inline void clear_has_from_resource();
  inline void set_has_to_uuid();
  inline void clear_has_to_uuid();
  inline void set_has_to_resource();
  inline void clear_has_to_resource();
  inline void set_has_to_conn_id();
  inline void clear_has_to_conn_id();
  inline void set_has_stream_type();
  inline void clear_has_stream_type();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_region_bucket();
  inline void clear_has_region_bucket();

  ::google::protobuf::uint64 call_id_;
  ::google::protobuf::uint64 from_uuid_;
  ::std::string* from_resource_;
  ::google::protobuf::uint64 to_uuid_;
  ::std::string* to_resource_;
  ::google::protobuf::uint64 to_conn_id_;
  ::std::string* payload_;
  ::google::protobuf::int64 region_bucket_;
  int stream_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static RouterPacket* default_instance_;
};
// -------------------------------------------------------------------

class BurrowPacket : public ::google::protobuf::MessageLite {
 public:
  BurrowPacket();
  virtual ~BurrowPacket();

  BurrowPacket(const BurrowPacket& from);

  inline BurrowPacket& operator=(const BurrowPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const BurrowPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BurrowPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BurrowPacket* other);

  // implements Message ----------------------------------------------

  BurrowPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BurrowPacket& from);
  void MergeFrom(const BurrowPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // required uint64 call_id = 3;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 3;
  inline ::google::protobuf::uint64 call_id() const;
  inline void set_call_id(::google::protobuf::uint64 value);

  // required uint64 burrow_id = 4;
  inline bool has_burrow_id() const;
  inline void clear_burrow_id();
  static const int kBurrowIdFieldNumber = 4;
  inline ::google::protobuf::uint64 burrow_id() const;
  inline void set_burrow_id(::google::protobuf::uint64 value);

  // required .mimc.BURROW_TYPE burrow_type = 5;
  inline bool has_burrow_type() const;
  inline void clear_burrow_type();
  static const int kBurrowTypeFieldNumber = 5;
  inline ::mimc::BURROW_TYPE burrow_type() const;
  inline void set_burrow_type(::mimc::BURROW_TYPE value);

  // @@protoc_insertion_point(class_scope:mimc.BurrowPacket)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_burrow_id();
  inline void clear_has_burrow_id();
  inline void set_has_burrow_type();
  inline void clear_has_burrow_type();

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::uint64 call_id_;
  ::google::protobuf::uint64 burrow_id_;
  int burrow_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_rts_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_rts_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_rts_5fdata_2eproto();
  friend void protobuf_ShutdownFile_rts_5fdata_2eproto();

  void InitAsDefaultInstance();
  static BurrowPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// UserPacket

// optional uint32 version = 1;
inline bool UserPacket::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPacket::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPacket::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPacket::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 UserPacket::version() const {
  return version_;
}
inline void UserPacket::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required .mimc.PKT_TYPE pkt_type = 2;
inline bool UserPacket::has_pkt_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPacket::set_has_pkt_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPacket::clear_has_pkt_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPacket::clear_pkt_type() {
  pkt_type_ = 1;
  clear_has_pkt_type();
}
inline ::mimc::PKT_TYPE UserPacket::pkt_type() const {
  return static_cast< ::mimc::PKT_TYPE >(pkt_type_);
}
inline void UserPacket::set_pkt_type(::mimc::PKT_TYPE value) {
  assert(::mimc::PKT_TYPE_IsValid(value));
  set_has_pkt_type();
  pkt_type_ = value;
}

// required uint64 uuid = 3;
inline bool UserPacket::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPacket::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPacket::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPacket::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 UserPacket::uuid() const {
  return uuid_;
}
inline void UserPacket::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 4;
inline bool UserPacket::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPacket::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPacket::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPacket::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& UserPacket::resource() const {
  return *resource_;
}
inline void UserPacket::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UserPacket::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UserPacket::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPacket::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* UserPacket::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPacket::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 call_id = 5;
inline bool UserPacket::has_call_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPacket::set_has_call_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPacket::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPacket::clear_call_id() {
  call_id_ = GOOGLE_ULONGLONG(0);
  clear_has_call_id();
}
inline ::google::protobuf::uint64 UserPacket::call_id() const {
  return call_id_;
}
inline void UserPacket::set_call_id(::google::protobuf::uint64 value) {
  set_has_call_id();
  call_id_ = value;
}

// optional bytes payload = 6;
inline bool UserPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserPacket::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& UserPacket::payload() const {
  return *payload_;
}
inline void UserPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UserPacket::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UserPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPacket::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* UserPacket::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPacket::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 region_bucket = 7;
inline bool UserPacket::has_region_bucket() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserPacket::set_has_region_bucket() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserPacket::clear_has_region_bucket() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserPacket::clear_region_bucket() {
  region_bucket_ = GOOGLE_LONGLONG(0);
  clear_has_region_bucket();
}
inline ::google::protobuf::int64 UserPacket::region_bucket() const {
  return region_bucket_;
}
inline void UserPacket::set_region_bucket(::google::protobuf::int64 value) {
  set_has_region_bucket();
  region_bucket_ = value;
}

// -------------------------------------------------------------------

// BindRelayRequest

// required uint64 uuid = 1;
inline bool BindRelayRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindRelayRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindRelayRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindRelayRequest::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 BindRelayRequest::uuid() const {
  return uuid_;
}
inline void BindRelayRequest::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool BindRelayRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindRelayRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindRelayRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindRelayRequest::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& BindRelayRequest::resource() const {
  return *resource_;
}
inline void BindRelayRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void BindRelayRequest::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void BindRelayRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BindRelayRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* BindRelayRequest::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BindRelayRequest::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intranet_ip = 3;
inline bool BindRelayRequest::has_intranet_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindRelayRequest::set_has_intranet_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindRelayRequest::clear_has_intranet_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindRelayRequest::clear_intranet_ip() {
  if (intranet_ip_ != &::google::protobuf::internal::kEmptyString) {
    intranet_ip_->clear();
  }
  clear_has_intranet_ip();
}
inline const ::std::string& BindRelayRequest::intranet_ip() const {
  return *intranet_ip_;
}
inline void BindRelayRequest::set_intranet_ip(const ::std::string& value) {
  set_has_intranet_ip();
  if (intranet_ip_ == &::google::protobuf::internal::kEmptyString) {
    intranet_ip_ = new ::std::string;
  }
  intranet_ip_->assign(value);
}
inline void BindRelayRequest::set_intranet_ip(const char* value) {
  set_has_intranet_ip();
  if (intranet_ip_ == &::google::protobuf::internal::kEmptyString) {
    intranet_ip_ = new ::std::string;
  }
  intranet_ip_->assign(value);
}
inline void BindRelayRequest::set_intranet_ip(const char* value, size_t size) {
  set_has_intranet_ip();
  if (intranet_ip_ == &::google::protobuf::internal::kEmptyString) {
    intranet_ip_ = new ::std::string;
  }
  intranet_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BindRelayRequest::mutable_intranet_ip() {
  set_has_intranet_ip();
  if (intranet_ip_ == &::google::protobuf::internal::kEmptyString) {
    intranet_ip_ = new ::std::string;
  }
  return intranet_ip_;
}
inline ::std::string* BindRelayRequest::release_intranet_ip() {
  clear_has_intranet_ip();
  if (intranet_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intranet_ip_;
    intranet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BindRelayRequest::set_allocated_intranet_ip(::std::string* intranet_ip) {
  if (intranet_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete intranet_ip_;
  }
  if (intranet_ip) {
    set_has_intranet_ip();
    intranet_ip_ = intranet_ip;
  } else {
    clear_has_intranet_ip();
    intranet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 intranet_port = 4;
inline bool BindRelayRequest::has_intranet_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindRelayRequest::set_has_intranet_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindRelayRequest::clear_has_intranet_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindRelayRequest::clear_intranet_port() {
  intranet_port_ = 0;
  clear_has_intranet_port();
}
inline ::google::protobuf::int32 BindRelayRequest::intranet_port() const {
  return intranet_port_;
}
inline void BindRelayRequest::set_intranet_port(::google::protobuf::int32 value) {
  set_has_intranet_port();
  intranet_port_ = value;
}

// optional string token = 5;
inline bool BindRelayRequest::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindRelayRequest::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindRelayRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindRelayRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& BindRelayRequest::token() const {
  return *token_;
}
inline void BindRelayRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void BindRelayRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void BindRelayRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BindRelayRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* BindRelayRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BindRelayRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mimc.StreamConfig audio_stream_default_config = 6;
inline bool BindRelayRequest::has_audio_stream_default_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindRelayRequest::set_has_audio_stream_default_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindRelayRequest::clear_has_audio_stream_default_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindRelayRequest::clear_audio_stream_default_config() {
  if (audio_stream_default_config_ != NULL) audio_stream_default_config_->::mimc::StreamConfig::Clear();
  clear_has_audio_stream_default_config();
}
inline const ::mimc::StreamConfig& BindRelayRequest::audio_stream_default_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return audio_stream_default_config_ != NULL ? *audio_stream_default_config_ : *default_instance().audio_stream_default_config_;
#else
  return audio_stream_default_config_ != NULL ? *audio_stream_default_config_ : *default_instance_->audio_stream_default_config_;
#endif
}
inline ::mimc::StreamConfig* BindRelayRequest::mutable_audio_stream_default_config() {
  set_has_audio_stream_default_config();
  if (audio_stream_default_config_ == NULL) audio_stream_default_config_ = new ::mimc::StreamConfig;
  return audio_stream_default_config_;
}
inline ::mimc::StreamConfig* BindRelayRequest::release_audio_stream_default_config() {
  clear_has_audio_stream_default_config();
  ::mimc::StreamConfig* temp = audio_stream_default_config_;
  audio_stream_default_config_ = NULL;
  return temp;
}
inline void BindRelayRequest::set_allocated_audio_stream_default_config(::mimc::StreamConfig* audio_stream_default_config) {
  delete audio_stream_default_config_;
  audio_stream_default_config_ = audio_stream_default_config;
  if (audio_stream_default_config) {
    set_has_audio_stream_default_config();
  } else {
    clear_has_audio_stream_default_config();
  }
}

// optional .mimc.StreamConfig video_stream_default_config = 7;
inline bool BindRelayRequest::has_video_stream_default_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindRelayRequest::set_has_video_stream_default_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindRelayRequest::clear_has_video_stream_default_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindRelayRequest::clear_video_stream_default_config() {
  if (video_stream_default_config_ != NULL) video_stream_default_config_->::mimc::StreamConfig::Clear();
  clear_has_video_stream_default_config();
}
inline const ::mimc::StreamConfig& BindRelayRequest::video_stream_default_config() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return video_stream_default_config_ != NULL ? *video_stream_default_config_ : *default_instance().video_stream_default_config_;
#else
  return video_stream_default_config_ != NULL ? *video_stream_default_config_ : *default_instance_->video_stream_default_config_;
#endif
}
inline ::mimc::StreamConfig* BindRelayRequest::mutable_video_stream_default_config() {
  set_has_video_stream_default_config();
  if (video_stream_default_config_ == NULL) video_stream_default_config_ = new ::mimc::StreamConfig;
  return video_stream_default_config_;
}
inline ::mimc::StreamConfig* BindRelayRequest::release_video_stream_default_config() {
  clear_has_video_stream_default_config();
  ::mimc::StreamConfig* temp = video_stream_default_config_;
  video_stream_default_config_ = NULL;
  return temp;
}
inline void BindRelayRequest::set_allocated_video_stream_default_config(::mimc::StreamConfig* video_stream_default_config) {
  delete video_stream_default_config_;
  video_stream_default_config_ = video_stream_default_config;
  if (video_stream_default_config) {
    set_has_video_stream_default_config();
  } else {
    clear_has_video_stream_default_config();
  }
}

// -------------------------------------------------------------------

// StreamConfig

// required .mimc.STREAM_STRATEGY stream_strategy = 1;
inline bool StreamConfig::has_stream_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamConfig::set_has_stream_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamConfig::clear_has_stream_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamConfig::clear_stream_strategy() {
  stream_strategy_ = 1;
  clear_has_stream_strategy();
}
inline ::mimc::STREAM_STRATEGY StreamConfig::stream_strategy() const {
  return static_cast< ::mimc::STREAM_STRATEGY >(stream_strategy_);
}
inline void StreamConfig::set_stream_strategy(::mimc::STREAM_STRATEGY value) {
  assert(::mimc::STREAM_STRATEGY_IsValid(value));
  set_has_stream_strategy();
  stream_strategy_ = value;
}

// optional uint32 ack_stream_wait_time_ms = 2;
inline bool StreamConfig::has_ack_stream_wait_time_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamConfig::set_has_ack_stream_wait_time_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamConfig::clear_has_ack_stream_wait_time_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamConfig::clear_ack_stream_wait_time_ms() {
  ack_stream_wait_time_ms_ = 0u;
  clear_has_ack_stream_wait_time_ms();
}
inline ::google::protobuf::uint32 StreamConfig::ack_stream_wait_time_ms() const {
  return ack_stream_wait_time_ms_;
}
inline void StreamConfig::set_ack_stream_wait_time_ms(::google::protobuf::uint32 value) {
  set_has_ack_stream_wait_time_ms();
  ack_stream_wait_time_ms_ = value;
}

// optional uint32 stream_timeout_s = 3;
inline bool StreamConfig::has_stream_timeout_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreamConfig::set_has_stream_timeout_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreamConfig::clear_has_stream_timeout_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreamConfig::clear_stream_timeout_s() {
  stream_timeout_s_ = 0u;
  clear_has_stream_timeout_s();
}
inline ::google::protobuf::uint32 StreamConfig::stream_timeout_s() const {
  return stream_timeout_s_;
}
inline void StreamConfig::set_stream_timeout_s(::google::protobuf::uint32 value) {
  set_has_stream_timeout_s();
  stream_timeout_s_ = value;
}

// optional bool stream_is_encrypt = 4;
inline bool StreamConfig::has_stream_is_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StreamConfig::set_has_stream_is_encrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StreamConfig::clear_has_stream_is_encrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StreamConfig::clear_stream_is_encrypt() {
  stream_is_encrypt_ = false;
  clear_has_stream_is_encrypt();
}
inline bool StreamConfig::stream_is_encrypt() const {
  return stream_is_encrypt_;
}
inline void StreamConfig::set_stream_is_encrypt(bool value) {
  set_has_stream_is_encrypt();
  stream_is_encrypt_ = value;
}

// -------------------------------------------------------------------

// BindRelayResponse

// required bool result = 1;
inline bool BindRelayResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindRelayResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindRelayResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindRelayResponse::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool BindRelayResponse::result() const {
  return result_;
}
inline void BindRelayResponse::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required string internet_ip = 2;
inline bool BindRelayResponse::has_internet_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindRelayResponse::set_has_internet_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindRelayResponse::clear_has_internet_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindRelayResponse::clear_internet_ip() {
  if (internet_ip_ != &::google::protobuf::internal::kEmptyString) {
    internet_ip_->clear();
  }
  clear_has_internet_ip();
}
inline const ::std::string& BindRelayResponse::internet_ip() const {
  return *internet_ip_;
}
inline void BindRelayResponse::set_internet_ip(const ::std::string& value) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(value);
}
inline void BindRelayResponse::set_internet_ip(const char* value) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(value);
}
inline void BindRelayResponse::set_internet_ip(const char* value, size_t size) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BindRelayResponse::mutable_internet_ip() {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  return internet_ip_;
}
inline ::std::string* BindRelayResponse::release_internet_ip() {
  clear_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internet_ip_;
    internet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BindRelayResponse::set_allocated_internet_ip(::std::string* internet_ip) {
  if (internet_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete internet_ip_;
  }
  if (internet_ip) {
    set_has_internet_ip();
    internet_ip_ = internet_ip;
  } else {
    clear_has_internet_ip();
    internet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 internet_port = 3;
inline bool BindRelayResponse::has_internet_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindRelayResponse::set_has_internet_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindRelayResponse::clear_has_internet_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindRelayResponse::clear_internet_port() {
  internet_port_ = 0;
  clear_has_internet_port();
}
inline ::google::protobuf::int32 BindRelayResponse::internet_port() const {
  return internet_port_;
}
inline void BindRelayResponse::set_internet_port(::google::protobuf::int32 value) {
  set_has_internet_port();
  internet_port_ = value;
}

// optional string relay_ip = 4;
inline bool BindRelayResponse::has_relay_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindRelayResponse::set_has_relay_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindRelayResponse::clear_has_relay_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindRelayResponse::clear_relay_ip() {
  if (relay_ip_ != &::google::protobuf::internal::kEmptyString) {
    relay_ip_->clear();
  }
  clear_has_relay_ip();
}
inline const ::std::string& BindRelayResponse::relay_ip() const {
  return *relay_ip_;
}
inline void BindRelayResponse::set_relay_ip(const ::std::string& value) {
  set_has_relay_ip();
  if (relay_ip_ == &::google::protobuf::internal::kEmptyString) {
    relay_ip_ = new ::std::string;
  }
  relay_ip_->assign(value);
}
inline void BindRelayResponse::set_relay_ip(const char* value) {
  set_has_relay_ip();
  if (relay_ip_ == &::google::protobuf::internal::kEmptyString) {
    relay_ip_ = new ::std::string;
  }
  relay_ip_->assign(value);
}
inline void BindRelayResponse::set_relay_ip(const char* value, size_t size) {
  set_has_relay_ip();
  if (relay_ip_ == &::google::protobuf::internal::kEmptyString) {
    relay_ip_ = new ::std::string;
  }
  relay_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BindRelayResponse::mutable_relay_ip() {
  set_has_relay_ip();
  if (relay_ip_ == &::google::protobuf::internal::kEmptyString) {
    relay_ip_ = new ::std::string;
  }
  return relay_ip_;
}
inline ::std::string* BindRelayResponse::release_relay_ip() {
  clear_has_relay_ip();
  if (relay_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relay_ip_;
    relay_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BindRelayResponse::set_allocated_relay_ip(::std::string* relay_ip) {
  if (relay_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete relay_ip_;
  }
  if (relay_ip) {
    set_has_relay_ip();
    relay_ip_ = relay_ip;
  } else {
    clear_has_relay_ip();
    relay_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 relay_port = 5;
inline bool BindRelayResponse::has_relay_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindRelayResponse::set_has_relay_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindRelayResponse::clear_has_relay_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindRelayResponse::clear_relay_port() {
  relay_port_ = 0;
  clear_has_relay_port();
}
inline ::google::protobuf::int32 BindRelayResponse::relay_port() const {
  return relay_port_;
}
inline void BindRelayResponse::set_relay_port(::google::protobuf::int32 value) {
  set_has_relay_port();
  relay_port_ = value;
}

// optional uint32 errorno = 6;
inline bool BindRelayResponse::has_errorno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindRelayResponse::set_has_errorno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindRelayResponse::clear_has_errorno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindRelayResponse::clear_errorno() {
  errorno_ = 0u;
  clear_has_errorno();
}
inline ::google::protobuf::uint32 BindRelayResponse::errorno() const {
  return errorno_;
}
inline void BindRelayResponse::set_errorno(::google::protobuf::uint32 value) {
  set_has_errorno();
  errorno_ = value;
}

// -------------------------------------------------------------------

// PingRelayRequest

// required uint64 uuid = 1;
inline bool PingRelayRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingRelayRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingRelayRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingRelayRequest::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 PingRelayRequest::uuid() const {
  return uuid_;
}
inline void PingRelayRequest::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool PingRelayRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingRelayRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingRelayRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingRelayRequest::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& PingRelayRequest::resource() const {
  return *resource_;
}
inline void PingRelayRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PingRelayRequest::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PingRelayRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingRelayRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* PingRelayRequest::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PingRelayRequest::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PingRelayResponse

// required bool result = 1;
inline bool PingRelayResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingRelayResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingRelayResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingRelayResponse::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool PingRelayResponse::result() const {
  return result_;
}
inline void PingRelayResponse::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required string internet_ip = 2;
inline bool PingRelayResponse::has_internet_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingRelayResponse::set_has_internet_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingRelayResponse::clear_has_internet_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingRelayResponse::clear_internet_ip() {
  if (internet_ip_ != &::google::protobuf::internal::kEmptyString) {
    internet_ip_->clear();
  }
  clear_has_internet_ip();
}
inline const ::std::string& PingRelayResponse::internet_ip() const {
  return *internet_ip_;
}
inline void PingRelayResponse::set_internet_ip(const ::std::string& value) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(value);
}
inline void PingRelayResponse::set_internet_ip(const char* value) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(value);
}
inline void PingRelayResponse::set_internet_ip(const char* value, size_t size) {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  internet_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingRelayResponse::mutable_internet_ip() {
  set_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    internet_ip_ = new ::std::string;
  }
  return internet_ip_;
}
inline ::std::string* PingRelayResponse::release_internet_ip() {
  clear_has_internet_ip();
  if (internet_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internet_ip_;
    internet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PingRelayResponse::set_allocated_internet_ip(::std::string* internet_ip) {
  if (internet_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete internet_ip_;
  }
  if (internet_ip) {
    set_has_internet_ip();
    internet_ip_ = internet_ip;
  } else {
    clear_has_internet_ip();
    internet_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 internet_port = 3;
inline bool PingRelayResponse::has_internet_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PingRelayResponse::set_has_internet_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PingRelayResponse::clear_has_internet_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PingRelayResponse::clear_internet_port() {
  internet_port_ = 0;
  clear_has_internet_port();
}
inline ::google::protobuf::int32 PingRelayResponse::internet_port() const {
  return internet_port_;
}
inline void PingRelayResponse::set_internet_port(::google::protobuf::int32 value) {
  set_has_internet_port();
  internet_port_ = value;
}

// optional uint32 errorno = 4;
inline bool PingRelayResponse::has_errorno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PingRelayResponse::set_has_errorno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PingRelayResponse::clear_has_errorno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PingRelayResponse::clear_errorno() {
  errorno_ = 0u;
  clear_has_errorno();
}
inline ::google::protobuf::uint32 PingRelayResponse::errorno() const {
  return errorno_;
}
inline void PingRelayResponse::set_errorno(::google::protobuf::uint32 value) {
  set_has_errorno();
  errorno_ = value;
}

// -------------------------------------------------------------------

// UnBindRelayRequest

// required uint64 uuid = 1;
inline bool UnBindRelayRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindRelayRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindRelayRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindRelayRequest::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 UnBindRelayRequest::uuid() const {
  return uuid_;
}
inline void UnBindRelayRequest::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool UnBindRelayRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnBindRelayRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnBindRelayRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnBindRelayRequest::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& UnBindRelayRequest::resource() const {
  return *resource_;
}
inline void UnBindRelayRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UnBindRelayRequest::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void UnBindRelayRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnBindRelayRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* UnBindRelayRequest::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnBindRelayRequest::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 3;
inline bool UnBindRelayRequest::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnBindRelayRequest::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnBindRelayRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnBindRelayRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UnBindRelayRequest::token() const {
  return *token_;
}
inline void UnBindRelayRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UnBindRelayRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UnBindRelayRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnBindRelayRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UnBindRelayRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnBindRelayRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnBindRelayResponse

// required bool is_ok = 1;
inline bool UnBindRelayResponse::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindRelayResponse::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindRelayResponse::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindRelayResponse::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool UnBindRelayResponse::is_ok() const {
  return is_ok_;
}
inline void UnBindRelayResponse::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// -------------------------------------------------------------------

// RelayKickRequest

// required .mimc.KICK_REASON reason = 1;
inline bool RelayKickRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelayKickRequest::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelayKickRequest::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelayKickRequest::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::mimc::KICK_REASON RelayKickRequest::reason() const {
  return static_cast< ::mimc::KICK_REASON >(reason_);
}
inline void RelayKickRequest::set_reason(::mimc::KICK_REASON value) {
  assert(::mimc::KICK_REASON_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// RelayKickResponse

// required bool is_ok = 1;
inline bool RelayKickResponse::has_is_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelayKickResponse::set_has_is_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelayKickResponse::clear_has_is_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelayKickResponse::clear_is_ok() {
  is_ok_ = false;
  clear_has_is_ok();
}
inline bool RelayKickResponse::is_ok() const {
  return is_ok_;
}
inline void RelayKickResponse::set_is_ok(bool value) {
  set_has_is_ok();
  is_ok_ = value;
}

// -------------------------------------------------------------------

// RouterPacket

// required uint64 call_id = 1;
inline bool RouterPacket::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouterPacket::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouterPacket::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouterPacket::clear_call_id() {
  call_id_ = GOOGLE_ULONGLONG(0);
  clear_has_call_id();
}
inline ::google::protobuf::uint64 RouterPacket::call_id() const {
  return call_id_;
}
inline void RouterPacket::set_call_id(::google::protobuf::uint64 value) {
  set_has_call_id();
  call_id_ = value;
}

// optional uint64 from_uuid = 2;
inline bool RouterPacket::has_from_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouterPacket::set_has_from_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouterPacket::clear_has_from_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouterPacket::clear_from_uuid() {
  from_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_from_uuid();
}
inline ::google::protobuf::uint64 RouterPacket::from_uuid() const {
  return from_uuid_;
}
inline void RouterPacket::set_from_uuid(::google::protobuf::uint64 value) {
  set_has_from_uuid();
  from_uuid_ = value;
}

// optional string from_resource = 3;
inline bool RouterPacket::has_from_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouterPacket::set_has_from_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouterPacket::clear_has_from_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouterPacket::clear_from_resource() {
  if (from_resource_ != &::google::protobuf::internal::kEmptyString) {
    from_resource_->clear();
  }
  clear_has_from_resource();
}
inline const ::std::string& RouterPacket::from_resource() const {
  return *from_resource_;
}
inline void RouterPacket::set_from_resource(const ::std::string& value) {
  set_has_from_resource();
  if (from_resource_ == &::google::protobuf::internal::kEmptyString) {
    from_resource_ = new ::std::string;
  }
  from_resource_->assign(value);
}
inline void RouterPacket::set_from_resource(const char* value) {
  set_has_from_resource();
  if (from_resource_ == &::google::protobuf::internal::kEmptyString) {
    from_resource_ = new ::std::string;
  }
  from_resource_->assign(value);
}
inline void RouterPacket::set_from_resource(const char* value, size_t size) {
  set_has_from_resource();
  if (from_resource_ == &::google::protobuf::internal::kEmptyString) {
    from_resource_ = new ::std::string;
  }
  from_resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouterPacket::mutable_from_resource() {
  set_has_from_resource();
  if (from_resource_ == &::google::protobuf::internal::kEmptyString) {
    from_resource_ = new ::std::string;
  }
  return from_resource_;
}
inline ::std::string* RouterPacket::release_from_resource() {
  clear_has_from_resource();
  if (from_resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_resource_;
    from_resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouterPacket::set_allocated_from_resource(::std::string* from_resource) {
  if (from_resource_ != &::google::protobuf::internal::kEmptyString) {
    delete from_resource_;
  }
  if (from_resource) {
    set_has_from_resource();
    from_resource_ = from_resource;
  } else {
    clear_has_from_resource();
    from_resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 to_uuid = 4;
inline bool RouterPacket::has_to_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouterPacket::set_has_to_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouterPacket::clear_has_to_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouterPacket::clear_to_uuid() {
  to_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_to_uuid();
}
inline ::google::protobuf::uint64 RouterPacket::to_uuid() const {
  return to_uuid_;
}
inline void RouterPacket::set_to_uuid(::google::protobuf::uint64 value) {
  set_has_to_uuid();
  to_uuid_ = value;
}

// optional string to_resource = 5;
inline bool RouterPacket::has_to_resource() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouterPacket::set_has_to_resource() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouterPacket::clear_has_to_resource() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouterPacket::clear_to_resource() {
  if (to_resource_ != &::google::protobuf::internal::kEmptyString) {
    to_resource_->clear();
  }
  clear_has_to_resource();
}
inline const ::std::string& RouterPacket::to_resource() const {
  return *to_resource_;
}
inline void RouterPacket::set_to_resource(const ::std::string& value) {
  set_has_to_resource();
  if (to_resource_ == &::google::protobuf::internal::kEmptyString) {
    to_resource_ = new ::std::string;
  }
  to_resource_->assign(value);
}
inline void RouterPacket::set_to_resource(const char* value) {
  set_has_to_resource();
  if (to_resource_ == &::google::protobuf::internal::kEmptyString) {
    to_resource_ = new ::std::string;
  }
  to_resource_->assign(value);
}
inline void RouterPacket::set_to_resource(const char* value, size_t size) {
  set_has_to_resource();
  if (to_resource_ == &::google::protobuf::internal::kEmptyString) {
    to_resource_ = new ::std::string;
  }
  to_resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouterPacket::mutable_to_resource() {
  set_has_to_resource();
  if (to_resource_ == &::google::protobuf::internal::kEmptyString) {
    to_resource_ = new ::std::string;
  }
  return to_resource_;
}
inline ::std::string* RouterPacket::release_to_resource() {
  clear_has_to_resource();
  if (to_resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_resource_;
    to_resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouterPacket::set_allocated_to_resource(::std::string* to_resource) {
  if (to_resource_ != &::google::protobuf::internal::kEmptyString) {
    delete to_resource_;
  }
  if (to_resource) {
    set_has_to_resource();
    to_resource_ = to_resource;
  } else {
    clear_has_to_resource();
    to_resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 to_conn_id = 6;
inline bool RouterPacket::has_to_conn_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouterPacket::set_has_to_conn_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouterPacket::clear_has_to_conn_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouterPacket::clear_to_conn_id() {
  to_conn_id_ = GOOGLE_ULONGLONG(0);
  clear_has_to_conn_id();
}
inline ::google::protobuf::uint64 RouterPacket::to_conn_id() const {
  return to_conn_id_;
}
inline void RouterPacket::set_to_conn_id(::google::protobuf::uint64 value) {
  set_has_to_conn_id();
  to_conn_id_ = value;
}

// optional .mimc.STREAM_TYPE stream_type = 7;
inline bool RouterPacket::has_stream_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RouterPacket::set_has_stream_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RouterPacket::clear_has_stream_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RouterPacket::clear_stream_type() {
  stream_type_ = 1;
  clear_has_stream_type();
}
inline ::mimc::STREAM_TYPE RouterPacket::stream_type() const {
  return static_cast< ::mimc::STREAM_TYPE >(stream_type_);
}
inline void RouterPacket::set_stream_type(::mimc::STREAM_TYPE value) {
  assert(::mimc::STREAM_TYPE_IsValid(value));
  set_has_stream_type();
  stream_type_ = value;
}

// optional bytes payload = 8;
inline bool RouterPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RouterPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RouterPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RouterPacket::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& RouterPacket::payload() const {
  return *payload_;
}
inline void RouterPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void RouterPacket::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void RouterPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouterPacket::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* RouterPacket::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouterPacket::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 region_bucket = 9;
inline bool RouterPacket::has_region_bucket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RouterPacket::set_has_region_bucket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RouterPacket::clear_has_region_bucket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RouterPacket::clear_region_bucket() {
  region_bucket_ = GOOGLE_LONGLONG(0);
  clear_has_region_bucket();
}
inline ::google::protobuf::int64 RouterPacket::region_bucket() const {
  return region_bucket_;
}
inline void RouterPacket::set_region_bucket(::google::protobuf::int64 value) {
  set_has_region_bucket();
  region_bucket_ = value;
}

// -------------------------------------------------------------------

// BurrowPacket

// required uint64 uuid = 1;
inline bool BurrowPacket::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BurrowPacket::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BurrowPacket::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BurrowPacket::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 BurrowPacket::uuid() const {
  return uuid_;
}
inline void BurrowPacket::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool BurrowPacket::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BurrowPacket::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BurrowPacket::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BurrowPacket::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& BurrowPacket::resource() const {
  return *resource_;
}
inline void BurrowPacket::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void BurrowPacket::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void BurrowPacket::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BurrowPacket::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* BurrowPacket::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BurrowPacket::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 call_id = 3;
inline bool BurrowPacket::has_call_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BurrowPacket::set_has_call_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BurrowPacket::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BurrowPacket::clear_call_id() {
  call_id_ = GOOGLE_ULONGLONG(0);
  clear_has_call_id();
}
inline ::google::protobuf::uint64 BurrowPacket::call_id() const {
  return call_id_;
}
inline void BurrowPacket::set_call_id(::google::protobuf::uint64 value) {
  set_has_call_id();
  call_id_ = value;
}

// required uint64 burrow_id = 4;
inline bool BurrowPacket::has_burrow_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BurrowPacket::set_has_burrow_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BurrowPacket::clear_has_burrow_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BurrowPacket::clear_burrow_id() {
  burrow_id_ = GOOGLE_ULONGLONG(0);
  clear_has_burrow_id();
}
inline ::google::protobuf::uint64 BurrowPacket::burrow_id() const {
  return burrow_id_;
}
inline void BurrowPacket::set_burrow_id(::google::protobuf::uint64 value) {
  set_has_burrow_id();
  burrow_id_ = value;
}

// required .mimc.BURROW_TYPE burrow_type = 5;
inline bool BurrowPacket::has_burrow_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BurrowPacket::set_has_burrow_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BurrowPacket::clear_has_burrow_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BurrowPacket::clear_burrow_type() {
  burrow_type_ = 1;
  clear_has_burrow_type();
}
inline ::mimc::BURROW_TYPE BurrowPacket::burrow_type() const {
  return static_cast< ::mimc::BURROW_TYPE >(burrow_type_);
}
inline void BurrowPacket::set_burrow_type(::mimc::BURROW_TYPE value) {
  assert(::mimc::BURROW_TYPE_IsValid(value));
  set_has_burrow_type();
  burrow_type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rts_5fdata_2eproto__INCLUDED
