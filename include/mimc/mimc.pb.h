// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mimc.proto

#ifndef PROTOBUF_mimc_2eproto__INCLUDED
#define PROTOBUF_mimc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mimc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mimc_2eproto();
void protobuf_AssignDesc_mimc_2eproto();
void protobuf_ShutdownFile_mimc_2eproto();

class FilterRequest;
class FilterResponse;
class PullMessageRequest;
class TopicMessage;
class QueryAppinfoRequest;
class Appinfo;
class MIMCPacket;
class MIMCPacketList;
class MIMCPacketAck;
class MIMCP2PMessage;
class MIMCP2TMessage;
class MIMCSequenceAck;
class MIMCPull;
class P2PPushMesage;
class P2TPushMesage;
class MIMCUser;
class MIMCGroup;
class UCGroup;
class UCPacket;
class UCExchange;
class UCJoin;
class UCJoinResp;
class UCQuit;
class UCQuitResp;
class UCPing;
class UCMessage;
class UCPushMessage;
class UCMessageList;
class UCSequenceAck;
class UCDismiss;
class UCQueryOnlineUsers;
class UCQueryOnlineUsersResp;
class FeInfo;

enum ErrorCode {
  OK = 0,
  INTERNAL_ERROR = 1
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = OK;
const ErrorCode ErrorCode_MAX = INTERNAL_ERROR;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

enum MIMC_MSG_TYPE {
  P2P_MESSAGE = 1,
  P2T_MESSAGE = 2,
  SEQUENCE_ACK = 3,
  PACKET_ACK = 4,
  PULL = 5,
  COMPOUND = 6,
  RTS_SIGNAL = 7,
  UC_PACKET = 8,
  P2P_PUSH_MESSAGE = 9,
  P2T_PUSH_MESSAGE = 10
};
bool MIMC_MSG_TYPE_IsValid(int value);
const MIMC_MSG_TYPE MIMC_MSG_TYPE_MIN = P2P_MESSAGE;
const MIMC_MSG_TYPE MIMC_MSG_TYPE_MAX = P2T_PUSH_MESSAGE;
const int MIMC_MSG_TYPE_ARRAYSIZE = MIMC_MSG_TYPE_MAX + 1;

enum UC_MSG_TYPE {
  PING = 1,
  PONG = 2,
  JOIN = 3,
  JOIN_RESP = 4,
  QUIT = 5,
  QUIT_RESP = 6,
  SEQ_ACK = 7,
  MESSAGE = 8,
  MESSAGE_LIST = 9,
  DISMISS = 10,
  QUERY_ONLINE_USERS = 11,
  QUERY_ONLINE_USERS_RESP = 12
};
bool UC_MSG_TYPE_IsValid(int value);
const UC_MSG_TYPE UC_MSG_TYPE_MIN = PING;
const UC_MSG_TYPE UC_MSG_TYPE_MAX = QUERY_ONLINE_USERS_RESP;
const int UC_MSG_TYPE_ARRAYSIZE = UC_MSG_TYPE_MAX + 1;

// ===================================================================

class FilterRequest : public ::google::protobuf::MessageLite {
 public:
  FilterRequest();
  virtual ~FilterRequest();

  FilterRequest(const FilterRequest& from);

  inline FilterRequest& operator=(const FilterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const FilterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FilterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FilterRequest* other);

  // implements Message ----------------------------------------------

  FilterRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FilterRequest& from);
  void MergeFrom(const FilterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .mimc.MIMCPacket packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::mimc::MIMCPacket& packet() const;
  inline ::mimc::MIMCPacket* mutable_packet();
  inline ::mimc::MIMCPacket* release_packet();
  inline void set_allocated_packet(::mimc::MIMCPacket* packet);

  // @@protoc_insertion_point(class_scope:mimc.FilterRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_packet();
  inline void clear_has_packet();

  ::std::string* id_;
  ::mimc::MIMCPacket* packet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static FilterRequest* default_instance_;
};
// -------------------------------------------------------------------

class FilterResponse : public ::google::protobuf::MessageLite {
 public:
  FilterResponse();
  virtual ~FilterResponse();

  FilterResponse(const FilterResponse& from);

  inline FilterResponse& operator=(const FilterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const FilterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FilterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FilterResponse* other);

  // implements Message ----------------------------------------------

  FilterResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FilterResponse& from);
  void MergeFrom(const FilterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .mimc.MIMC_MSG_TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mimc::MIMC_MSG_TYPE type() const;
  inline void set_type(::mimc::MIMC_MSG_TYPE value);

  // optional .mimc.ErrorCode errorCode = 3;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 3;
  inline ::mimc::ErrorCode errorcode() const;
  inline void set_errorcode(::mimc::ErrorCode value);

  // optional bool isFilter = 4;
  inline bool has_isfilter() const;
  inline void clear_isfilter();
  static const int kIsFilterFieldNumber = 4;
  inline bool isfilter() const;
  inline void set_isfilter(bool value);

  // @@protoc_insertion_point(class_scope:mimc.FilterResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_isfilter();
  inline void clear_has_isfilter();

  ::std::string* id_;
  int type_;
  int errorcode_;
  bool isfilter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static FilterResponse* default_instance_;
};
// -------------------------------------------------------------------

class PullMessageRequest : public ::google::protobuf::MessageLite {
 public:
  PullMessageRequest();
  virtual ~PullMessageRequest();

  PullMessageRequest(const PullMessageRequest& from);

  inline PullMessageRequest& operator=(const PullMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PullMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PullMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PullMessageRequest* other);

  // implements Message ----------------------------------------------

  PullMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PullMessageRequest& from);
  void MergeFrom(const PullMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::uint64 uuid() const;
  inline void set_uuid(::google::protobuf::uint64 value);

  // required string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.PullMessageRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::uint64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static PullMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class TopicMessage : public ::google::protobuf::MessageLite {
 public:
  TopicMessage();
  virtual ~TopicMessage();

  TopicMessage(const TopicMessage& from);

  inline TopicMessage& operator=(const TopicMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopicMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopicMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopicMessage* other);

  // implements Message ----------------------------------------------

  TopicMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopicMessage& from);
  void MergeFrom(const TopicMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 topicId = 1;
  inline bool has_topicid() const;
  inline void clear_topicid();
  static const int kTopicIdFieldNumber = 1;
  inline ::google::protobuf::uint64 topicid() const;
  inline void set_topicid(::google::protobuf::uint64 value);

  // required .mimc.MIMCPacket packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::mimc::MIMCPacket& packet() const;
  inline ::mimc::MIMCPacket* mutable_packet();
  inline ::mimc::MIMCPacket* release_packet();
  inline void set_allocated_packet(::mimc::MIMCPacket* packet);

  // optional int64 uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.TopicMessage)
 private:
  inline void set_has_topicid();
  inline void clear_has_topicid();
  inline void set_has_packet();
  inline void clear_has_packet();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::uint64 topicid_;
  ::mimc::MIMCPacket* packet_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static TopicMessage* default_instance_;
};
// -------------------------------------------------------------------

class QueryAppinfoRequest : public ::google::protobuf::MessageLite {
 public:
  QueryAppinfoRequest();
  virtual ~QueryAppinfoRequest();

  QueryAppinfoRequest(const QueryAppinfoRequest& from);

  inline QueryAppinfoRequest& operator=(const QueryAppinfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryAppinfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryAppinfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryAppinfoRequest* other);

  // implements Message ----------------------------------------------

  QueryAppinfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryAppinfoRequest& from);
  void MergeFrom(const QueryAppinfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint64 appid() const;
  inline void set_appid(::google::protobuf::uint64 value);

  // optional string context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // @@protoc_insertion_point(class_scope:mimc.QueryAppinfoRequest)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_context();
  inline void clear_has_context();

  ::google::protobuf::uint64 appid_;
  ::std::string* context_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static QueryAppinfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class Appinfo : public ::google::protobuf::MessageLite {
 public:
  Appinfo();
  virtual ~Appinfo();

  Appinfo(const Appinfo& from);

  inline Appinfo& operator=(const Appinfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const Appinfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Appinfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Appinfo* other);

  // implements Message ----------------------------------------------

  Appinfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Appinfo& from);
  void MergeFrom(const Appinfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::uint64 appid() const;
  inline void set_appid(::google::protobuf::uint64 value);

  // optional string msgCallbackUrl = 2;
  inline bool has_msgcallbackurl() const;
  inline void clear_msgcallbackurl();
  static const int kMsgCallbackUrlFieldNumber = 2;
  inline const ::std::string& msgcallbackurl() const;
  inline void set_msgcallbackurl(const ::std::string& value);
  inline void set_msgcallbackurl(const char* value);
  inline void set_msgcallbackurl(const char* value, size_t size);
  inline ::std::string* mutable_msgcallbackurl();
  inline ::std::string* release_msgcallbackurl();
  inline void set_allocated_msgcallbackurl(::std::string* msgcallbackurl);

  // optional string offlineMsgCallbackUrl = 3;
  inline bool has_offlinemsgcallbackurl() const;
  inline void clear_offlinemsgcallbackurl();
  static const int kOfflineMsgCallbackUrlFieldNumber = 3;
  inline const ::std::string& offlinemsgcallbackurl() const;
  inline void set_offlinemsgcallbackurl(const ::std::string& value);
  inline void set_offlinemsgcallbackurl(const char* value);
  inline void set_offlinemsgcallbackurl(const char* value, size_t size);
  inline ::std::string* mutable_offlinemsgcallbackurl();
  inline ::std::string* release_offlinemsgcallbackurl();
  inline void set_allocated_offlinemsgcallbackurl(::std::string* offlinemsgcallbackurl);

  // optional uint64 uuidTTL = 4;
  inline bool has_uuidttl() const;
  inline void clear_uuidttl();
  static const int kUuidTTLFieldNumber = 4;
  inline ::google::protobuf::uint64 uuidttl() const;
  inline void set_uuidttl(::google::protobuf::uint64 value);

  // optional string context = 5;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 5;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const char* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // optional string messageFilter = 6;
  inline bool has_messagefilter() const;
  inline void clear_messagefilter();
  static const int kMessageFilterFieldNumber = 6;
  inline const ::std::string& messagefilter() const;
  inline void set_messagefilter(const ::std::string& value);
  inline void set_messagefilter(const char* value);
  inline void set_messagefilter(const char* value, size_t size);
  inline ::std::string* mutable_messagefilter();
  inline ::std::string* release_messagefilter();
  inline void set_allocated_messagefilter(::std::string* messagefilter);

  // optional string ucMsgCallbackUrl = 7;
  inline bool has_ucmsgcallbackurl() const;
  inline void clear_ucmsgcallbackurl();
  static const int kUcMsgCallbackUrlFieldNumber = 7;
  inline const ::std::string& ucmsgcallbackurl() const;
  inline void set_ucmsgcallbackurl(const ::std::string& value);
  inline void set_ucmsgcallbackurl(const char* value);
  inline void set_ucmsgcallbackurl(const char* value, size_t size);
  inline ::std::string* mutable_ucmsgcallbackurl();
  inline ::std::string* release_ucmsgcallbackurl();
  inline void set_allocated_ucmsgcallbackurl(::std::string* ucmsgcallbackurl);

  // @@protoc_insertion_point(class_scope:mimc.Appinfo)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_msgcallbackurl();
  inline void clear_has_msgcallbackurl();
  inline void set_has_offlinemsgcallbackurl();
  inline void clear_has_offlinemsgcallbackurl();
  inline void set_has_uuidttl();
  inline void clear_has_uuidttl();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_messagefilter();
  inline void clear_has_messagefilter();
  inline void set_has_ucmsgcallbackurl();
  inline void clear_has_ucmsgcallbackurl();

  ::google::protobuf::uint64 appid_;
  ::std::string* msgcallbackurl_;
  ::std::string* offlinemsgcallbackurl_;
  ::google::protobuf::uint64 uuidttl_;
  ::std::string* context_;
  ::std::string* messagefilter_;
  ::std::string* ucmsgcallbackurl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static Appinfo* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacket : public ::google::protobuf::MessageLite {
 public:
  MIMCPacket();
  virtual ~MIMCPacket();

  MIMCPacket(const MIMCPacket& from);

  inline MIMCPacket& operator=(const MIMCPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCPacket* other);

  // implements Message ----------------------------------------------

  MIMCPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCPacket& from);
  void MergeFrom(const MIMCPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string packetId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional int64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional .mimc.MIMC_MSG_TYPE type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::mimc::MIMC_MSG_TYPE type() const;
  inline void set_type(::mimc::MIMC_MSG_TYPE value);

  // optional bytes payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacket)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::std::string* packetid_;
  ::std::string* package_;
  ::google::protobuf::int64 sequence_;
  ::std::string* payload_;
  ::google::protobuf::int64 timestamp_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacket* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacketList : public ::google::protobuf::MessageLite {
 public:
  MIMCPacketList();
  virtual ~MIMCPacketList();

  MIMCPacketList(const MIMCPacketList& from);

  inline MIMCPacketList& operator=(const MIMCPacketList& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCPacketList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCPacketList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCPacketList* other);

  // implements Message ----------------------------------------------

  MIMCPacketList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCPacketList& from);
  void MergeFrom(const MIMCPacketList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 maxSequence = 3;
  inline bool has_maxsequence() const;
  inline void clear_maxsequence();
  static const int kMaxSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 maxsequence() const;
  inline void set_maxsequence(::google::protobuf::int64 value);

  // repeated .mimc.MIMCPacket packets = 4;
  inline int packets_size() const;
  inline void clear_packets();
  static const int kPacketsFieldNumber = 4;
  inline const ::mimc::MIMCPacket& packets(int index) const;
  inline ::mimc::MIMCPacket* mutable_packets(int index);
  inline ::mimc::MIMCPacket* add_packets();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >&
      packets() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >*
      mutable_packets();

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacketList)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_maxsequence();
  inline void clear_has_maxsequence();

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 maxsequence_;
  ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket > packets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacketList* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPacketAck : public ::google::protobuf::MessageLite {
 public:
  MIMCPacketAck();
  virtual ~MIMCPacketAck();

  MIMCPacketAck(const MIMCPacketAck& from);

  inline MIMCPacketAck& operator=(const MIMCPacketAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCPacketAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCPacketAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCPacketAck* other);

  // implements Message ----------------------------------------------

  MIMCPacketAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCPacketAck& from);
  void MergeFrom(const MIMCPacketAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string packetId = 1;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // optional int64 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 sequence = 4;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string package = 6;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 6;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional string errorMsg = 7;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 7;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  inline void set_allocated_errormsg(::std::string* errormsg);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPacketAck)
 private:
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();

  ::std::string* packetid_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* package_;
  ::std::string* errormsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPacketAck* default_instance_;
};
// -------------------------------------------------------------------

class MIMCP2PMessage : public ::google::protobuf::MessageLite {
 public:
  MIMCP2PMessage();
  virtual ~MIMCP2PMessage();

  MIMCP2PMessage(const MIMCP2PMessage& from);

  inline MIMCP2PMessage& operator=(const MIMCP2PMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCP2PMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCP2PMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCP2PMessage* other);

  // implements Message ----------------------------------------------

  MIMCP2PMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCP2PMessage& from);
  void MergeFrom(const MIMCP2PMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // optional .mimc.MIMCUser to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCUser& to() const;
  inline ::mimc::MIMCUser* mutable_to();
  inline ::mimc::MIMCUser* release_to();
  inline void set_allocated_to(::mimc::MIMCUser* to);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // optional bytes bizType = 5;
  inline bool has_biztype() const;
  inline void clear_biztype();
  static const int kBizTypeFieldNumber = 5;
  inline const ::std::string& biztype() const;
  inline void set_biztype(const ::std::string& value);
  inline void set_biztype(const char* value);
  inline void set_biztype(const void* value, size_t size);
  inline ::std::string* mutable_biztype();
  inline ::std::string* release_biztype();
  inline void set_allocated_biztype(::std::string* biztype);

  // @@protoc_insertion_point(class_scope:mimc.MIMCP2PMessage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();
  inline void set_has_biztype();
  inline void clear_has_biztype();

  ::mimc::MIMCUser* from_;
  ::mimc::MIMCUser* to_;
  ::std::string* payload_;
  ::std::string* biztype_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCP2PMessage* default_instance_;
};
// -------------------------------------------------------------------

class MIMCP2TMessage : public ::google::protobuf::MessageLite {
 public:
  MIMCP2TMessage();
  virtual ~MIMCP2TMessage();

  MIMCP2TMessage(const MIMCP2TMessage& from);

  inline MIMCP2TMessage& operator=(const MIMCP2TMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCP2TMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCP2TMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCP2TMessage* other);

  // implements Message ----------------------------------------------

  MIMCP2TMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCP2TMessage& from);
  void MergeFrom(const MIMCP2TMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // optional .mimc.MIMCGroup to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCGroup& to() const;
  inline ::mimc::MIMCGroup* mutable_to();
  inline ::mimc::MIMCGroup* release_to();
  inline void set_allocated_to(::mimc::MIMCGroup* to);

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // optional bytes bizType = 5;
  inline bool has_biztype() const;
  inline void clear_biztype();
  static const int kBizTypeFieldNumber = 5;
  inline const ::std::string& biztype() const;
  inline void set_biztype(const ::std::string& value);
  inline void set_biztype(const char* value);
  inline void set_biztype(const void* value, size_t size);
  inline ::std::string* mutable_biztype();
  inline ::std::string* release_biztype();
  inline void set_allocated_biztype(::std::string* biztype);

  // @@protoc_insertion_point(class_scope:mimc.MIMCP2TMessage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();
  inline void set_has_biztype();
  inline void clear_has_biztype();

  ::mimc::MIMCUser* from_;
  ::mimc::MIMCGroup* to_;
  ::std::string* payload_;
  ::std::string* biztype_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCP2TMessage* default_instance_;
};
// -------------------------------------------------------------------

class MIMCSequenceAck : public ::google::protobuf::MessageLite {
 public:
  MIMCSequenceAck();
  virtual ~MIMCSequenceAck();

  MIMCSequenceAck(const MIMCSequenceAck& from);

  inline MIMCSequenceAck& operator=(const MIMCSequenceAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCSequenceAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCSequenceAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCSequenceAck* other);

  // implements Message ----------------------------------------------

  MIMCSequenceAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCSequenceAck& from);
  void MergeFrom(const MIMCSequenceAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCSequenceAck)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;
  ::google::protobuf::int64 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCSequenceAck* default_instance_;
};
// -------------------------------------------------------------------

class MIMCPull : public ::google::protobuf::MessageLite {
 public:
  MIMCPull();
  virtual ~MIMCPull();

  MIMCPull(const MIMCPull& from);

  inline MIMCPull& operator=(const MIMCPull& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCPull& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCPull* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCPull* other);

  // implements Message ----------------------------------------------

  MIMCPull* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCPull& from);
  void MergeFrom(const MIMCPull& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.MIMCPull)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCPull* default_instance_;
};
// -------------------------------------------------------------------

class P2PPushMesage : public ::google::protobuf::MessageLite {
 public:
  P2PPushMesage();
  virtual ~P2PPushMesage();

  P2PPushMesage(const P2PPushMesage& from);

  inline P2PPushMesage& operator=(const P2PPushMesage& from) {
    CopyFrom(from);
    return *this;
  }

  static const P2PPushMesage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const P2PPushMesage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(P2PPushMesage* other);

  // implements Message ----------------------------------------------

  P2PPushMesage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const P2PPushMesage& from);
  void MergeFrom(const P2PPushMesage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // repeated .mimc.MIMCUser to = 2;
  inline int to_size() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCUser& to(int index) const;
  inline ::mimc::MIMCUser* mutable_to(int index);
  inline ::mimc::MIMCUser* add_to();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCUser >&
      to() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCUser >*
      mutable_to();

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // @@protoc_insertion_point(class_scope:mimc.P2PPushMesage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();

  ::mimc::MIMCUser* from_;
  ::google::protobuf::RepeatedPtrField< ::mimc::MIMCUser > to_;
  ::std::string* payload_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static P2PPushMesage* default_instance_;
};
// -------------------------------------------------------------------

class P2TPushMesage : public ::google::protobuf::MessageLite {
 public:
  P2TPushMesage();
  virtual ~P2TPushMesage();

  P2TPushMesage(const P2TPushMesage& from);

  inline P2TPushMesage& operator=(const P2TPushMesage& from) {
    CopyFrom(from);
    return *this;
  }

  static const P2TPushMesage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const P2TPushMesage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(P2TPushMesage* other);

  // implements Message ----------------------------------------------

  P2TPushMesage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const P2TPushMesage& from);
  void MergeFrom(const P2TPushMesage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.MIMCUser from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::mimc::MIMCUser& from() const;
  inline ::mimc::MIMCUser* mutable_from();
  inline ::mimc::MIMCUser* release_from();
  inline void set_allocated_from(::mimc::MIMCUser* from);

  // repeated .mimc.MIMCGroup to = 2;
  inline int to_size() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::mimc::MIMCGroup& to(int index) const;
  inline ::mimc::MIMCGroup* mutable_to(int index);
  inline ::mimc::MIMCGroup* add_to();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCGroup >&
      to() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCGroup >*
      mutable_to();

  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // @@protoc_insertion_point(class_scope:mimc.P2TPushMesage)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_isstore();
  inline void clear_has_isstore();

  ::mimc::MIMCUser* from_;
  ::google::protobuf::RepeatedPtrField< ::mimc::MIMCGroup > to_;
  ::std::string* payload_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static P2TPushMesage* default_instance_;
};
// -------------------------------------------------------------------

class MIMCUser : public ::google::protobuf::MessageLite {
 public:
  MIMCUser();
  virtual ~MIMCUser();

  MIMCUser(const MIMCUser& from);

  inline MIMCUser& operator=(const MIMCUser& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCUser& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCUser* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCUser* other);

  // implements Message ----------------------------------------------

  MIMCUser* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCUser& from);
  void MergeFrom(const MIMCUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional string appAccount = 2;
  inline bool has_appaccount() const;
  inline void clear_appaccount();
  static const int kAppAccountFieldNumber = 2;
  inline const ::std::string& appaccount() const;
  inline void set_appaccount(const ::std::string& value);
  inline void set_appaccount(const char* value);
  inline void set_appaccount(const char* value, size_t size);
  inline ::std::string* mutable_appaccount();
  inline ::std::string* release_appaccount();
  inline void set_allocated_appaccount(::std::string* appaccount);

  // optional int64 uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline ::google::protobuf::int64 uuid() const;
  inline void set_uuid(::google::protobuf::int64 value);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:mimc.MIMCUser)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_appaccount();
  inline void clear_has_appaccount();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::int64 appid_;
  ::std::string* appaccount_;
  ::google::protobuf::int64 uuid_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCUser* default_instance_;
};
// -------------------------------------------------------------------

class MIMCGroup : public ::google::protobuf::MessageLite {
 public:
  MIMCGroup();
  virtual ~MIMCGroup();

  MIMCGroup(const MIMCGroup& from);

  inline MIMCGroup& operator=(const MIMCGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const MIMCGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MIMCGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MIMCGroup* other);

  // implements Message ----------------------------------------------

  MIMCGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MIMCGroup& from);
  void MergeFrom(const MIMCGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional int64 topicId = 2;
  inline bool has_topicid() const;
  inline void clear_topicid();
  static const int kTopicIdFieldNumber = 2;
  inline ::google::protobuf::int64 topicid() const;
  inline void set_topicid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.MIMCGroup)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_topicid();
  inline void clear_has_topicid();

  ::google::protobuf::int64 appid_;
  ::google::protobuf::int64 topicid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static MIMCGroup* default_instance_;
};
// -------------------------------------------------------------------

class UCGroup : public ::google::protobuf::MessageLite {
 public:
  UCGroup();
  virtual ~UCGroup();

  UCGroup(const UCGroup& from);

  inline UCGroup& operator=(const UCGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCGroup* other);

  // implements Message ----------------------------------------------

  UCGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCGroup& from);
  void MergeFrom(const UCGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline ::google::protobuf::int64 appid() const;
  inline void set_appid(::google::protobuf::int64 value);

  // optional int64 topicId = 2;
  inline bool has_topicid() const;
  inline void clear_topicid();
  static const int kTopicIdFieldNumber = 2;
  inline ::google::protobuf::int64 topicid() const;
  inline void set_topicid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.UCGroup)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_topicid();
  inline void clear_has_topicid();

  ::google::protobuf::int64 appid_;
  ::google::protobuf::int64 topicid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCGroup* default_instance_;
};
// -------------------------------------------------------------------

class UCPacket : public ::google::protobuf::MessageLite {
 public:
  UCPacket();
  virtual ~UCPacket();

  UCPacket(const UCPacket& from);

  inline UCPacket& operator=(const UCPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCPacket* other);

  // implements Message ----------------------------------------------

  UCPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCPacket& from);
  void MergeFrom(const UCPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.MIMCUser user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::mimc::MIMCUser& user() const;
  inline ::mimc::MIMCUser* mutable_user();
  inline ::mimc::MIMCUser* release_user();
  inline void set_allocated_user(::mimc::MIMCUser* user);

  // required .mimc.UC_MSG_TYPE type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mimc::UC_MSG_TYPE type() const;
  inline void set_type(::mimc::UC_MSG_TYPE value);

  // required bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // required string packetId = 4;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 4;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // @@protoc_insertion_point(class_scope:mimc.UCPacket)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_packetid();
  inline void clear_has_packetid();

  ::mimc::MIMCUser* user_;
  ::std::string* payload_;
  ::std::string* packetid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCPacket* default_instance_;
};
// -------------------------------------------------------------------

class UCExchange : public ::google::protobuf::MessageLite {
 public:
  UCExchange();
  virtual ~UCExchange();

  UCExchange(const UCExchange& from);

  inline UCExchange& operator=(const UCExchange& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCExchange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCExchange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCExchange* other);

  // implements Message ----------------------------------------------

  UCExchange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCExchange& from);
  void MergeFrom(const UCExchange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mimc.FeInfo feInfo = 1;
  inline bool has_feinfo() const;
  inline void clear_feinfo();
  static const int kFeInfoFieldNumber = 1;
  inline const ::mimc::FeInfo& feinfo() const;
  inline ::mimc::FeInfo* mutable_feinfo();
  inline ::mimc::FeInfo* release_feinfo();
  inline void set_allocated_feinfo(::mimc::FeInfo* feinfo);

  // required .mimc.UCPacket packet = 2;
  inline bool has_packet() const;
  inline void clear_packet();
  static const int kPacketFieldNumber = 2;
  inline const ::mimc::UCPacket& packet() const;
  inline ::mimc::UCPacket* mutable_packet();
  inline ::mimc::UCPacket* release_packet();
  inline void set_allocated_packet(::mimc::UCPacket* packet);

  // required string package = 3;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 3;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // @@protoc_insertion_point(class_scope:mimc.UCExchange)
 private:
  inline void set_has_feinfo();
  inline void clear_has_feinfo();
  inline void set_has_packet();
  inline void clear_has_packet();
  inline void set_has_package();
  inline void clear_has_package();

  ::mimc::FeInfo* feinfo_;
  ::mimc::UCPacket* packet_;
  ::std::string* package_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCExchange* default_instance_;
};
// -------------------------------------------------------------------

class UCJoin : public ::google::protobuf::MessageLite {
 public:
  UCJoin();
  virtual ~UCJoin();

  UCJoin(const UCJoin& from);

  inline UCJoin& operator=(const UCJoin& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCJoin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCJoin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCJoin* other);

  // implements Message ----------------------------------------------

  UCJoin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCJoin& from);
  void MergeFrom(const UCJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // @@protoc_insertion_point(class_scope:mimc.UCJoin)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::mimc::UCGroup* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCJoin* default_instance_;
};
// -------------------------------------------------------------------

class UCJoinResp : public ::google::protobuf::MessageLite {
 public:
  UCJoinResp();
  virtual ~UCJoinResp();

  UCJoinResp(const UCJoinResp& from);

  inline UCJoinResp& operator=(const UCJoinResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCJoinResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCJoinResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCJoinResp* other);

  // implements Message ----------------------------------------------

  UCJoinResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCJoinResp& from);
  void MergeFrom(const UCJoinResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mimc.UCJoinResp)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::mimc::UCGroup* group_;
  ::std::string* message_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCJoinResp* default_instance_;
};
// -------------------------------------------------------------------

class UCQuit : public ::google::protobuf::MessageLite {
 public:
  UCQuit();
  virtual ~UCQuit();

  UCQuit(const UCQuit& from);

  inline UCQuit& operator=(const UCQuit& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCQuit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCQuit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCQuit* other);

  // implements Message ----------------------------------------------

  UCQuit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCQuit& from);
  void MergeFrom(const UCQuit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // @@protoc_insertion_point(class_scope:mimc.UCQuit)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::mimc::UCGroup* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCQuit* default_instance_;
};
// -------------------------------------------------------------------

class UCQuitResp : public ::google::protobuf::MessageLite {
 public:
  UCQuitResp();
  virtual ~UCQuitResp();

  UCQuitResp(const UCQuitResp& from);

  inline UCQuitResp& operator=(const UCQuitResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCQuitResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCQuitResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCQuitResp* other);

  // implements Message ----------------------------------------------

  UCQuitResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCQuitResp& from);
  void MergeFrom(const UCQuitResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:mimc.UCQuitResp)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::mimc::UCGroup* group_;
  ::std::string* message_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCQuitResp* default_instance_;
};
// -------------------------------------------------------------------

class UCPing : public ::google::protobuf::MessageLite {
 public:
  UCPing();
  virtual ~UCPing();

  UCPing(const UCPing& from);

  inline UCPing& operator=(const UCPing& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCPing* other);

  // implements Message ----------------------------------------------

  UCPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCPing& from);
  void MergeFrom(const UCPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mimc.UCGroup group = 1;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group(int index) const;
  inline ::mimc::UCGroup* mutable_group(int index);
  inline ::mimc::UCGroup* add_group();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >&
      group() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >*
      mutable_group();

  // @@protoc_insertion_point(class_scope:mimc.UCPing)
 private:

  ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup > group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCPing* default_instance_;
};
// -------------------------------------------------------------------

class UCMessage : public ::google::protobuf::MessageLite {
 public:
  UCMessage();
  virtual ~UCMessage();

  UCMessage(const UCMessage& from);

  inline UCMessage& operator=(const UCMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCMessage* other);

  // implements Message ----------------------------------------------

  UCMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCMessage& from);
  void MergeFrom(const UCMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // required bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // optional .mimc.MIMCUser user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::mimc::MIMCUser& user() const;
  inline ::mimc::MIMCUser* mutable_user();
  inline ::mimc::MIMCUser* release_user();
  inline void set_allocated_user(::mimc::MIMCUser* user);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string packetId = 7;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 7;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // @@protoc_insertion_point(class_scope:mimc.UCMessage)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_isstore();
  inline void clear_has_isstore();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_packetid();
  inline void clear_has_packetid();

  ::mimc::UCGroup* group_;
  ::std::string* payload_;
  ::google::protobuf::int64 sequence_;
  ::mimc::MIMCUser* user_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* packetid_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCMessage* default_instance_;
};
// -------------------------------------------------------------------

class UCPushMessage : public ::google::protobuf::MessageLite {
 public:
  UCPushMessage();
  virtual ~UCPushMessage();

  UCPushMessage(const UCPushMessage& from);

  inline UCPushMessage& operator=(const UCPushMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCPushMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCPushMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCPushMessage* other);

  // implements Message ----------------------------------------------

  UCPushMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCPushMessage& from);
  void MergeFrom(const UCPushMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.MIMCUser user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::mimc::MIMCUser& user() const;
  inline ::mimc::MIMCUser* mutable_user();
  inline ::mimc::MIMCUser* release_user();
  inline void set_allocated_user(::mimc::MIMCUser* user);

  // repeated .mimc.UCGroup group = 2;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::mimc::UCGroup& group(int index) const;
  inline ::mimc::UCGroup* mutable_group(int index);
  inline ::mimc::UCGroup* add_group();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >&
      group() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >*
      mutable_group();

  // repeated bytes payloads = 3;
  inline int payloads_size() const;
  inline void clear_payloads();
  static const int kPayloadsFieldNumber = 3;
  inline const ::std::string& payloads(int index) const;
  inline ::std::string* mutable_payloads(int index);
  inline void set_payloads(int index, const ::std::string& value);
  inline void set_payloads(int index, const char* value);
  inline void set_payloads(int index, const void* value, size_t size);
  inline ::std::string* add_payloads();
  inline void add_payloads(const ::std::string& value);
  inline void add_payloads(const char* value);
  inline void add_payloads(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& payloads() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_payloads();

  // optional bool isStore = 4;
  inline bool has_isstore() const;
  inline void clear_isstore();
  static const int kIsStoreFieldNumber = 4;
  inline bool isstore() const;
  inline void set_isstore(bool value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string packetId = 6;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 6;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  inline void set_allocated_packetid(::std::string* packetid);

  // @@protoc_insertion_point(class_scope:mimc.UCPushMessage)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_isstore();
  inline void clear_has_isstore();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_packetid();
  inline void clear_has_packetid();

  ::mimc::MIMCUser* user_;
  ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup > group_;
  ::google::protobuf::RepeatedPtrField< ::std::string> payloads_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* packetid_;
  bool isstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCPushMessage* default_instance_;
};
// -------------------------------------------------------------------

class UCMessageList : public ::google::protobuf::MessageLite {
 public:
  UCMessageList();
  virtual ~UCMessageList();

  UCMessageList(const UCMessageList& from);

  inline UCMessageList& operator=(const UCMessageList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCMessageList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCMessageList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCMessageList* other);

  // implements Message ----------------------------------------------

  UCMessageList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCMessageList& from);
  void MergeFrom(const UCMessageList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // repeated .mimc.UCMessage message = 2;
  inline int message_size() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::mimc::UCMessage& message(int index) const;
  inline ::mimc::UCMessage* mutable_message(int index);
  inline ::mimc::UCMessage* add_message();
  inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCMessage >&
      message() const;
  inline ::google::protobuf::RepeatedPtrField< ::mimc::UCMessage >*
      mutable_message();

  // optional int64 maxSequence = 3;
  inline bool has_maxsequence() const;
  inline void clear_maxsequence();
  static const int kMaxSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 maxsequence() const;
  inline void set_maxsequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.UCMessageList)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_maxsequence();
  inline void clear_has_maxsequence();

  ::mimc::UCGroup* group_;
  ::google::protobuf::RepeatedPtrField< ::mimc::UCMessage > message_;
  ::google::protobuf::int64 maxsequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCMessageList* default_instance_;
};
// -------------------------------------------------------------------

class UCSequenceAck : public ::google::protobuf::MessageLite {
 public:
  UCSequenceAck();
  virtual ~UCSequenceAck();

  UCSequenceAck(const UCSequenceAck& from);

  inline UCSequenceAck& operator=(const UCSequenceAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCSequenceAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCSequenceAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCSequenceAck* other);

  // implements Message ----------------------------------------------

  UCSequenceAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCSequenceAck& from);
  void MergeFrom(const UCSequenceAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // required int64 sequence = 2;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.UCSequenceAck)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::mimc::UCGroup* group_;
  ::google::protobuf::int64 sequence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCSequenceAck* default_instance_;
};
// -------------------------------------------------------------------

class UCDismiss : public ::google::protobuf::MessageLite {
 public:
  UCDismiss();
  virtual ~UCDismiss();

  UCDismiss(const UCDismiss& from);

  inline UCDismiss& operator=(const UCDismiss& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCDismiss& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCDismiss* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCDismiss* other);

  // implements Message ----------------------------------------------

  UCDismiss* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCDismiss& from);
  void MergeFrom(const UCDismiss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // @@protoc_insertion_point(class_scope:mimc.UCDismiss)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::mimc::UCGroup* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCDismiss* default_instance_;
};
// -------------------------------------------------------------------

class UCQueryOnlineUsers : public ::google::protobuf::MessageLite {
 public:
  UCQueryOnlineUsers();
  virtual ~UCQueryOnlineUsers();

  UCQueryOnlineUsers(const UCQueryOnlineUsers& from);

  inline UCQueryOnlineUsers& operator=(const UCQueryOnlineUsers& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCQueryOnlineUsers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCQueryOnlineUsers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCQueryOnlineUsers* other);

  // implements Message ----------------------------------------------

  UCQueryOnlineUsers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCQueryOnlineUsers& from);
  void MergeFrom(const UCQueryOnlineUsers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // @@protoc_insertion_point(class_scope:mimc.UCQueryOnlineUsers)
 private:
  inline void set_has_group();
  inline void clear_has_group();

  ::mimc::UCGroup* group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCQueryOnlineUsers* default_instance_;
};
// -------------------------------------------------------------------

class UCQueryOnlineUsersResp : public ::google::protobuf::MessageLite {
 public:
  UCQueryOnlineUsersResp();
  virtual ~UCQueryOnlineUsersResp();

  UCQueryOnlineUsersResp(const UCQueryOnlineUsersResp& from);

  inline UCQueryOnlineUsersResp& operator=(const UCQueryOnlineUsersResp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UCQueryOnlineUsersResp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UCQueryOnlineUsersResp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UCQueryOnlineUsersResp* other);

  // implements Message ----------------------------------------------

  UCQueryOnlineUsersResp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UCQueryOnlineUsersResp& from);
  void MergeFrom(const UCQueryOnlineUsersResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mimc.UCGroup group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::mimc::UCGroup& group() const;
  inline ::mimc::UCGroup* mutable_group();
  inline ::mimc::UCGroup* release_group();
  inline void set_allocated_group(::mimc::UCGroup* group);

  // required int64 userCount = 2;
  inline bool has_usercount() const;
  inline void clear_usercount();
  static const int kUserCountFieldNumber = 2;
  inline ::google::protobuf::int64 usercount() const;
  inline void set_usercount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mimc.UCQueryOnlineUsersResp)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_usercount();
  inline void clear_has_usercount();

  ::mimc::UCGroup* group_;
  ::google::protobuf::int64 usercount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static UCQueryOnlineUsersResp* default_instance_;
};
// -------------------------------------------------------------------

class FeInfo : public ::google::protobuf::MessageLite {
 public:
  FeInfo();
  virtual ~FeInfo();

  FeInfo(const FeInfo& from);

  inline FeInfo& operator=(const FeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FeInfo* other);

  // implements Message ----------------------------------------------

  FeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FeInfo& from);
  void MergeFrom(const FeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fe_src_ip = 1;
  inline bool has_fe_src_ip() const;
  inline void clear_fe_src_ip();
  static const int kFeSrcIpFieldNumber = 1;
  inline const ::std::string& fe_src_ip() const;
  inline void set_fe_src_ip(const ::std::string& value);
  inline void set_fe_src_ip(const char* value);
  inline void set_fe_src_ip(const char* value, size_t size);
  inline ::std::string* mutable_fe_src_ip();
  inline ::std::string* release_fe_src_ip();
  inline void set_allocated_fe_src_ip(::std::string* fe_src_ip);

  // optional int32 fe_src_port = 2;
  inline bool has_fe_src_port() const;
  inline void clear_fe_src_port();
  static const int kFeSrcPortFieldNumber = 2;
  inline ::google::protobuf::int32 fe_src_port() const;
  inline void set_fe_src_port(::google::protobuf::int32 value);

  // optional int32 fe_thread_id = 3;
  inline bool has_fe_thread_id() const;
  inline void clear_fe_thread_id();
  static const int kFeThreadIdFieldNumber = 3;
  inline ::google::protobuf::int32 fe_thread_id() const;
  inline void set_fe_thread_id(::google::protobuf::int32 value);

  // optional uint64 fe_ucid = 4;
  inline bool has_fe_ucid() const;
  inline void clear_fe_ucid();
  static const int kFeUcidFieldNumber = 4;
  inline ::google::protobuf::uint64 fe_ucid() const;
  inline void set_fe_ucid(::google::protobuf::uint64 value);

  // optional uint64 fe_sid = 5;
  inline bool has_fe_sid() const;
  inline void clear_fe_sid();
  static const int kFeSidFieldNumber = 5;
  inline ::google::protobuf::uint64 fe_sid() const;
  inline void set_fe_sid(::google::protobuf::uint64 value);

  // optional uint64 fe_seqno = 6;
  inline bool has_fe_seqno() const;
  inline void clear_fe_seqno();
  static const int kFeSeqnoFieldNumber = 6;
  inline ::google::protobuf::uint64 fe_seqno() const;
  inline void set_fe_seqno(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mimc.FeInfo)
 private:
  inline void set_has_fe_src_ip();
  inline void clear_has_fe_src_ip();
  inline void set_has_fe_src_port();
  inline void clear_has_fe_src_port();
  inline void set_has_fe_thread_id();
  inline void clear_has_fe_thread_id();
  inline void set_has_fe_ucid();
  inline void clear_has_fe_ucid();
  inline void set_has_fe_sid();
  inline void clear_has_fe_sid();
  inline void set_has_fe_seqno();
  inline void clear_has_fe_seqno();

  ::std::string* fe_src_ip_;
  ::google::protobuf::int32 fe_src_port_;
  ::google::protobuf::int32 fe_thread_id_;
  ::google::protobuf::uint64 fe_ucid_;
  ::google::protobuf::uint64 fe_sid_;
  ::google::protobuf::uint64 fe_seqno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mimc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mimc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mimc_2eproto();
  friend void protobuf_ShutdownFile_mimc_2eproto();

  void InitAsDefaultInstance();
  static FeInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// FilterRequest

// required string id = 1;
inline bool FilterRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FilterRequest::id() const {
  return *id_;
}
inline void FilterRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FilterRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mimc.MIMCPacket packet = 2;
inline bool FilterRequest::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterRequest::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterRequest::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterRequest::clear_packet() {
  if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
  clear_has_packet();
}
inline const ::mimc::MIMCPacket& FilterRequest::packet() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packet_ != NULL ? *packet_ : *default_instance().packet_;
#else
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
#endif
}
inline ::mimc::MIMCPacket* FilterRequest::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) packet_ = new ::mimc::MIMCPacket;
  return packet_;
}
inline ::mimc::MIMCPacket* FilterRequest::release_packet() {
  clear_has_packet();
  ::mimc::MIMCPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void FilterRequest::set_allocated_packet(::mimc::MIMCPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
}

// -------------------------------------------------------------------

// FilterResponse

// required string id = 1;
inline bool FilterResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FilterResponse::id() const {
  return *id_;
}
inline void FilterResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FilterResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilterResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FilterResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FilterResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mimc.MIMC_MSG_TYPE type = 2;
inline bool FilterResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::MIMC_MSG_TYPE FilterResponse::type() const {
  return static_cast< ::mimc::MIMC_MSG_TYPE >(type_);
}
inline void FilterResponse::set_type(::mimc::MIMC_MSG_TYPE value) {
  assert(::mimc::MIMC_MSG_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .mimc.ErrorCode errorCode = 3;
inline bool FilterResponse::has_errorcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterResponse::set_has_errorcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterResponse::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterResponse::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::mimc::ErrorCode FilterResponse::errorcode() const {
  return static_cast< ::mimc::ErrorCode >(errorcode_);
}
inline void FilterResponse::set_errorcode(::mimc::ErrorCode value) {
  assert(::mimc::ErrorCode_IsValid(value));
  set_has_errorcode();
  errorcode_ = value;
}

// optional bool isFilter = 4;
inline bool FilterResponse::has_isfilter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterResponse::set_has_isfilter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterResponse::clear_has_isfilter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterResponse::clear_isfilter() {
  isfilter_ = false;
  clear_has_isfilter();
}
inline bool FilterResponse::isfilter() const {
  return isfilter_;
}
inline void FilterResponse::set_isfilter(bool value) {
  set_has_isfilter();
  isfilter_ = value;
}

// -------------------------------------------------------------------

// PullMessageRequest

// required uint64 uuid = 1;
inline bool PullMessageRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullMessageRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullMessageRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullMessageRequest::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 PullMessageRequest::uuid() const {
  return uuid_;
}
inline void PullMessageRequest::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
}

// required string resource = 2;
inline bool PullMessageRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullMessageRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullMessageRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullMessageRequest::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& PullMessageRequest::resource() const {
  return *resource_;
}
inline void PullMessageRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PullMessageRequest::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void PullMessageRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullMessageRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* PullMessageRequest::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PullMessageRequest::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TopicMessage

// required uint64 topicId = 1;
inline bool TopicMessage::has_topicid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicMessage::set_has_topicid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicMessage::clear_has_topicid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicMessage::clear_topicid() {
  topicid_ = GOOGLE_ULONGLONG(0);
  clear_has_topicid();
}
inline ::google::protobuf::uint64 TopicMessage::topicid() const {
  return topicid_;
}
inline void TopicMessage::set_topicid(::google::protobuf::uint64 value) {
  set_has_topicid();
  topicid_ = value;
}

// required .mimc.MIMCPacket packet = 2;
inline bool TopicMessage::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicMessage::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicMessage::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicMessage::clear_packet() {
  if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
  clear_has_packet();
}
inline const ::mimc::MIMCPacket& TopicMessage::packet() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packet_ != NULL ? *packet_ : *default_instance().packet_;
#else
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
#endif
}
inline ::mimc::MIMCPacket* TopicMessage::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) packet_ = new ::mimc::MIMCPacket;
  return packet_;
}
inline ::mimc::MIMCPacket* TopicMessage::release_packet() {
  clear_has_packet();
  ::mimc::MIMCPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void TopicMessage::set_allocated_packet(::mimc::MIMCPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
}

// optional int64 uuid = 3;
inline bool TopicMessage::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicMessage::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicMessage::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicMessage::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 TopicMessage::uuid() const {
  return uuid_;
}
inline void TopicMessage::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 4;
inline bool TopicMessage::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicMessage::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicMessage::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicMessage::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& TopicMessage::resource() const {
  return *resource_;
}
inline void TopicMessage::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TopicMessage::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void TopicMessage::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopicMessage::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* TopicMessage::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopicMessage::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryAppinfoRequest

// required uint64 appId = 1;
inline bool QueryAppinfoRequest::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryAppinfoRequest::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryAppinfoRequest::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryAppinfoRequest::clear_appid() {
  appid_ = GOOGLE_ULONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::uint64 QueryAppinfoRequest::appid() const {
  return appid_;
}
inline void QueryAppinfoRequest::set_appid(::google::protobuf::uint64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string context = 2;
inline bool QueryAppinfoRequest::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryAppinfoRequest::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryAppinfoRequest::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryAppinfoRequest::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& QueryAppinfoRequest::context() const {
  return *context_;
}
inline void QueryAppinfoRequest::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void QueryAppinfoRequest::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void QueryAppinfoRequest::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryAppinfoRequest::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* QueryAppinfoRequest::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryAppinfoRequest::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Appinfo

// required uint64 appId = 1;
inline bool Appinfo::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Appinfo::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Appinfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Appinfo::clear_appid() {
  appid_ = GOOGLE_ULONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::uint64 Appinfo::appid() const {
  return appid_;
}
inline void Appinfo::set_appid(::google::protobuf::uint64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string msgCallbackUrl = 2;
inline bool Appinfo::has_msgcallbackurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Appinfo::set_has_msgcallbackurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Appinfo::clear_has_msgcallbackurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Appinfo::clear_msgcallbackurl() {
  if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_->clear();
  }
  clear_has_msgcallbackurl();
}
inline const ::std::string& Appinfo::msgcallbackurl() const {
  return *msgcallbackurl_;
}
inline void Appinfo::set_msgcallbackurl(const ::std::string& value) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(value);
}
inline void Appinfo::set_msgcallbackurl(const char* value) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(value);
}
inline void Appinfo::set_msgcallbackurl(const char* value, size_t size) {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  msgcallbackurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_msgcallbackurl() {
  set_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    msgcallbackurl_ = new ::std::string;
  }
  return msgcallbackurl_;
}
inline ::std::string* Appinfo::release_msgcallbackurl() {
  clear_has_msgcallbackurl();
  if (msgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcallbackurl_;
    msgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_msgcallbackurl(::std::string* msgcallbackurl) {
  if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcallbackurl_;
  }
  if (msgcallbackurl) {
    set_has_msgcallbackurl();
    msgcallbackurl_ = msgcallbackurl;
  } else {
    clear_has_msgcallbackurl();
    msgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string offlineMsgCallbackUrl = 3;
inline bool Appinfo::has_offlinemsgcallbackurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Appinfo::set_has_offlinemsgcallbackurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Appinfo::clear_has_offlinemsgcallbackurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Appinfo::clear_offlinemsgcallbackurl() {
  if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_->clear();
  }
  clear_has_offlinemsgcallbackurl();
}
inline const ::std::string& Appinfo::offlinemsgcallbackurl() const {
  return *offlinemsgcallbackurl_;
}
inline void Appinfo::set_offlinemsgcallbackurl(const ::std::string& value) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(value);
}
inline void Appinfo::set_offlinemsgcallbackurl(const char* value) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(value);
}
inline void Appinfo::set_offlinemsgcallbackurl(const char* value, size_t size) {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  offlinemsgcallbackurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_offlinemsgcallbackurl() {
  set_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    offlinemsgcallbackurl_ = new ::std::string;
  }
  return offlinemsgcallbackurl_;
}
inline ::std::string* Appinfo::release_offlinemsgcallbackurl() {
  clear_has_offlinemsgcallbackurl();
  if (offlinemsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offlinemsgcallbackurl_;
    offlinemsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_offlinemsgcallbackurl(::std::string* offlinemsgcallbackurl) {
  if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete offlinemsgcallbackurl_;
  }
  if (offlinemsgcallbackurl) {
    set_has_offlinemsgcallbackurl();
    offlinemsgcallbackurl_ = offlinemsgcallbackurl;
  } else {
    clear_has_offlinemsgcallbackurl();
    offlinemsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uuidTTL = 4;
inline bool Appinfo::has_uuidttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Appinfo::set_has_uuidttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Appinfo::clear_has_uuidttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Appinfo::clear_uuidttl() {
  uuidttl_ = GOOGLE_ULONGLONG(0);
  clear_has_uuidttl();
}
inline ::google::protobuf::uint64 Appinfo::uuidttl() const {
  return uuidttl_;
}
inline void Appinfo::set_uuidttl(::google::protobuf::uint64 value) {
  set_has_uuidttl();
  uuidttl_ = value;
}

// optional string context = 5;
inline bool Appinfo::has_context() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Appinfo::set_has_context() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Appinfo::clear_has_context() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Appinfo::clear_context() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& Appinfo::context() const {
  return *context_;
}
inline void Appinfo::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void Appinfo::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(value);
}
inline void Appinfo::set_context(const char* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    context_ = new ::std::string;
  }
  return context_;
}
inline ::std::string* Appinfo::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string messageFilter = 6;
inline bool Appinfo::has_messagefilter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Appinfo::set_has_messagefilter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Appinfo::clear_has_messagefilter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Appinfo::clear_messagefilter() {
  if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
    messagefilter_->clear();
  }
  clear_has_messagefilter();
}
inline const ::std::string& Appinfo::messagefilter() const {
  return *messagefilter_;
}
inline void Appinfo::set_messagefilter(const ::std::string& value) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(value);
}
inline void Appinfo::set_messagefilter(const char* value) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(value);
}
inline void Appinfo::set_messagefilter(const char* value, size_t size) {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  messagefilter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_messagefilter() {
  set_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    messagefilter_ = new ::std::string;
  }
  return messagefilter_;
}
inline ::std::string* Appinfo::release_messagefilter() {
  clear_has_messagefilter();
  if (messagefilter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagefilter_;
    messagefilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_messagefilter(::std::string* messagefilter) {
  if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
    delete messagefilter_;
  }
  if (messagefilter) {
    set_has_messagefilter();
    messagefilter_ = messagefilter;
  } else {
    clear_has_messagefilter();
    messagefilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ucMsgCallbackUrl = 7;
inline bool Appinfo::has_ucmsgcallbackurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Appinfo::set_has_ucmsgcallbackurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Appinfo::clear_has_ucmsgcallbackurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Appinfo::clear_ucmsgcallbackurl() {
  if (ucmsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    ucmsgcallbackurl_->clear();
  }
  clear_has_ucmsgcallbackurl();
}
inline const ::std::string& Appinfo::ucmsgcallbackurl() const {
  return *ucmsgcallbackurl_;
}
inline void Appinfo::set_ucmsgcallbackurl(const ::std::string& value) {
  set_has_ucmsgcallbackurl();
  if (ucmsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    ucmsgcallbackurl_ = new ::std::string;
  }
  ucmsgcallbackurl_->assign(value);
}
inline void Appinfo::set_ucmsgcallbackurl(const char* value) {
  set_has_ucmsgcallbackurl();
  if (ucmsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    ucmsgcallbackurl_ = new ::std::string;
  }
  ucmsgcallbackurl_->assign(value);
}
inline void Appinfo::set_ucmsgcallbackurl(const char* value, size_t size) {
  set_has_ucmsgcallbackurl();
  if (ucmsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    ucmsgcallbackurl_ = new ::std::string;
  }
  ucmsgcallbackurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Appinfo::mutable_ucmsgcallbackurl() {
  set_has_ucmsgcallbackurl();
  if (ucmsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    ucmsgcallbackurl_ = new ::std::string;
  }
  return ucmsgcallbackurl_;
}
inline ::std::string* Appinfo::release_ucmsgcallbackurl() {
  clear_has_ucmsgcallbackurl();
  if (ucmsgcallbackurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ucmsgcallbackurl_;
    ucmsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Appinfo::set_allocated_ucmsgcallbackurl(::std::string* ucmsgcallbackurl) {
  if (ucmsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete ucmsgcallbackurl_;
  }
  if (ucmsgcallbackurl) {
    set_has_ucmsgcallbackurl();
    ucmsgcallbackurl_ = ucmsgcallbackurl;
  } else {
    clear_has_ucmsgcallbackurl();
    ucmsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCPacket

// optional string packetId = 1;
inline bool MIMCPacket::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacket::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacket::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacket::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& MIMCPacket::packetid() const {
  return *packetid_;
}
inline void MIMCPacket::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacket::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacket::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* MIMCPacket::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string package = 2;
inline bool MIMCPacket::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacket::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacket::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacket::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& MIMCPacket::package() const {
  return *package_;
}
inline void MIMCPacket::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacket::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacket::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* MIMCPacket::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 3;
inline bool MIMCPacket::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacket::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacket::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacket::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCPacket::sequence() const {
  return sequence_;
}
inline void MIMCPacket::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional .mimc.MIMC_MSG_TYPE type = 4;
inline bool MIMCPacket::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCPacket::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCPacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCPacket::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::MIMC_MSG_TYPE MIMCPacket::type() const {
  return static_cast< ::mimc::MIMC_MSG_TYPE >(type_);
}
inline void MIMCPacket::set_type(::mimc::MIMC_MSG_TYPE value) {
  assert(::mimc::MIMC_MSG_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes payload = 5;
inline bool MIMCPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCPacket::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCPacket::payload() const {
  return *payload_;
}
inline void MIMCPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCPacket::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacket::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCPacket::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacket::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 6;
inline bool MIMCPacket::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MIMCPacket::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MIMCPacket::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MIMCPacket::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MIMCPacket::timestamp() const {
  return timestamp_;
}
inline void MIMCPacket::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// MIMCPacketList

// optional int64 uuid = 1;
inline bool MIMCPacketList::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacketList::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacketList::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacketList::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPacketList::uuid() const {
  return uuid_;
}
inline void MIMCPacketList::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCPacketList::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacketList::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacketList::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacketList::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPacketList::resource() const {
  return *resource_;
}
inline void MIMCPacketList::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketList::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketList::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketList::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPacketList::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketList::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 maxSequence = 3;
inline bool MIMCPacketList::has_maxsequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacketList::set_has_maxsequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacketList::clear_has_maxsequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacketList::clear_maxsequence() {
  maxsequence_ = GOOGLE_LONGLONG(0);
  clear_has_maxsequence();
}
inline ::google::protobuf::int64 MIMCPacketList::maxsequence() const {
  return maxsequence_;
}
inline void MIMCPacketList::set_maxsequence(::google::protobuf::int64 value) {
  set_has_maxsequence();
  maxsequence_ = value;
}

// repeated .mimc.MIMCPacket packets = 4;
inline int MIMCPacketList::packets_size() const {
  return packets_.size();
}
inline void MIMCPacketList::clear_packets() {
  packets_.Clear();
}
inline const ::mimc::MIMCPacket& MIMCPacketList::packets(int index) const {
  return packets_.Get(index);
}
inline ::mimc::MIMCPacket* MIMCPacketList::mutable_packets(int index) {
  return packets_.Mutable(index);
}
inline ::mimc::MIMCPacket* MIMCPacketList::add_packets() {
  return packets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >&
MIMCPacketList::packets() const {
  return packets_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCPacket >*
MIMCPacketList::mutable_packets() {
  return &packets_;
}

// -------------------------------------------------------------------

// MIMCPacketAck

// optional string packetId = 1;
inline bool MIMCPacketAck::has_packetid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPacketAck::set_has_packetid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPacketAck::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPacketAck::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& MIMCPacketAck::packetid() const {
  return *packetid_;
}
inline void MIMCPacketAck::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacketAck::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void MIMCPacketAck::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* MIMCPacketAck::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 uuid = 2;
inline bool MIMCPacketAck::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPacketAck::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPacketAck::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPacketAck::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPacketAck::uuid() const {
  return uuid_;
}
inline void MIMCPacketAck::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 3;
inline bool MIMCPacketAck::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCPacketAck::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCPacketAck::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCPacketAck::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPacketAck::resource() const {
  return *resource_;
}
inline void MIMCPacketAck::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketAck::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPacketAck::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPacketAck::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 4;
inline bool MIMCPacketAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCPacketAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCPacketAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCPacketAck::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCPacketAck::sequence() const {
  return sequence_;
}
inline void MIMCPacketAck::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int64 timestamp = 5;
inline bool MIMCPacketAck::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCPacketAck::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCPacketAck::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCPacketAck::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MIMCPacketAck::timestamp() const {
  return timestamp_;
}
inline void MIMCPacketAck::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string package = 6;
inline bool MIMCPacketAck::has_package() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MIMCPacketAck::set_has_package() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MIMCPacketAck::clear_has_package() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MIMCPacketAck::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& MIMCPacketAck::package() const {
  return *package_;
}
inline void MIMCPacketAck::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacketAck::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void MIMCPacketAck::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* MIMCPacketAck::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string errorMsg = 7;
inline bool MIMCPacketAck::has_errormsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MIMCPacketAck::set_has_errormsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MIMCPacketAck::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MIMCPacketAck::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& MIMCPacketAck::errormsg() const {
  return *errormsg_;
}
inline void MIMCPacketAck::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void MIMCPacketAck::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void MIMCPacketAck::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPacketAck::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* MIMCPacketAck::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPacketAck::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errormsg_;
  }
  if (errormsg) {
    set_has_errormsg();
    errormsg_ = errormsg;
  } else {
    clear_has_errormsg();
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCP2PMessage

// optional .mimc.MIMCUser from = 1;
inline bool MIMCP2PMessage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCP2PMessage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCP2PMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCP2PMessage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& MIMCP2PMessage::from() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_ != NULL ? *from_ : *default_instance().from_;
#else
  return from_ != NULL ? *from_ : *default_instance_->from_;
#endif
}
inline ::mimc::MIMCUser* MIMCP2PMessage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void MIMCP2PMessage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// optional .mimc.MIMCUser to = 2;
inline bool MIMCP2PMessage::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCP2PMessage::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCP2PMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCP2PMessage::clear_to() {
  if (to_ != NULL) to_->::mimc::MIMCUser::Clear();
  clear_has_to();
}
inline const ::mimc::MIMCUser& MIMCP2PMessage::to() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return to_ != NULL ? *to_ : *default_instance().to_;
#else
  return to_ != NULL ? *to_ : *default_instance_->to_;
#endif
}
inline ::mimc::MIMCUser* MIMCP2PMessage::mutable_to() {
  set_has_to();
  if (to_ == NULL) to_ = new ::mimc::MIMCUser;
  return to_;
}
inline ::mimc::MIMCUser* MIMCP2PMessage::release_to() {
  clear_has_to();
  ::mimc::MIMCUser* temp = to_;
  to_ = NULL;
  return temp;
}
inline void MIMCP2PMessage::set_allocated_to(::mimc::MIMCUser* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
}

// optional bytes payload = 3;
inline bool MIMCP2PMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCP2PMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCP2PMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCP2PMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCP2PMessage::payload() const {
  return *payload_;
}
inline void MIMCP2PMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2PMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2PMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2PMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCP2PMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2PMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool MIMCP2PMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCP2PMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCP2PMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCP2PMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool MIMCP2PMessage::isstore() const {
  return isstore_;
}
inline void MIMCP2PMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// optional bytes bizType = 5;
inline bool MIMCP2PMessage::has_biztype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCP2PMessage::set_has_biztype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCP2PMessage::clear_has_biztype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCP2PMessage::clear_biztype() {
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    biztype_->clear();
  }
  clear_has_biztype();
}
inline const ::std::string& MIMCP2PMessage::biztype() const {
  return *biztype_;
}
inline void MIMCP2PMessage::set_biztype(const ::std::string& value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
}
inline void MIMCP2PMessage::set_biztype(const char* value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
}
inline void MIMCP2PMessage::set_biztype(const void* value, size_t size) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2PMessage::mutable_biztype() {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  return biztype_;
}
inline ::std::string* MIMCP2PMessage::release_biztype() {
  clear_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = biztype_;
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2PMessage::set_allocated_biztype(::std::string* biztype) {
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  if (biztype) {
    set_has_biztype();
    biztype_ = biztype;
  } else {
    clear_has_biztype();
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCP2TMessage

// optional .mimc.MIMCUser from = 1;
inline bool MIMCP2TMessage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCP2TMessage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCP2TMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCP2TMessage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& MIMCP2TMessage::from() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_ != NULL ? *from_ : *default_instance().from_;
#else
  return from_ != NULL ? *from_ : *default_instance_->from_;
#endif
}
inline ::mimc::MIMCUser* MIMCP2TMessage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* MIMCP2TMessage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void MIMCP2TMessage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// optional .mimc.MIMCGroup to = 2;
inline bool MIMCP2TMessage::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCP2TMessage::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCP2TMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCP2TMessage::clear_to() {
  if (to_ != NULL) to_->::mimc::MIMCGroup::Clear();
  clear_has_to();
}
inline const ::mimc::MIMCGroup& MIMCP2TMessage::to() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return to_ != NULL ? *to_ : *default_instance().to_;
#else
  return to_ != NULL ? *to_ : *default_instance_->to_;
#endif
}
inline ::mimc::MIMCGroup* MIMCP2TMessage::mutable_to() {
  set_has_to();
  if (to_ == NULL) to_ = new ::mimc::MIMCGroup;
  return to_;
}
inline ::mimc::MIMCGroup* MIMCP2TMessage::release_to() {
  clear_has_to();
  ::mimc::MIMCGroup* temp = to_;
  to_ = NULL;
  return temp;
}
inline void MIMCP2TMessage::set_allocated_to(::mimc::MIMCGroup* to) {
  delete to_;
  to_ = to;
  if (to) {
    set_has_to();
  } else {
    clear_has_to();
  }
}

// optional bytes payload = 3;
inline bool MIMCP2TMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCP2TMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCP2TMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCP2TMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MIMCP2TMessage::payload() const {
  return *payload_;
}
inline void MIMCP2TMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2TMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MIMCP2TMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2TMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MIMCP2TMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2TMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool MIMCP2TMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCP2TMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCP2TMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCP2TMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool MIMCP2TMessage::isstore() const {
  return isstore_;
}
inline void MIMCP2TMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// optional bytes bizType = 5;
inline bool MIMCP2TMessage::has_biztype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MIMCP2TMessage::set_has_biztype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MIMCP2TMessage::clear_has_biztype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MIMCP2TMessage::clear_biztype() {
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    biztype_->clear();
  }
  clear_has_biztype();
}
inline const ::std::string& MIMCP2TMessage::biztype() const {
  return *biztype_;
}
inline void MIMCP2TMessage::set_biztype(const ::std::string& value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
}
inline void MIMCP2TMessage::set_biztype(const char* value) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(value);
}
inline void MIMCP2TMessage::set_biztype(const void* value, size_t size) {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  biztype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCP2TMessage::mutable_biztype() {
  set_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    biztype_ = new ::std::string;
  }
  return biztype_;
}
inline ::std::string* MIMCP2TMessage::release_biztype() {
  clear_has_biztype();
  if (biztype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = biztype_;
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCP2TMessage::set_allocated_biztype(::std::string* biztype) {
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  if (biztype) {
    set_has_biztype();
    biztype_ = biztype;
  } else {
    clear_has_biztype();
    biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCSequenceAck

// optional int64 uuid = 1;
inline bool MIMCSequenceAck::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCSequenceAck::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCSequenceAck::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCSequenceAck::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCSequenceAck::uuid() const {
  return uuid_;
}
inline void MIMCSequenceAck::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCSequenceAck::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCSequenceAck::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCSequenceAck::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCSequenceAck::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCSequenceAck::resource() const {
  return *resource_;
}
inline void MIMCSequenceAck::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCSequenceAck::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCSequenceAck::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCSequenceAck::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCSequenceAck::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCSequenceAck::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 3;
inline bool MIMCSequenceAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCSequenceAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCSequenceAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCSequenceAck::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 MIMCSequenceAck::sequence() const {
  return sequence_;
}
inline void MIMCSequenceAck::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// -------------------------------------------------------------------

// MIMCPull

// optional int64 uuid = 1;
inline bool MIMCPull::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCPull::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCPull::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCPull::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCPull::uuid() const {
  return uuid_;
}
inline void MIMCPull::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 2;
inline bool MIMCPull::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCPull::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCPull::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCPull::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCPull::resource() const {
  return *resource_;
}
inline void MIMCPull::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPull::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCPull::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCPull::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCPull::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCPull::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// P2PPushMesage

// optional .mimc.MIMCUser from = 1;
inline bool P2PPushMesage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2PPushMesage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P2PPushMesage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P2PPushMesage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& P2PPushMesage::from() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_ != NULL ? *from_ : *default_instance().from_;
#else
  return from_ != NULL ? *from_ : *default_instance_->from_;
#endif
}
inline ::mimc::MIMCUser* P2PPushMesage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* P2PPushMesage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void P2PPushMesage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// repeated .mimc.MIMCUser to = 2;
inline int P2PPushMesage::to_size() const {
  return to_.size();
}
inline void P2PPushMesage::clear_to() {
  to_.Clear();
}
inline const ::mimc::MIMCUser& P2PPushMesage::to(int index) const {
  return to_.Get(index);
}
inline ::mimc::MIMCUser* P2PPushMesage::mutable_to(int index) {
  return to_.Mutable(index);
}
inline ::mimc::MIMCUser* P2PPushMesage::add_to() {
  return to_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCUser >&
P2PPushMesage::to() const {
  return to_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCUser >*
P2PPushMesage::mutable_to() {
  return &to_;
}

// optional bytes payload = 3;
inline bool P2PPushMesage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P2PPushMesage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P2PPushMesage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P2PPushMesage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& P2PPushMesage::payload() const {
  return *payload_;
}
inline void P2PPushMesage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void P2PPushMesage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void P2PPushMesage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* P2PPushMesage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* P2PPushMesage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void P2PPushMesage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool P2PPushMesage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void P2PPushMesage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void P2PPushMesage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void P2PPushMesage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool P2PPushMesage::isstore() const {
  return isstore_;
}
inline void P2PPushMesage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// -------------------------------------------------------------------

// P2TPushMesage

// optional .mimc.MIMCUser from = 1;
inline bool P2TPushMesage::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2TPushMesage::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P2TPushMesage::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P2TPushMesage::clear_from() {
  if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
  clear_has_from();
}
inline const ::mimc::MIMCUser& P2TPushMesage::from() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_ != NULL ? *from_ : *default_instance().from_;
#else
  return from_ != NULL ? *from_ : *default_instance_->from_;
#endif
}
inline ::mimc::MIMCUser* P2TPushMesage::mutable_from() {
  set_has_from();
  if (from_ == NULL) from_ = new ::mimc::MIMCUser;
  return from_;
}
inline ::mimc::MIMCUser* P2TPushMesage::release_from() {
  clear_has_from();
  ::mimc::MIMCUser* temp = from_;
  from_ = NULL;
  return temp;
}
inline void P2TPushMesage::set_allocated_from(::mimc::MIMCUser* from) {
  delete from_;
  from_ = from;
  if (from) {
    set_has_from();
  } else {
    clear_has_from();
  }
}

// repeated .mimc.MIMCGroup to = 2;
inline int P2TPushMesage::to_size() const {
  return to_.size();
}
inline void P2TPushMesage::clear_to() {
  to_.Clear();
}
inline const ::mimc::MIMCGroup& P2TPushMesage::to(int index) const {
  return to_.Get(index);
}
inline ::mimc::MIMCGroup* P2TPushMesage::mutable_to(int index) {
  return to_.Mutable(index);
}
inline ::mimc::MIMCGroup* P2TPushMesage::add_to() {
  return to_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::MIMCGroup >&
P2TPushMesage::to() const {
  return to_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::MIMCGroup >*
P2TPushMesage::mutable_to() {
  return &to_;
}

// optional bytes payload = 3;
inline bool P2TPushMesage::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void P2TPushMesage::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void P2TPushMesage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void P2TPushMesage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& P2TPushMesage::payload() const {
  return *payload_;
}
inline void P2TPushMesage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void P2TPushMesage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void P2TPushMesage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* P2TPushMesage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* P2TPushMesage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void P2TPushMesage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isStore = 4;
inline bool P2TPushMesage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void P2TPushMesage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void P2TPushMesage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void P2TPushMesage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool P2TPushMesage::isstore() const {
  return isstore_;
}
inline void P2TPushMesage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// -------------------------------------------------------------------

// MIMCUser

// optional int64 appId = 1;
inline bool MIMCUser::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCUser::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCUser::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCUser::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 MIMCUser::appid() const {
  return appid_;
}
inline void MIMCUser::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional string appAccount = 2;
inline bool MIMCUser::has_appaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCUser::set_has_appaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCUser::clear_has_appaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCUser::clear_appaccount() {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    appaccount_->clear();
  }
  clear_has_appaccount();
}
inline const ::std::string& MIMCUser::appaccount() const {
  return *appaccount_;
}
inline void MIMCUser::set_appaccount(const ::std::string& value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void MIMCUser::set_appaccount(const char* value) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(value);
}
inline void MIMCUser::set_appaccount(const char* value, size_t size) {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  appaccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCUser::mutable_appaccount() {
  set_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    appaccount_ = new ::std::string;
  }
  return appaccount_;
}
inline ::std::string* MIMCUser::release_appaccount() {
  clear_has_appaccount();
  if (appaccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appaccount_;
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCUser::set_allocated_appaccount(::std::string* appaccount) {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete appaccount_;
  }
  if (appaccount) {
    set_has_appaccount();
    appaccount_ = appaccount;
  } else {
    clear_has_appaccount();
    appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 uuid = 3;
inline bool MIMCUser::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MIMCUser::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MIMCUser::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MIMCUser::clear_uuid() {
  uuid_ = GOOGLE_LONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::int64 MIMCUser::uuid() const {
  return uuid_;
}
inline void MIMCUser::set_uuid(::google::protobuf::int64 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional string resource = 4;
inline bool MIMCUser::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MIMCUser::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MIMCUser::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MIMCUser::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& MIMCUser::resource() const {
  return *resource_;
}
inline void MIMCUser::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCUser::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void MIMCUser::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MIMCUser::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* MIMCUser::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MIMCUser::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MIMCGroup

// optional int64 appId = 1;
inline bool MIMCGroup::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MIMCGroup::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MIMCGroup::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MIMCGroup::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 MIMCGroup::appid() const {
  return appid_;
}
inline void MIMCGroup::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional int64 topicId = 2;
inline bool MIMCGroup::has_topicid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MIMCGroup::set_has_topicid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MIMCGroup::clear_has_topicid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MIMCGroup::clear_topicid() {
  topicid_ = GOOGLE_LONGLONG(0);
  clear_has_topicid();
}
inline ::google::protobuf::int64 MIMCGroup::topicid() const {
  return topicid_;
}
inline void MIMCGroup::set_topicid(::google::protobuf::int64 value) {
  set_has_topicid();
  topicid_ = value;
}

// -------------------------------------------------------------------

// UCGroup

// optional int64 appId = 1;
inline bool UCGroup::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCGroup::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCGroup::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCGroup::clear_appid() {
  appid_ = GOOGLE_LONGLONG(0);
  clear_has_appid();
}
inline ::google::protobuf::int64 UCGroup::appid() const {
  return appid_;
}
inline void UCGroup::set_appid(::google::protobuf::int64 value) {
  set_has_appid();
  appid_ = value;
}

// optional int64 topicId = 2;
inline bool UCGroup::has_topicid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCGroup::set_has_topicid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCGroup::clear_has_topicid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCGroup::clear_topicid() {
  topicid_ = GOOGLE_LONGLONG(0);
  clear_has_topicid();
}
inline ::google::protobuf::int64 UCGroup::topicid() const {
  return topicid_;
}
inline void UCGroup::set_topicid(::google::protobuf::int64 value) {
  set_has_topicid();
  topicid_ = value;
}

// -------------------------------------------------------------------

// UCPacket

// required .mimc.MIMCUser user = 1;
inline bool UCPacket::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCPacket::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCPacket::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCPacket::clear_user() {
  if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
  clear_has_user();
}
inline const ::mimc::MIMCUser& UCPacket::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::mimc::MIMCUser* UCPacket::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mimc::MIMCUser;
  return user_;
}
inline ::mimc::MIMCUser* UCPacket::release_user() {
  clear_has_user();
  ::mimc::MIMCUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline void UCPacket::set_allocated_user(::mimc::MIMCUser* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// required .mimc.UC_MSG_TYPE type = 2;
inline bool UCPacket::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCPacket::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCPacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCPacket::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mimc::UC_MSG_TYPE UCPacket::type() const {
  return static_cast< ::mimc::UC_MSG_TYPE >(type_);
}
inline void UCPacket::set_type(::mimc::UC_MSG_TYPE value) {
  assert(::mimc::UC_MSG_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes payload = 3;
inline bool UCPacket::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCPacket::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCPacket::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCPacket::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& UCPacket::payload() const {
  return *payload_;
}
inline void UCPacket::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UCPacket::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UCPacket::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCPacket::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* UCPacket::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCPacket::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string packetId = 4;
inline bool UCPacket::has_packetid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UCPacket::set_has_packetid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UCPacket::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UCPacket::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& UCPacket::packetid() const {
  return *packetid_;
}
inline void UCPacket::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCPacket::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCPacket::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCPacket::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* UCPacket::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCPacket::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCExchange

// optional .mimc.FeInfo feInfo = 1;
inline bool UCExchange::has_feinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCExchange::set_has_feinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCExchange::clear_has_feinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCExchange::clear_feinfo() {
  if (feinfo_ != NULL) feinfo_->::mimc::FeInfo::Clear();
  clear_has_feinfo();
}
inline const ::mimc::FeInfo& UCExchange::feinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return feinfo_ != NULL ? *feinfo_ : *default_instance().feinfo_;
#else
  return feinfo_ != NULL ? *feinfo_ : *default_instance_->feinfo_;
#endif
}
inline ::mimc::FeInfo* UCExchange::mutable_feinfo() {
  set_has_feinfo();
  if (feinfo_ == NULL) feinfo_ = new ::mimc::FeInfo;
  return feinfo_;
}
inline ::mimc::FeInfo* UCExchange::release_feinfo() {
  clear_has_feinfo();
  ::mimc::FeInfo* temp = feinfo_;
  feinfo_ = NULL;
  return temp;
}
inline void UCExchange::set_allocated_feinfo(::mimc::FeInfo* feinfo) {
  delete feinfo_;
  feinfo_ = feinfo;
  if (feinfo) {
    set_has_feinfo();
  } else {
    clear_has_feinfo();
  }
}

// required .mimc.UCPacket packet = 2;
inline bool UCExchange::has_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCExchange::set_has_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCExchange::clear_has_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCExchange::clear_packet() {
  if (packet_ != NULL) packet_->::mimc::UCPacket::Clear();
  clear_has_packet();
}
inline const ::mimc::UCPacket& UCExchange::packet() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packet_ != NULL ? *packet_ : *default_instance().packet_;
#else
  return packet_ != NULL ? *packet_ : *default_instance_->packet_;
#endif
}
inline ::mimc::UCPacket* UCExchange::mutable_packet() {
  set_has_packet();
  if (packet_ == NULL) packet_ = new ::mimc::UCPacket;
  return packet_;
}
inline ::mimc::UCPacket* UCExchange::release_packet() {
  clear_has_packet();
  ::mimc::UCPacket* temp = packet_;
  packet_ = NULL;
  return temp;
}
inline void UCExchange::set_allocated_packet(::mimc::UCPacket* packet) {
  delete packet_;
  packet_ = packet;
  if (packet) {
    set_has_packet();
  } else {
    clear_has_packet();
  }
}

// required string package = 3;
inline bool UCExchange::has_package() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCExchange::set_has_package() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCExchange::clear_has_package() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCExchange::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& UCExchange::package() const {
  return *package_;
}
inline void UCExchange::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void UCExchange::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void UCExchange::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCExchange::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* UCExchange::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCExchange::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCJoin

// required .mimc.UCGroup group = 1;
inline bool UCJoin::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCJoin::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCJoin::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCJoin::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCJoin::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCJoin::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCJoin::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCJoin::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// UCJoinResp

// required .mimc.UCGroup group = 1;
inline bool UCJoinResp::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCJoinResp::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCJoinResp::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCJoinResp::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCJoinResp::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCJoinResp::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCJoinResp::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCJoinResp::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// required int32 code = 2;
inline bool UCJoinResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCJoinResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCJoinResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCJoinResp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 UCJoinResp::code() const {
  return code_;
}
inline void UCJoinResp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 3;
inline bool UCJoinResp::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCJoinResp::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCJoinResp::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCJoinResp::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& UCJoinResp::message() const {
  return *message_;
}
inline void UCJoinResp::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UCJoinResp::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UCJoinResp::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCJoinResp::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* UCJoinResp::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCJoinResp::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCQuit

// required .mimc.UCGroup group = 1;
inline bool UCQuit::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCQuit::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCQuit::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCQuit::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCQuit::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCQuit::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCQuit::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCQuit::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// UCQuitResp

// required .mimc.UCGroup group = 1;
inline bool UCQuitResp::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCQuitResp::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCQuitResp::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCQuitResp::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCQuitResp::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCQuitResp::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCQuitResp::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCQuitResp::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// required int32 code = 2;
inline bool UCQuitResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCQuitResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCQuitResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCQuitResp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 UCQuitResp::code() const {
  return code_;
}
inline void UCQuitResp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 3;
inline bool UCQuitResp::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCQuitResp::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCQuitResp::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCQuitResp::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& UCQuitResp::message() const {
  return *message_;
}
inline void UCQuitResp::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UCQuitResp::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UCQuitResp::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCQuitResp::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* UCQuitResp::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCQuitResp::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCPing

// repeated .mimc.UCGroup group = 1;
inline int UCPing::group_size() const {
  return group_.size();
}
inline void UCPing::clear_group() {
  group_.Clear();
}
inline const ::mimc::UCGroup& UCPing::group(int index) const {
  return group_.Get(index);
}
inline ::mimc::UCGroup* UCPing::mutable_group(int index) {
  return group_.Mutable(index);
}
inline ::mimc::UCGroup* UCPing::add_group() {
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >&
UCPing::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >*
UCPing::mutable_group() {
  return &group_;
}

// -------------------------------------------------------------------

// UCMessage

// required .mimc.UCGroup group = 1;
inline bool UCMessage::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCMessage::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCMessage::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCMessage::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCMessage::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCMessage::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCMessage::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCMessage::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// required bytes payload = 2;
inline bool UCMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& UCMessage::payload() const {
  return *payload_;
}
inline void UCMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UCMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void UCMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* UCMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sequence = 3;
inline bool UCMessage::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCMessage::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCMessage::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCMessage::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 UCMessage::sequence() const {
  return sequence_;
}
inline void UCMessage::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional bool isStore = 4;
inline bool UCMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UCMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UCMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UCMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool UCMessage::isstore() const {
  return isstore_;
}
inline void UCMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// optional .mimc.MIMCUser user = 5;
inline bool UCMessage::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UCMessage::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UCMessage::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UCMessage::clear_user() {
  if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
  clear_has_user();
}
inline const ::mimc::MIMCUser& UCMessage::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::mimc::MIMCUser* UCMessage::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mimc::MIMCUser;
  return user_;
}
inline ::mimc::MIMCUser* UCMessage::release_user() {
  clear_has_user();
  ::mimc::MIMCUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline void UCMessage::set_allocated_user(::mimc::MIMCUser* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional int64 timestamp = 6;
inline bool UCMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UCMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UCMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UCMessage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 UCMessage::timestamp() const {
  return timestamp_;
}
inline void UCMessage::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string packetId = 7;
inline bool UCMessage::has_packetid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UCMessage::set_has_packetid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UCMessage::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UCMessage::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& UCMessage::packetid() const {
  return *packetid_;
}
inline void UCMessage::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCMessage::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCMessage::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCMessage::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* UCMessage::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCMessage::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCPushMessage

// required .mimc.MIMCUser user = 1;
inline bool UCPushMessage::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCPushMessage::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCPushMessage::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCPushMessage::clear_user() {
  if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
  clear_has_user();
}
inline const ::mimc::MIMCUser& UCPushMessage::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::mimc::MIMCUser* UCPushMessage::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::mimc::MIMCUser;
  return user_;
}
inline ::mimc::MIMCUser* UCPushMessage::release_user() {
  clear_has_user();
  ::mimc::MIMCUser* temp = user_;
  user_ = NULL;
  return temp;
}
inline void UCPushMessage::set_allocated_user(::mimc::MIMCUser* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// repeated .mimc.UCGroup group = 2;
inline int UCPushMessage::group_size() const {
  return group_.size();
}
inline void UCPushMessage::clear_group() {
  group_.Clear();
}
inline const ::mimc::UCGroup& UCPushMessage::group(int index) const {
  return group_.Get(index);
}
inline ::mimc::UCGroup* UCPushMessage::mutable_group(int index) {
  return group_.Mutable(index);
}
inline ::mimc::UCGroup* UCPushMessage::add_group() {
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >&
UCPushMessage::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UCGroup >*
UCPushMessage::mutable_group() {
  return &group_;
}

// repeated bytes payloads = 3;
inline int UCPushMessage::payloads_size() const {
  return payloads_.size();
}
inline void UCPushMessage::clear_payloads() {
  payloads_.Clear();
}
inline const ::std::string& UCPushMessage::payloads(int index) const {
  return payloads_.Get(index);
}
inline ::std::string* UCPushMessage::mutable_payloads(int index) {
  return payloads_.Mutable(index);
}
inline void UCPushMessage::set_payloads(int index, const ::std::string& value) {
  payloads_.Mutable(index)->assign(value);
}
inline void UCPushMessage::set_payloads(int index, const char* value) {
  payloads_.Mutable(index)->assign(value);
}
inline void UCPushMessage::set_payloads(int index, const void* value, size_t size) {
  payloads_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCPushMessage::add_payloads() {
  return payloads_.Add();
}
inline void UCPushMessage::add_payloads(const ::std::string& value) {
  payloads_.Add()->assign(value);
}
inline void UCPushMessage::add_payloads(const char* value) {
  payloads_.Add()->assign(value);
}
inline void UCPushMessage::add_payloads(const void* value, size_t size) {
  payloads_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UCPushMessage::payloads() const {
  return payloads_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UCPushMessage::mutable_payloads() {
  return &payloads_;
}

// optional bool isStore = 4;
inline bool UCPushMessage::has_isstore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UCPushMessage::set_has_isstore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UCPushMessage::clear_has_isstore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UCPushMessage::clear_isstore() {
  isstore_ = false;
  clear_has_isstore();
}
inline bool UCPushMessage::isstore() const {
  return isstore_;
}
inline void UCPushMessage::set_isstore(bool value) {
  set_has_isstore();
  isstore_ = value;
}

// optional int64 timestamp = 5;
inline bool UCPushMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UCPushMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UCPushMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UCPushMessage::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 UCPushMessage::timestamp() const {
  return timestamp_;
}
inline void UCPushMessage::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string packetId = 6;
inline bool UCPushMessage::has_packetid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UCPushMessage::set_has_packetid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UCPushMessage::clear_has_packetid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UCPushMessage::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& UCPushMessage::packetid() const {
  return *packetid_;
}
inline void UCPushMessage::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCPushMessage::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void UCPushMessage::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UCPushMessage::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* UCPushMessage::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UCPushMessage::set_allocated_packetid(::std::string* packetid) {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (packetid) {
    set_has_packetid();
    packetid_ = packetid;
  } else {
    clear_has_packetid();
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UCMessageList

// required .mimc.UCGroup group = 1;
inline bool UCMessageList::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCMessageList::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCMessageList::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCMessageList::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCMessageList::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCMessageList::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCMessageList::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCMessageList::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// repeated .mimc.UCMessage message = 2;
inline int UCMessageList::message_size() const {
  return message_.size();
}
inline void UCMessageList::clear_message() {
  message_.Clear();
}
inline const ::mimc::UCMessage& UCMessageList::message(int index) const {
  return message_.Get(index);
}
inline ::mimc::UCMessage* UCMessageList::mutable_message(int index) {
  return message_.Mutable(index);
}
inline ::mimc::UCMessage* UCMessageList::add_message() {
  return message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mimc::UCMessage >&
UCMessageList::message() const {
  return message_;
}
inline ::google::protobuf::RepeatedPtrField< ::mimc::UCMessage >*
UCMessageList::mutable_message() {
  return &message_;
}

// optional int64 maxSequence = 3;
inline bool UCMessageList::has_maxsequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UCMessageList::set_has_maxsequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UCMessageList::clear_has_maxsequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UCMessageList::clear_maxsequence() {
  maxsequence_ = GOOGLE_LONGLONG(0);
  clear_has_maxsequence();
}
inline ::google::protobuf::int64 UCMessageList::maxsequence() const {
  return maxsequence_;
}
inline void UCMessageList::set_maxsequence(::google::protobuf::int64 value) {
  set_has_maxsequence();
  maxsequence_ = value;
}

// -------------------------------------------------------------------

// UCSequenceAck

// required .mimc.UCGroup group = 1;
inline bool UCSequenceAck::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCSequenceAck::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCSequenceAck::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCSequenceAck::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCSequenceAck::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCSequenceAck::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCSequenceAck::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCSequenceAck::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// required int64 sequence = 2;
inline bool UCSequenceAck::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCSequenceAck::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCSequenceAck::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCSequenceAck::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 UCSequenceAck::sequence() const {
  return sequence_;
}
inline void UCSequenceAck::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// -------------------------------------------------------------------

// UCDismiss

// required .mimc.UCGroup group = 1;
inline bool UCDismiss::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCDismiss::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCDismiss::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCDismiss::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCDismiss::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCDismiss::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCDismiss::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCDismiss::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// UCQueryOnlineUsers

// required .mimc.UCGroup group = 1;
inline bool UCQueryOnlineUsers::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCQueryOnlineUsers::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCQueryOnlineUsers::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCQueryOnlineUsers::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCQueryOnlineUsers::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCQueryOnlineUsers::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCQueryOnlineUsers::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCQueryOnlineUsers::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// UCQueryOnlineUsersResp

// required .mimc.UCGroup group = 1;
inline bool UCQueryOnlineUsersResp::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UCQueryOnlineUsersResp::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UCQueryOnlineUsersResp::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UCQueryOnlineUsersResp::clear_group() {
  if (group_ != NULL) group_->::mimc::UCGroup::Clear();
  clear_has_group();
}
inline const ::mimc::UCGroup& UCQueryOnlineUsersResp::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::mimc::UCGroup* UCQueryOnlineUsersResp::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::mimc::UCGroup;
  return group_;
}
inline ::mimc::UCGroup* UCQueryOnlineUsersResp::release_group() {
  clear_has_group();
  ::mimc::UCGroup* temp = group_;
  group_ = NULL;
  return temp;
}
inline void UCQueryOnlineUsersResp::set_allocated_group(::mimc::UCGroup* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// required int64 userCount = 2;
inline bool UCQueryOnlineUsersResp::has_usercount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UCQueryOnlineUsersResp::set_has_usercount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UCQueryOnlineUsersResp::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UCQueryOnlineUsersResp::clear_usercount() {
  usercount_ = GOOGLE_LONGLONG(0);
  clear_has_usercount();
}
inline ::google::protobuf::int64 UCQueryOnlineUsersResp::usercount() const {
  return usercount_;
}
inline void UCQueryOnlineUsersResp::set_usercount(::google::protobuf::int64 value) {
  set_has_usercount();
  usercount_ = value;
}

// -------------------------------------------------------------------

// FeInfo

// optional string fe_src_ip = 1;
inline bool FeInfo::has_fe_src_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeInfo::set_has_fe_src_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeInfo::clear_has_fe_src_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeInfo::clear_fe_src_ip() {
  if (fe_src_ip_ != &::google::protobuf::internal::kEmptyString) {
    fe_src_ip_->clear();
  }
  clear_has_fe_src_ip();
}
inline const ::std::string& FeInfo::fe_src_ip() const {
  return *fe_src_ip_;
}
inline void FeInfo::set_fe_src_ip(const ::std::string& value) {
  set_has_fe_src_ip();
  if (fe_src_ip_ == &::google::protobuf::internal::kEmptyString) {
    fe_src_ip_ = new ::std::string;
  }
  fe_src_ip_->assign(value);
}
inline void FeInfo::set_fe_src_ip(const char* value) {
  set_has_fe_src_ip();
  if (fe_src_ip_ == &::google::protobuf::internal::kEmptyString) {
    fe_src_ip_ = new ::std::string;
  }
  fe_src_ip_->assign(value);
}
inline void FeInfo::set_fe_src_ip(const char* value, size_t size) {
  set_has_fe_src_ip();
  if (fe_src_ip_ == &::google::protobuf::internal::kEmptyString) {
    fe_src_ip_ = new ::std::string;
  }
  fe_src_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeInfo::mutable_fe_src_ip() {
  set_has_fe_src_ip();
  if (fe_src_ip_ == &::google::protobuf::internal::kEmptyString) {
    fe_src_ip_ = new ::std::string;
  }
  return fe_src_ip_;
}
inline ::std::string* FeInfo::release_fe_src_ip() {
  clear_has_fe_src_ip();
  if (fe_src_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fe_src_ip_;
    fe_src_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeInfo::set_allocated_fe_src_ip(::std::string* fe_src_ip) {
  if (fe_src_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete fe_src_ip_;
  }
  if (fe_src_ip) {
    set_has_fe_src_ip();
    fe_src_ip_ = fe_src_ip;
  } else {
    clear_has_fe_src_ip();
    fe_src_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fe_src_port = 2;
inline bool FeInfo::has_fe_src_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeInfo::set_has_fe_src_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeInfo::clear_has_fe_src_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeInfo::clear_fe_src_port() {
  fe_src_port_ = 0;
  clear_has_fe_src_port();
}
inline ::google::protobuf::int32 FeInfo::fe_src_port() const {
  return fe_src_port_;
}
inline void FeInfo::set_fe_src_port(::google::protobuf::int32 value) {
  set_has_fe_src_port();
  fe_src_port_ = value;
}

// optional int32 fe_thread_id = 3;
inline bool FeInfo::has_fe_thread_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeInfo::set_has_fe_thread_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeInfo::clear_has_fe_thread_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeInfo::clear_fe_thread_id() {
  fe_thread_id_ = 0;
  clear_has_fe_thread_id();
}
inline ::google::protobuf::int32 FeInfo::fe_thread_id() const {
  return fe_thread_id_;
}
inline void FeInfo::set_fe_thread_id(::google::protobuf::int32 value) {
  set_has_fe_thread_id();
  fe_thread_id_ = value;
}

// optional uint64 fe_ucid = 4;
inline bool FeInfo::has_fe_ucid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeInfo::set_has_fe_ucid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeInfo::clear_has_fe_ucid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeInfo::clear_fe_ucid() {
  fe_ucid_ = GOOGLE_ULONGLONG(0);
  clear_has_fe_ucid();
}
inline ::google::protobuf::uint64 FeInfo::fe_ucid() const {
  return fe_ucid_;
}
inline void FeInfo::set_fe_ucid(::google::protobuf::uint64 value) {
  set_has_fe_ucid();
  fe_ucid_ = value;
}

// optional uint64 fe_sid = 5;
inline bool FeInfo::has_fe_sid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeInfo::set_has_fe_sid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeInfo::clear_has_fe_sid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeInfo::clear_fe_sid() {
  fe_sid_ = GOOGLE_ULONGLONG(0);
  clear_has_fe_sid();
}
inline ::google::protobuf::uint64 FeInfo::fe_sid() const {
  return fe_sid_;
}
inline void FeInfo::set_fe_sid(::google::protobuf::uint64 value) {
  set_has_fe_sid();
  fe_sid_ = value;
}

// optional uint64 fe_seqno = 6;
inline bool FeInfo::has_fe_seqno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeInfo::set_has_fe_seqno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeInfo::clear_has_fe_seqno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeInfo::clear_fe_seqno() {
  fe_seqno_ = GOOGLE_ULONGLONG(0);
  clear_has_fe_seqno();
}
inline ::google::protobuf::uint64 FeInfo::fe_seqno() const {
  return fe_seqno_;
}
inline void FeInfo::set_fe_seqno(::google::protobuf::uint64 value) {
  set_has_fe_seqno();
  fe_seqno_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mimc_2eproto__INCLUDED
