// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rts_signal.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mimc/rts_signal.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace mimc {

void protobuf_ShutdownFile_rts_5fsignal_2eproto() {
  delete UserInfo::default_instance_;
  delete CallInfo::default_instance_;
  delete XmqRTSExchange::default_instance_;
  delete RTSMessage::default_instance_;
  delete CreateRequest::default_instance_;
  delete InviteRequest::default_instance_;
  delete InviteResponse::default_instance_;
  delete CreateResponse::default_instance_;
  delete UpdateRequest::default_instance_;
  delete UpdateResponse::default_instance_;
  delete PingRequest::default_instance_;
  delete PingResponse::default_instance_;
  delete ByeRequest::default_instance_;
  delete ByeResponse::default_instance_;
  delete CreateChannelRequest::default_instance_;
  delete CreateChannelResponse::default_instance_;
  delete JoinChannelRequest::default_instance_;
  delete JoinChannelResponse::default_instance_;
  delete LeaveChannelRequest::default_instance_;
  delete LeaveChannelResponse::default_instance_;
  delete UserJoinNotification::default_instance_;
  delete UserLeaveNotification::default_instance_;
  delete UpdateCallInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_rts_5fsignal_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_rts_5fsignal_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::mimc::protobuf_AddDesc_rts_5fdata_2eproto();
  UserInfo::default_instance_ = new UserInfo();
  CallInfo::default_instance_ = new CallInfo();
  XmqRTSExchange::default_instance_ = new XmqRTSExchange();
  RTSMessage::default_instance_ = new RTSMessage();
  CreateRequest::default_instance_ = new CreateRequest();
  InviteRequest::default_instance_ = new InviteRequest();
  InviteResponse::default_instance_ = new InviteResponse();
  CreateResponse::default_instance_ = new CreateResponse();
  UpdateRequest::default_instance_ = new UpdateRequest();
  UpdateResponse::default_instance_ = new UpdateResponse();
  PingRequest::default_instance_ = new PingRequest();
  PingResponse::default_instance_ = new PingResponse();
  ByeRequest::default_instance_ = new ByeRequest();
  ByeResponse::default_instance_ = new ByeResponse();
  CreateChannelRequest::default_instance_ = new CreateChannelRequest();
  CreateChannelResponse::default_instance_ = new CreateChannelResponse();
  JoinChannelRequest::default_instance_ = new JoinChannelRequest();
  JoinChannelResponse::default_instance_ = new JoinChannelResponse();
  LeaveChannelRequest::default_instance_ = new LeaveChannelRequest();
  LeaveChannelResponse::default_instance_ = new LeaveChannelResponse();
  UserJoinNotification::default_instance_ = new UserJoinNotification();
  UserLeaveNotification::default_instance_ = new UserLeaveNotification();
  UpdateCallInfo::default_instance_ = new UpdateCallInfo();
  UserInfo::default_instance_->InitAsDefaultInstance();
  CallInfo::default_instance_->InitAsDefaultInstance();
  XmqRTSExchange::default_instance_->InitAsDefaultInstance();
  RTSMessage::default_instance_->InitAsDefaultInstance();
  CreateRequest::default_instance_->InitAsDefaultInstance();
  InviteRequest::default_instance_->InitAsDefaultInstance();
  InviteResponse::default_instance_->InitAsDefaultInstance();
  CreateResponse::default_instance_->InitAsDefaultInstance();
  UpdateRequest::default_instance_->InitAsDefaultInstance();
  UpdateResponse::default_instance_->InitAsDefaultInstance();
  PingRequest::default_instance_->InitAsDefaultInstance();
  PingResponse::default_instance_->InitAsDefaultInstance();
  ByeRequest::default_instance_->InitAsDefaultInstance();
  ByeResponse::default_instance_->InitAsDefaultInstance();
  CreateChannelRequest::default_instance_->InitAsDefaultInstance();
  CreateChannelResponse::default_instance_->InitAsDefaultInstance();
  JoinChannelRequest::default_instance_->InitAsDefaultInstance();
  JoinChannelResponse::default_instance_->InitAsDefaultInstance();
  LeaveChannelRequest::default_instance_->InitAsDefaultInstance();
  LeaveChannelResponse::default_instance_->InitAsDefaultInstance();
  UserJoinNotification::default_instance_->InitAsDefaultInstance();
  UserLeaveNotification::default_instance_->InitAsDefaultInstance();
  UpdateCallInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_rts_5fsignal_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_rts_5fsignal_2eproto_once_);
void protobuf_AddDesc_rts_5fsignal_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_rts_5fsignal_2eproto_once_,
                 &protobuf_AddDesc_rts_5fsignal_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_rts_5fsignal_2eproto {
  StaticDescriptorInitializer_rts_5fsignal_2eproto() {
    protobuf_AddDesc_rts_5fsignal_2eproto();
  }
} static_descriptor_initializer_rts_5fsignal_2eproto_;
#endif
bool RTSMessageType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

bool StreamDataType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool RTSResult_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 99:
      return true;
    default:
      return false;
  }
}

bool CallStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool UpdateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int UserInfo::kUuidFieldNumber;
const int UserInfo::kResourceFieldNumber;
const int UserInfo::kAppIdFieldNumber;
const int UserInfo::kAppAccountFieldNumber;
const int UserInfo::kIntranetIpFieldNumber;
const int UserInfo::kIntranetPortFieldNumber;
const int UserInfo::kInternetIpFieldNumber;
const int UserInfo::kInternetPortFieldNumber;
const int UserInfo::kRelayIpFieldNumber;
const int UserInfo::kRelayPortFieldNumber;
const int UserInfo::kConnIdFieldNumber;
const int UserInfo::kIsTcpFieldNumber;
#endif  // !_MSC_VER

UserInfo::UserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserInfo::InitAsDefaultInstance() {
}

UserInfo::UserInfo(const UserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserInfo::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = GOOGLE_LONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  appid_ = GOOGLE_LONGLONG(0);
  appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  intranetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  intranetport_ = 0u;
  internetip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  internetport_ = 0u;
  relayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  relayport_ = 0u;
  connid_ = GOOGLE_ULONGLONG(0);
  is_tcp_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserInfo::~UserInfo() {
  SharedDtor();
}

void UserInfo::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete appaccount_;
  }
  if (intranetip_ != &::google::protobuf::internal::kEmptyString) {
    delete intranetip_;
  }
  if (internetip_ != &::google::protobuf::internal::kEmptyString) {
    delete internetip_;
  }
  if (relayip_ != &::google::protobuf::internal::kEmptyString) {
    delete relayip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserInfo& UserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UserInfo* UserInfo::default_instance_ = NULL;

UserInfo* UserInfo::New() const {
  return new UserInfo;
}

void UserInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uuid_ = GOOGLE_LONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    appid_ = GOOGLE_LONGLONG(0);
    if (has_appaccount()) {
      if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
        appaccount_->clear();
      }
    }
    if (has_intranetip()) {
      if (intranetip_ != &::google::protobuf::internal::kEmptyString) {
        intranetip_->clear();
      }
    }
    intranetport_ = 0u;
    if (has_internetip()) {
      if (internetip_ != &::google::protobuf::internal::kEmptyString) {
        internetip_->clear();
      }
    }
    internetport_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_relayip()) {
      if (relayip_ != &::google::protobuf::internal::kEmptyString) {
        relayip_->clear();
      }
    }
    relayport_ = 0u;
    connid_ = GOOGLE_ULONGLONG(0);
    is_tcp_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_resource;
        break;
      }

      // optional string resource = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_appId;
        break;
      }

      // optional int64 appId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_appAccount;
        break;
      }

      // optional string appAccount = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_appAccount:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_appaccount()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_intranetIp;
        break;
      }

      // optional string intranetIp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_intranetIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_intranetip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_intranetPort;
        break;
      }

      // optional uint32 intranetPort = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_intranetPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &intranetport_)));
          set_has_intranetport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_internetIp;
        break;
      }

      // optional string internetIp = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_internetIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_internetip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_internetPort;
        break;
      }

      // optional uint32 internetPort = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_internetPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &internetport_)));
          set_has_internetport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_relayIp;
        break;
      }

      // optional string relayIp = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_relayIp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_relayip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_relayPort;
        break;
      }

      // optional uint32 relayPort = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_relayPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &relayport_)));
          set_has_relayport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_connId;
        break;
      }

      // optional uint64 connId = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_connId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &connid_)));
          set_has_connid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_is_tcp;
        break;
      }

      // optional bool is_tcp = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_tcp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_tcp_)));
          set_has_is_tcp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uuid(), output);
  }

  // optional string resource = 2;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->resource(), output);
  }

  // optional int64 appId = 3;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->appid(), output);
  }

  // optional string appAccount = 4;
  if (has_appaccount()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->appaccount(), output);
  }

  // optional string intranetIp = 5;
  if (has_intranetip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->intranetip(), output);
  }

  // optional uint32 intranetPort = 6;
  if (has_intranetport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->intranetport(), output);
  }

  // optional string internetIp = 7;
  if (has_internetip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->internetip(), output);
  }

  // optional uint32 internetPort = 8;
  if (has_internetport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->internetport(), output);
  }

  // optional string relayIp = 9;
  if (has_relayip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->relayip(), output);
  }

  // optional uint32 relayPort = 10;
  if (has_relayport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->relayport(), output);
  }

  // optional uint64 connId = 11;
  if (has_connid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->connid(), output);
  }

  // optional bool is_tcp = 12;
  if (has_is_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->is_tcp(), output);
  }

}

int UserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uuid());
    }

    // optional string resource = 2;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional int64 appId = 3;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->appid());
    }

    // optional string appAccount = 4;
    if (has_appaccount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->appaccount());
    }

    // optional string intranetIp = 5;
    if (has_intranetip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->intranetip());
    }

    // optional uint32 intranetPort = 6;
    if (has_intranetport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->intranetport());
    }

    // optional string internetIp = 7;
    if (has_internetip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->internetip());
    }

    // optional uint32 internetPort = 8;
    if (has_internetport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->internetport());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string relayIp = 9;
    if (has_relayip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->relayip());
    }

    // optional uint32 relayPort = 10;
    if (has_relayport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->relayport());
    }

    // optional uint64 connId = 11;
    if (has_connid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->connid());
    }

    // optional bool is_tcp = 12;
    if (has_is_tcp()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserInfo*>(&from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_appaccount()) {
      set_appaccount(from.appaccount());
    }
    if (from.has_intranetip()) {
      set_intranetip(from.intranetip());
    }
    if (from.has_intranetport()) {
      set_intranetport(from.intranetport());
    }
    if (from.has_internetip()) {
      set_internetip(from.internetip());
    }
    if (from.has_internetport()) {
      set_internetport(from.internetport());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_relayip()) {
      set_relayip(from.relayip());
    }
    if (from.has_relayport()) {
      set_relayport(from.relayport());
    }
    if (from.has_connid()) {
      set_connid(from.connid());
    }
    if (from.has_is_tcp()) {
      set_is_tcp(from.is_tcp());
    }
  }
}

void UserInfo::CopyFrom(const UserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {

  return true;
}

void UserInfo::Swap(UserInfo* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(appid_, other->appid_);
    std::swap(appaccount_, other->appaccount_);
    std::swap(intranetip_, other->intranetip_);
    std::swap(intranetport_, other->intranetport_);
    std::swap(internetip_, other->internetip_);
    std::swap(internetport_, other->internetport_);
    std::swap(relayip_, other->relayip_);
    std::swap(relayport_, other->relayport_);
    std::swap(connid_, other->connid_);
    std::swap(is_tcp_, other->is_tcp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserInfo::GetTypeName() const {
  return "mimc.UserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CallInfo::kCallIdFieldNumber;
const int CallInfo::kCallTypeFieldNumber;
const int CallInfo::kCallStatusFieldNumber;
const int CallInfo::kCreatorIdFieldNumber;
const int CallInfo::kCreatorResourceFieldNumber;
const int CallInfo::kMembersFieldNumber;
const int CallInfo::kCallKeyFieldNumber;
const int CallInfo::kExtraFieldNumber;
#endif  // !_MSC_VER

CallInfo::CallInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CallInfo::InitAsDefaultInstance() {
}

CallInfo::CallInfo(const CallInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CallInfo::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  calltype_ = 1;
  callstatus_ = 1;
  creatorid_ = GOOGLE_LONGLONG(0);
  creatorresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CallInfo::~CallInfo() {
  SharedDtor();
}

void CallInfo::SharedDtor() {
  if (creatorresource_ != &::google::protobuf::internal::kEmptyString) {
    delete creatorresource_;
  }
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CallInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CallInfo& CallInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

CallInfo* CallInfo::default_instance_ = NULL;

CallInfo* CallInfo::New() const {
  return new CallInfo;
}

void CallInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    calltype_ = 1;
    callstatus_ = 1;
    creatorid_ = GOOGLE_LONGLONG(0);
    if (has_creatorresource()) {
      if (creatorresource_ != &::google::protobuf::internal::kEmptyString) {
        creatorresource_->clear();
      }
    }
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    if (has_extra()) {
      if (extra_ != &::google::protobuf::internal::kEmptyString) {
        extra_->clear();
      }
    }
  }
  members_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CallInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_callType;
        break;
      }

      // optional .mimc.CallType callType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::CallType_IsValid(value)) {
            set_calltype(static_cast< ::mimc::CallType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_callStatus;
        break;
      }

      // optional .mimc.CallStatus callStatus = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callStatus:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::CallStatus_IsValid(value)) {
            set_callstatus(static_cast< ::mimc::CallStatus >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_creatorId;
        break;
      }

      // optional int64 creatorId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_creatorId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &creatorid_)));
          set_has_creatorid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_creatorResource;
        break;
      }

      // optional string creatorResource = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_creatorResource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_creatorresource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_members;
        break;
      }

      // repeated .mimc.UserInfo members = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_members:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_members()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_members;
        if (input->ExpectTag(58)) goto parse_callKey;
        break;
      }

      // optional string callKey = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_extra;
        break;
      }

      // optional bytes extra = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extra:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CallInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional .mimc.CallType callType = 2;
  if (has_calltype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->calltype(), output);
  }

  // optional .mimc.CallStatus callStatus = 3;
  if (has_callstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->callstatus(), output);
  }

  // optional int64 creatorId = 4;
  if (has_creatorid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->creatorid(), output);
  }

  // optional string creatorResource = 5;
  if (has_creatorresource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->creatorresource(), output);
  }

  // repeated .mimc.UserInfo members = 6;
  for (int i = 0; i < this->members_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->members(i), output);
  }

  // optional string callKey = 7;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->callkey(), output);
  }

  // optional bytes extra = 8;
  if (has_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->extra(), output);
  }

}

int CallInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional .mimc.CallType callType = 2;
    if (has_calltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->calltype());
    }

    // optional .mimc.CallStatus callStatus = 3;
    if (has_callstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->callstatus());
    }

    // optional int64 creatorId = 4;
    if (has_creatorid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->creatorid());
    }

    // optional string creatorResource = 5;
    if (has_creatorresource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->creatorresource());
    }

    // optional string callKey = 7;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional bytes extra = 8;
    if (has_extra()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra());
    }

  }
  // repeated .mimc.UserInfo members = 6;
  total_size += 1 * this->members_size();
  for (int i = 0; i < this->members_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->members(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CallInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CallInfo*>(&from));
}

void CallInfo::MergeFrom(const CallInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  members_.MergeFrom(from.members_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_calltype()) {
      set_calltype(from.calltype());
    }
    if (from.has_callstatus()) {
      set_callstatus(from.callstatus());
    }
    if (from.has_creatorid()) {
      set_creatorid(from.creatorid());
    }
    if (from.has_creatorresource()) {
      set_creatorresource(from.creatorresource());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_extra()) {
      set_extra(from.extra());
    }
  }
}

void CallInfo::CopyFrom(const CallInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallInfo::IsInitialized() const {

  return true;
}

void CallInfo::Swap(CallInfo* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(calltype_, other->calltype_);
    std::swap(callstatus_, other->callstatus_);
    std::swap(creatorid_, other->creatorid_);
    std::swap(creatorresource_, other->creatorresource_);
    members_.Swap(&other->members_);
    std::swap(callkey_, other->callkey_);
    std::swap(extra_, other->extra_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CallInfo::GetTypeName() const {
  return "mimc.CallInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int XmqRTSExchange::kPacketIdFieldNumber;
const int XmqRTSExchange::kPackageFieldNumber;
const int XmqRTSExchange::kToUuidFieldNumber;
const int XmqRTSExchange::kToResourceFieldNumber;
const int XmqRTSExchange::kMessageFieldNumber;
const int XmqRTSExchange::kTimestampFieldNumber;
#endif  // !_MSC_VER

XmqRTSExchange::XmqRTSExchange()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void XmqRTSExchange::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  message_ = const_cast< ::mimc::RTSMessage*>(
      ::mimc::RTSMessage::internal_default_instance());
#else
  message_ = const_cast< ::mimc::RTSMessage*>(&::mimc::RTSMessage::default_instance());
#endif
}

XmqRTSExchange::XmqRTSExchange(const XmqRTSExchange& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void XmqRTSExchange::SharedCtor() {
  _cached_size_ = 0;
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  touuid_ = GOOGLE_LONGLONG(0);
  toresource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  message_ = NULL;
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XmqRTSExchange::~XmqRTSExchange() {
  SharedDtor();
}

void XmqRTSExchange::SharedDtor() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (toresource_ != &::google::protobuf::internal::kEmptyString) {
    delete toresource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete message_;
  }
}

void XmqRTSExchange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const XmqRTSExchange& XmqRTSExchange::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

XmqRTSExchange* XmqRTSExchange::default_instance_ = NULL;

XmqRTSExchange* XmqRTSExchange::New() const {
  return new XmqRTSExchange;
}

void XmqRTSExchange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
    if (has_package()) {
      if (package_ != &::google::protobuf::internal::kEmptyString) {
        package_->clear();
      }
    }
    touuid_ = GOOGLE_LONGLONG(0);
    if (has_toresource()) {
      if (toresource_ != &::google::protobuf::internal::kEmptyString) {
        toresource_->clear();
      }
    }
    if (has_message()) {
      if (message_ != NULL) message_->::mimc::RTSMessage::Clear();
    }
    timestamp_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool XmqRTSExchange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string packetId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_package;
        break;
      }

      // optional string package = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_toUuid;
        break;
      }

      // optional int64 toUuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_toUuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &touuid_)));
          set_has_touuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_toResource;
        break;
      }

      // optional string toResource = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_toResource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_toresource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_message;
        break;
      }

      // optional .mimc.RTSMessage message = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void XmqRTSExchange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string packetId = 1;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->packetid(), output);
  }

  // optional string package = 2;
  if (has_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->package(), output);
  }

  // optional int64 toUuid = 3;
  if (has_touuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->touuid(), output);
  }

  // optional string toResource = 4;
  if (has_toresource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->toresource(), output);
  }

  // optional .mimc.RTSMessage message = 5;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->message(), output);
  }

  // optional int64 timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->timestamp(), output);
  }

}

int XmqRTSExchange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string packetId = 1;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

    // optional string package = 2;
    if (has_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package());
    }

    // optional int64 toUuid = 3;
    if (has_touuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->touuid());
    }

    // optional string toResource = 4;
    if (has_toresource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->toresource());
    }

    // optional .mimc.RTSMessage message = 5;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message());
    }

    // optional int64 timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XmqRTSExchange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const XmqRTSExchange*>(&from));
}

void XmqRTSExchange::MergeFrom(const XmqRTSExchange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
    if (from.has_package()) {
      set_package(from.package());
    }
    if (from.has_touuid()) {
      set_touuid(from.touuid());
    }
    if (from.has_toresource()) {
      set_toresource(from.toresource());
    }
    if (from.has_message()) {
      mutable_message()->::mimc::RTSMessage::MergeFrom(from.message());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void XmqRTSExchange::CopyFrom(const XmqRTSExchange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XmqRTSExchange::IsInitialized() const {

  return true;
}

void XmqRTSExchange::Swap(XmqRTSExchange* other) {
  if (other != this) {
    std::swap(packetid_, other->packetid_);
    std::swap(package_, other->package_);
    std::swap(touuid_, other->touuid_);
    std::swap(toresource_, other->toresource_);
    std::swap(message_, other->message_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string XmqRTSExchange::GetTypeName() const {
  return "mimc.XmqRTSExchange";
}


// ===================================================================

#ifndef _MSC_VER
const int RTSMessage::kTypeFieldNumber;
const int RTSMessage::kCallIdFieldNumber;
const int RTSMessage::kCallTypeFieldNumber;
const int RTSMessage::kUuidFieldNumber;
const int RTSMessage::kResourceFieldNumber;
const int RTSMessage::kPayloadFieldNumber;
const int RTSMessage::kRegionBucketFieldNumber;
#endif  // !_MSC_VER

RTSMessage::RTSMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RTSMessage::InitAsDefaultInstance() {
}

RTSMessage::RTSMessage(const RTSMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RTSMessage::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  callid_ = GOOGLE_ULONGLONG(0);
  calltype_ = 1;
  uuid_ = GOOGLE_LONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  region_bucket_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RTSMessage::~RTSMessage() {
  SharedDtor();
}

void RTSMessage::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RTSMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RTSMessage& RTSMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

RTSMessage* RTSMessage::default_instance_ = NULL;

RTSMessage* RTSMessage::New() const {
  return new RTSMessage;
}

void RTSMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    callid_ = GOOGLE_ULONGLONG(0);
    calltype_ = 1;
    uuid_ = GOOGLE_LONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    region_bucket_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RTSMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSMessageType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSMessageType_IsValid(value)) {
            set_type(static_cast< ::mimc::RTSMessageType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_callId;
        break;
      }

      // optional uint64 callId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_callType;
        break;
      }

      // optional .mimc.CallType callType = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::CallType_IsValid(value)) {
            set_calltype(static_cast< ::mimc::CallType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_uuid;
        break;
      }

      // optional int64 uuid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_resource;
        break;
      }

      // optional string resource = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_payload;
        break;
      }

      // optional bytes payload = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_region_bucket;
        break;
      }

      // optional int64 region_bucket = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_region_bucket:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &region_bucket_)));
          set_has_region_bucket();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RTSMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSMessageType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 callId = 2;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->callid(), output);
  }

  // optional .mimc.CallType callType = 3;
  if (has_calltype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->calltype(), output);
  }

  // optional int64 uuid = 4;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->uuid(), output);
  }

  // optional string resource = 5;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->resource(), output);
  }

  // optional bytes payload = 6;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->payload(), output);
  }

  // optional int64 region_bucket = 7;
  if (has_region_bucket()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->region_bucket(), output);
  }

}

int RTSMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSMessageType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 callId = 2;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional .mimc.CallType callType = 3;
    if (has_calltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->calltype());
    }

    // optional int64 uuid = 4;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uuid());
    }

    // optional string resource = 5;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional bytes payload = 6;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional int64 region_bucket = 7;
    if (has_region_bucket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->region_bucket());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RTSMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RTSMessage*>(&from));
}

void RTSMessage::MergeFrom(const RTSMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_calltype()) {
      set_calltype(from.calltype());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_region_bucket()) {
      set_region_bucket(from.region_bucket());
    }
  }
}

void RTSMessage::CopyFrom(const RTSMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RTSMessage::IsInitialized() const {

  return true;
}

void RTSMessage::Swap(RTSMessage* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(callid_, other->callid_);
    std::swap(calltype_, other->calltype_);
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(payload_, other->payload_);
    std::swap(region_bucket_, other->region_bucket_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RTSMessage::GetTypeName() const {
  return "mimc.RTSMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRequest::kStreamTypeFieldNumber;
const int CreateRequest::kMembersFieldNumber;
const int CreateRequest::kSdpFieldNumber;
const int CreateRequest::kAppContentFieldNumber;
#endif  // !_MSC_VER

CreateRequest::CreateRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRequest::InitAsDefaultInstance() {
}

CreateRequest::CreateRequest(const CreateRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRequest::SharedCtor() {
  _cached_size_ = 0;
  streamtype_ = 1;
  sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRequest::~CreateRequest() {
  SharedDtor();
}

void CreateRequest::SharedDtor() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete appcontent_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRequest& CreateRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

CreateRequest* CreateRequest::default_instance_ = NULL;

CreateRequest* CreateRequest::New() const {
  return new CreateRequest;
}

void CreateRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    streamtype_ = 1;
    if (has_sdp()) {
      if (sdp_ != &::google::protobuf::internal::kEmptyString) {
        sdp_->clear();
      }
    }
    if (has_appcontent()) {
      if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
        appcontent_->clear();
      }
    }
  }
  members_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.StreamDataType streamType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::StreamDataType_IsValid(value)) {
            set_streamtype(static_cast< ::mimc::StreamDataType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_members;
        break;
      }

      // repeated .mimc.UserInfo members = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_members:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_members()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_members;
        if (input->ExpectTag(26)) goto parse_sdp;
        break;
      }

      // optional string sdp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sdp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_appContent;
        break;
      }

      // optional bytes appContent = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_appContent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_appcontent()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.StreamDataType streamType = 1;
  if (has_streamtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->streamtype(), output);
  }

  // repeated .mimc.UserInfo members = 2;
  for (int i = 0; i < this->members_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->members(i), output);
  }

  // optional string sdp = 3;
  if (has_sdp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->sdp(), output);
  }

  // optional bytes appContent = 4;
  if (has_appcontent()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->appcontent(), output);
  }

}

int CreateRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.StreamDataType streamType = 1;
    if (has_streamtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->streamtype());
    }

    // optional string sdp = 3;
    if (has_sdp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sdp());
    }

    // optional bytes appContent = 4;
    if (has_appcontent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->appcontent());
    }

  }
  // repeated .mimc.UserInfo members = 2;
  total_size += 1 * this->members_size();
  for (int i = 0; i < this->members_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->members(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRequest*>(&from));
}

void CreateRequest::MergeFrom(const CreateRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  members_.MergeFrom(from.members_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_streamtype()) {
      set_streamtype(from.streamtype());
    }
    if (from.has_sdp()) {
      set_sdp(from.sdp());
    }
    if (from.has_appcontent()) {
      set_appcontent(from.appcontent());
    }
  }
}

void CreateRequest::CopyFrom(const CreateRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRequest::IsInitialized() const {

  return true;
}

void CreateRequest::Swap(CreateRequest* other) {
  if (other != this) {
    std::swap(streamtype_, other->streamtype_);
    members_.Swap(&other->members_);
    std::swap(sdp_, other->sdp_);
    std::swap(appcontent_, other->appcontent_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRequest::GetTypeName() const {
  return "mimc.CreateRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int InviteRequest::kStreamTypeFieldNumber;
const int InviteRequest::kMembersFieldNumber;
const int InviteRequest::kSdpFieldNumber;
const int InviteRequest::kAppContentFieldNumber;
#endif  // !_MSC_VER

InviteRequest::InviteRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void InviteRequest::InitAsDefaultInstance() {
}

InviteRequest::InviteRequest(const InviteRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void InviteRequest::SharedCtor() {
  _cached_size_ = 0;
  streamtype_ = 1;
  sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  appcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InviteRequest::~InviteRequest() {
  SharedDtor();
}

void InviteRequest::SharedDtor() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete appcontent_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InviteRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InviteRequest& InviteRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

InviteRequest* InviteRequest::default_instance_ = NULL;

InviteRequest* InviteRequest::New() const {
  return new InviteRequest;
}

void InviteRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    streamtype_ = 1;
    if (has_sdp()) {
      if (sdp_ != &::google::protobuf::internal::kEmptyString) {
        sdp_->clear();
      }
    }
    if (has_appcontent()) {
      if (appcontent_ != &::google::protobuf::internal::kEmptyString) {
        appcontent_->clear();
      }
    }
  }
  members_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool InviteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.StreamDataType streamType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::StreamDataType_IsValid(value)) {
            set_streamtype(static_cast< ::mimc::StreamDataType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_members;
        break;
      }

      // repeated .mimc.UserInfo members = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_members:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_members()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_members;
        if (input->ExpectTag(26)) goto parse_sdp;
        break;
      }

      // optional string sdp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sdp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_appContent;
        break;
      }

      // optional bytes appContent = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_appContent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_appcontent()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InviteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.StreamDataType streamType = 1;
  if (has_streamtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->streamtype(), output);
  }

  // repeated .mimc.UserInfo members = 2;
  for (int i = 0; i < this->members_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->members(i), output);
  }

  // optional string sdp = 3;
  if (has_sdp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->sdp(), output);
  }

  // optional bytes appContent = 4;
  if (has_appcontent()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->appcontent(), output);
  }

}

int InviteRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.StreamDataType streamType = 1;
    if (has_streamtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->streamtype());
    }

    // optional string sdp = 3;
    if (has_sdp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sdp());
    }

    // optional bytes appContent = 4;
    if (has_appcontent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->appcontent());
    }

  }
  // repeated .mimc.UserInfo members = 2;
  total_size += 1 * this->members_size();
  for (int i = 0; i < this->members_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->members(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InviteRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InviteRequest*>(&from));
}

void InviteRequest::MergeFrom(const InviteRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  members_.MergeFrom(from.members_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_streamtype()) {
      set_streamtype(from.streamtype());
    }
    if (from.has_sdp()) {
      set_sdp(from.sdp());
    }
    if (from.has_appcontent()) {
      set_appcontent(from.appcontent());
    }
  }
}

void InviteRequest::CopyFrom(const InviteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InviteRequest::IsInitialized() const {

  return true;
}

void InviteRequest::Swap(InviteRequest* other) {
  if (other != this) {
    std::swap(streamtype_, other->streamtype_);
    members_.Swap(&other->members_);
    std::swap(sdp_, other->sdp_);
    std::swap(appcontent_, other->appcontent_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string InviteRequest::GetTypeName() const {
  return "mimc.InviteRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int InviteResponse::kResultFieldNumber;
const int InviteResponse::kErrmsgFieldNumber;
const int InviteResponse::kSdpFieldNumber;
const int InviteResponse::kUserFieldNumber;
#endif  // !_MSC_VER

InviteResponse::InviteResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void InviteResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

InviteResponse::InviteResponse(const InviteResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void InviteResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InviteResponse::~InviteResponse() {
  SharedDtor();
}

void InviteResponse::SharedDtor() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errmsg_;
  }
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void InviteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InviteResponse& InviteResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

InviteResponse* InviteResponse::default_instance_ = NULL;

InviteResponse* InviteResponse::New() const {
  return new InviteResponse;
}

void InviteResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_errmsg()) {
      if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
        errmsg_->clear();
      }
    }
    if (has_sdp()) {
      if (sdp_ != &::google::protobuf::internal::kEmptyString) {
        sdp_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool InviteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errmsg;
        break;
      }

      // optional string errmsg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errmsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errmsg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sdp;
        break;
      }

      // optional string sdp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sdp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InviteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string errmsg = 2;
  if (has_errmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errmsg(), output);
  }

  // optional string sdp = 3;
  if (has_sdp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->sdp(), output);
  }

  // optional .mimc.UserInfo user = 4;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->user(), output);
  }

}

int InviteResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string errmsg = 2;
    if (has_errmsg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errmsg());
    }

    // optional string sdp = 3;
    if (has_sdp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sdp());
    }

    // optional .mimc.UserInfo user = 4;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InviteResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InviteResponse*>(&from));
}

void InviteResponse::MergeFrom(const InviteResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_errmsg()) {
      set_errmsg(from.errmsg());
    }
    if (from.has_sdp()) {
      set_sdp(from.sdp());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void InviteResponse::CopyFrom(const InviteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InviteResponse::IsInitialized() const {

  return true;
}

void InviteResponse::Swap(InviteResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(errmsg_, other->errmsg_);
    std::swap(sdp_, other->sdp_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string InviteResponse::GetTypeName() const {
  return "mimc.InviteResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateResponse::kResultFieldNumber;
const int CreateResponse::kErrmsgFieldNumber;
const int CreateResponse::kSdpFieldNumber;
const int CreateResponse::kMembersFieldNumber;
#endif  // !_MSC_VER

CreateResponse::CreateResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateResponse::InitAsDefaultInstance() {
}

CreateResponse::CreateResponse(const CreateResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateResponse::~CreateResponse() {
  SharedDtor();
}

void CreateResponse::SharedDtor() {
  if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errmsg_;
  }
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateResponse& CreateResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

CreateResponse* CreateResponse::default_instance_ = NULL;

CreateResponse* CreateResponse::New() const {
  return new CreateResponse;
}

void CreateResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_errmsg()) {
      if (errmsg_ != &::google::protobuf::internal::kEmptyString) {
        errmsg_->clear();
      }
    }
    if (has_sdp()) {
      if (sdp_ != &::google::protobuf::internal::kEmptyString) {
        sdp_->clear();
      }
    }
  }
  members_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_errmsg;
        break;
      }

      // optional string errmsg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errmsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errmsg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sdp;
        break;
      }

      // optional string sdp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sdp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sdp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_members;
        break;
      }

      // repeated .mimc.UserInfo members = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_members:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_members()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_members;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string errmsg = 2;
  if (has_errmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->errmsg(), output);
  }

  // optional string sdp = 3;
  if (has_sdp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->sdp(), output);
  }

  // repeated .mimc.UserInfo members = 4;
  for (int i = 0; i < this->members_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->members(i), output);
  }

}

int CreateResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string errmsg = 2;
    if (has_errmsg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errmsg());
    }

    // optional string sdp = 3;
    if (has_sdp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sdp());
    }

  }
  // repeated .mimc.UserInfo members = 4;
  total_size += 1 * this->members_size();
  for (int i = 0; i < this->members_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->members(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateResponse*>(&from));
}

void CreateResponse::MergeFrom(const CreateResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  members_.MergeFrom(from.members_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_errmsg()) {
      set_errmsg(from.errmsg());
    }
    if (from.has_sdp()) {
      set_sdp(from.sdp());
    }
  }
}

void CreateResponse::CopyFrom(const CreateResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateResponse::IsInitialized() const {

  return true;
}

void CreateResponse::Swap(CreateResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(errmsg_, other->errmsg_);
    std::swap(sdp_, other->sdp_);
    members_.Swap(&other->members_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateResponse::GetTypeName() const {
  return "mimc.CreateResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateRequest::kUserFieldNumber;
#endif  // !_MSC_VER

UpdateRequest::UpdateRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

UpdateRequest::UpdateRequest(const UpdateRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateRequest::SharedCtor() {
  _cached_size_ = 0;
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateRequest::~UpdateRequest() {
  SharedDtor();
}

void UpdateRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void UpdateRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateRequest& UpdateRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UpdateRequest* UpdateRequest::default_instance_ = NULL;

UpdateRequest* UpdateRequest::New() const {
  return new UpdateRequest;
}

void UpdateRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.UserInfo user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.UserInfo user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user(), output);
  }

}

int UpdateRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.UserInfo user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateRequest*>(&from));
}

void UpdateRequest::MergeFrom(const UpdateRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void UpdateRequest::CopyFrom(const UpdateRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateRequest::IsInitialized() const {

  return true;
}

void UpdateRequest::Swap(UpdateRequest* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateRequest::GetTypeName() const {
  return "mimc.UpdateRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateResponse::kResultFieldNumber;
#endif  // !_MSC_VER

UpdateResponse::UpdateResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateResponse::InitAsDefaultInstance() {
}

UpdateResponse::UpdateResponse(const UpdateResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateResponse::~UpdateResponse() {
  SharedDtor();
}

void UpdateResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateResponse& UpdateResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UpdateResponse* UpdateResponse::default_instance_ = NULL;

UpdateResponse* UpdateResponse::New() const {
  return new UpdateResponse;
}

void UpdateResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int UpdateResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateResponse*>(&from));
}

void UpdateResponse::MergeFrom(const UpdateResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void UpdateResponse::CopyFrom(const UpdateResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateResponse::IsInitialized() const {

  return true;
}

void UpdateResponse::Swap(UpdateResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateResponse::GetTypeName() const {
  return "mimc.UpdateResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PingRequest::PingRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PingRequest::InitAsDefaultInstance() {
}

PingRequest::PingRequest(const PingRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PingRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PingRequest::~PingRequest() {
  SharedDtor();
}

void PingRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PingRequest& PingRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

PingRequest* PingRequest::default_instance_ = NULL;

PingRequest* PingRequest::New() const {
  return new PingRequest;
}

void PingRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void PingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int PingRequest::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PingRequest*>(&from));
}

void PingRequest::MergeFrom(const PingRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void PingRequest::CopyFrom(const PingRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingRequest::IsInitialized() const {

  return true;
}

void PingRequest::Swap(PingRequest* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PingRequest::GetTypeName() const {
  return "mimc.PingRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PingResponse::PingResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PingResponse::InitAsDefaultInstance() {
}

PingResponse::PingResponse(const PingResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PingResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PingResponse::~PingResponse() {
  SharedDtor();
}

void PingResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PingResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PingResponse& PingResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

PingResponse* PingResponse::default_instance_ = NULL;

PingResponse* PingResponse::New() const {
  return new PingResponse;
}

void PingResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PingResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void PingResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int PingResponse::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PingResponse*>(&from));
}

void PingResponse::MergeFrom(const PingResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void PingResponse::CopyFrom(const PingResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingResponse::IsInitialized() const {

  return true;
}

void PingResponse::Swap(PingResponse* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PingResponse::GetTypeName() const {
  return "mimc.PingResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int ByeRequest::kReasonFieldNumber;
#endif  // !_MSC_VER

ByeRequest::ByeRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ByeRequest::InitAsDefaultInstance() {
}

ByeRequest::ByeRequest(const ByeRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ByeRequest::SharedCtor() {
  _cached_size_ = 0;
  reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ByeRequest::~ByeRequest() {
  SharedDtor();
}

void ByeRequest::SharedDtor() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ByeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ByeRequest& ByeRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

ByeRequest* ByeRequest::default_instance_ = NULL;

ByeRequest* ByeRequest::New() const {
  return new ByeRequest;
}

void ByeRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_reason()) {
      if (reason_ != &::google::protobuf::internal::kEmptyString) {
        reason_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ByeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string reason = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reason()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ByeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string reason = 1;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->reason(), output);
  }

}

int ByeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string reason = 1;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reason());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ByeRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ByeRequest*>(&from));
}

void ByeRequest::MergeFrom(const ByeRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
}

void ByeRequest::CopyFrom(const ByeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByeRequest::IsInitialized() const {

  return true;
}

void ByeRequest::Swap(ByeRequest* other) {
  if (other != this) {
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ByeRequest::GetTypeName() const {
  return "mimc.ByeRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ByeResponse::kResultFieldNumber;
const int ByeResponse::kReasonFieldNumber;
#endif  // !_MSC_VER

ByeResponse::ByeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ByeResponse::InitAsDefaultInstance() {
}

ByeResponse::ByeResponse(const ByeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ByeResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ByeResponse::~ByeResponse() {
  SharedDtor();
}

void ByeResponse::SharedDtor() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ByeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ByeResponse& ByeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

ByeResponse* ByeResponse::default_instance_ = NULL;

ByeResponse* ByeResponse::New() const {
  return new ByeResponse;
}

void ByeResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_reason()) {
      if (reason_ != &::google::protobuf::internal::kEmptyString) {
        reason_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ByeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_reason;
        break;
      }

      // optional string reason = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reason:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reason()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ByeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string reason = 2;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->reason(), output);
  }

}

int ByeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string reason = 2;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reason());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ByeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ByeResponse*>(&from));
}

void ByeResponse::MergeFrom(const ByeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
}

void ByeResponse::CopyFrom(const ByeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByeResponse::IsInitialized() const {

  return true;
}

void ByeResponse::Swap(ByeResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ByeResponse::GetTypeName() const {
  return "mimc.ByeResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateChannelRequest::kUserFieldNumber;
const int CreateChannelRequest::kIdentityFieldNumber;
const int CreateChannelRequest::kExtraFieldNumber;
#endif  // !_MSC_VER

CreateChannelRequest::CreateChannelRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateChannelRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

CreateChannelRequest::CreateChannelRequest(const CreateChannelRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateChannelRequest::SharedCtor() {
  _cached_size_ = 0;
  user_ = NULL;
  identity_ = GOOGLE_ULONGLONG(0);
  extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateChannelRequest::~CreateChannelRequest() {
  SharedDtor();
}

void CreateChannelRequest::SharedDtor() {
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void CreateChannelRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateChannelRequest& CreateChannelRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

CreateChannelRequest* CreateChannelRequest::default_instance_ = NULL;

CreateChannelRequest* CreateChannelRequest::New() const {
  return new CreateChannelRequest;
}

void CreateChannelRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
    identity_ = GOOGLE_ULONGLONG(0);
    if (has_extra()) {
      if (extra_ != &::google::protobuf::internal::kEmptyString) {
        extra_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateChannelRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.UserInfo user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_identity;
        break;
      }

      // optional uint64 identity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_identity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &identity_)));
          set_has_identity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_extra;
        break;
      }

      // optional bytes extra = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extra:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateChannelRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.UserInfo user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user(), output);
  }

  // optional uint64 identity = 2;
  if (has_identity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->identity(), output);
  }

  // optional bytes extra = 3;
  if (has_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->extra(), output);
  }

}

int CreateChannelRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.UserInfo user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

    // optional uint64 identity = 2;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->identity());
    }

    // optional bytes extra = 3;
    if (has_extra()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateChannelRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateChannelRequest*>(&from));
}

void CreateChannelRequest::MergeFrom(const CreateChannelRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
    if (from.has_identity()) {
      set_identity(from.identity());
    }
    if (from.has_extra()) {
      set_extra(from.extra());
    }
  }
}

void CreateChannelRequest::CopyFrom(const CreateChannelRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateChannelRequest::IsInitialized() const {

  return true;
}

void CreateChannelRequest::Swap(CreateChannelRequest* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    std::swap(identity_, other->identity_);
    std::swap(extra_, other->extra_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateChannelRequest::GetTypeName() const {
  return "mimc.CreateChannelRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateChannelResponse::kResultFieldNumber;
const int CreateChannelResponse::kDescFieldNumber;
const int CreateChannelResponse::kCallIdFieldNumber;
const int CreateChannelResponse::kCallKeyFieldNumber;
const int CreateChannelResponse::kIdentityFieldNumber;
const int CreateChannelResponse::kExtraFieldNumber;
const int CreateChannelResponse::kUserFieldNumber;
#endif  // !_MSC_VER

CreateChannelResponse::CreateChannelResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateChannelResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

CreateChannelResponse::CreateChannelResponse(const CreateChannelResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateChannelResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callid_ = GOOGLE_ULONGLONG(0);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  identity_ = GOOGLE_ULONGLONG(0);
  extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateChannelResponse::~CreateChannelResponse() {
  SharedDtor();
}

void CreateChannelResponse::SharedDtor() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void CreateChannelResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateChannelResponse& CreateChannelResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

CreateChannelResponse* CreateChannelResponse::default_instance_ = NULL;

CreateChannelResponse* CreateChannelResponse::New() const {
  return new CreateChannelResponse;
}

void CreateChannelResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    identity_ = GOOGLE_ULONGLONG(0);
    if (has_extra()) {
      if (extra_ != &::google::protobuf::internal::kEmptyString) {
        extra_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateChannelResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }

      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_callId;
        break;
      }

      // optional uint64 callId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_callKey;
        break;
      }

      // optional string callKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_identity;
        break;
      }

      // optional uint64 identity = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_identity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &identity_)));
          set_has_identity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_extra;
        break;
      }

      // optional bytes extra = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extra:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateChannelResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }

  // optional uint64 callId = 3;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->callid(), output);
  }

  // optional string callKey = 4;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->callkey(), output);
  }

  // optional uint64 identity = 5;
  if (has_identity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->identity(), output);
  }

  // optional bytes extra = 6;
  if (has_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->extra(), output);
  }

  // optional .mimc.UserInfo user = 7;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->user(), output);
  }

}

int CreateChannelResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }

    // optional uint64 callId = 3;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional string callKey = 4;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional uint64 identity = 5;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->identity());
    }

    // optional bytes extra = 6;
    if (has_extra()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra());
    }

    // optional .mimc.UserInfo user = 7;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateChannelResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateChannelResponse*>(&from));
}

void CreateChannelResponse::MergeFrom(const CreateChannelResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_identity()) {
      set_identity(from.identity());
    }
    if (from.has_extra()) {
      set_extra(from.extra());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void CreateChannelResponse::CopyFrom(const CreateChannelResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateChannelResponse::IsInitialized() const {

  return true;
}

void CreateChannelResponse::Swap(CreateChannelResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(desc_, other->desc_);
    std::swap(callid_, other->callid_);
    std::swap(callkey_, other->callkey_);
    std::swap(identity_, other->identity_);
    std::swap(extra_, other->extra_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateChannelResponse::GetTypeName() const {
  return "mimc.CreateChannelResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinChannelRequest::kCallIdFieldNumber;
const int JoinChannelRequest::kCallKeyFieldNumber;
const int JoinChannelRequest::kUserFieldNumber;
#endif  // !_MSC_VER

JoinChannelRequest::JoinChannelRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinChannelRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

JoinChannelRequest::JoinChannelRequest(const JoinChannelRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinChannelRequest::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinChannelRequest::~JoinChannelRequest() {
  SharedDtor();
}

void JoinChannelRequest::SharedDtor() {
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void JoinChannelRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinChannelRequest& JoinChannelRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

JoinChannelRequest* JoinChannelRequest::default_instance_ = NULL;

JoinChannelRequest* JoinChannelRequest::New() const {
  return new JoinChannelRequest;
}

void JoinChannelRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinChannelRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_callKey;
        break;
      }

      // optional string callKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinChannelRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional string callKey = 2;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->callkey(), output);
  }

  // optional .mimc.UserInfo user = 3;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user(), output);
  }

}

int JoinChannelRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional string callKey = 2;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional .mimc.UserInfo user = 3;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinChannelRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinChannelRequest*>(&from));
}

void JoinChannelRequest::MergeFrom(const JoinChannelRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void JoinChannelRequest::CopyFrom(const JoinChannelRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinChannelRequest::IsInitialized() const {

  return true;
}

void JoinChannelRequest::Swap(JoinChannelRequest* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(callkey_, other->callkey_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinChannelRequest::GetTypeName() const {
  return "mimc.JoinChannelRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinChannelResponse::kResultFieldNumber;
const int JoinChannelResponse::kDescFieldNumber;
const int JoinChannelResponse::kCallIdFieldNumber;
const int JoinChannelResponse::kExtraFieldNumber;
const int JoinChannelResponse::kUsersFieldNumber;
#endif  // !_MSC_VER

JoinChannelResponse::JoinChannelResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinChannelResponse::InitAsDefaultInstance() {
}

JoinChannelResponse::JoinChannelResponse(const JoinChannelResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinChannelResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callid_ = GOOGLE_ULONGLONG(0);
  extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinChannelResponse::~JoinChannelResponse() {
  SharedDtor();
}

void JoinChannelResponse::SharedDtor() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (extra_ != &::google::protobuf::internal::kEmptyString) {
    delete extra_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinChannelResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinChannelResponse& JoinChannelResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

JoinChannelResponse* JoinChannelResponse::default_instance_ = NULL;

JoinChannelResponse* JoinChannelResponse::New() const {
  return new JoinChannelResponse;
}

void JoinChannelResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_extra()) {
      if (extra_ != &::google::protobuf::internal::kEmptyString) {
        extra_->clear();
      }
    }
  }
  users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinChannelResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }

      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_callId;
        break;
      }

      // optional uint64 callId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_extra;
        break;
      }

      // optional bytes extra = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extra:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_users;
        break;
      }

      // repeated .mimc.UserInfo users = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinChannelResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }

  // optional uint64 callId = 3;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->callid(), output);
  }

  // optional bytes extra = 4;
  if (has_extra()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->extra(), output);
  }

  // repeated .mimc.UserInfo users = 5;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->users(i), output);
  }

}

int JoinChannelResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }

    // optional uint64 callId = 3;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional bytes extra = 4;
    if (has_extra()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra());
    }

  }
  // repeated .mimc.UserInfo users = 5;
  total_size += 1 * this->users_size();
  for (int i = 0; i < this->users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->users(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinChannelResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinChannelResponse*>(&from));
}

void JoinChannelResponse::MergeFrom(const JoinChannelResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_extra()) {
      set_extra(from.extra());
    }
  }
}

void JoinChannelResponse::CopyFrom(const JoinChannelResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinChannelResponse::IsInitialized() const {

  return true;
}

void JoinChannelResponse::Swap(JoinChannelResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(desc_, other->desc_);
    std::swap(callid_, other->callid_);
    std::swap(extra_, other->extra_);
    users_.Swap(&other->users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinChannelResponse::GetTypeName() const {
  return "mimc.JoinChannelResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int LeaveChannelRequest::kCallIdFieldNumber;
const int LeaveChannelRequest::kCallKeyFieldNumber;
const int LeaveChannelRequest::kUserFieldNumber;
#endif  // !_MSC_VER

LeaveChannelRequest::LeaveChannelRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LeaveChannelRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

LeaveChannelRequest::LeaveChannelRequest(const LeaveChannelRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LeaveChannelRequest::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveChannelRequest::~LeaveChannelRequest() {
  SharedDtor();
}

void LeaveChannelRequest::SharedDtor() {
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void LeaveChannelRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveChannelRequest& LeaveChannelRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

LeaveChannelRequest* LeaveChannelRequest::default_instance_ = NULL;

LeaveChannelRequest* LeaveChannelRequest::New() const {
  return new LeaveChannelRequest;
}

void LeaveChannelRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LeaveChannelRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_callKey;
        break;
      }

      // optional string callKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LeaveChannelRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional string callKey = 2;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->callkey(), output);
  }

  // optional .mimc.UserInfo user = 3;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user(), output);
  }

}

int LeaveChannelRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional string callKey = 2;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional .mimc.UserInfo user = 3;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveChannelRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveChannelRequest*>(&from));
}

void LeaveChannelRequest::MergeFrom(const LeaveChannelRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void LeaveChannelRequest::CopyFrom(const LeaveChannelRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveChannelRequest::IsInitialized() const {

  return true;
}

void LeaveChannelRequest::Swap(LeaveChannelRequest* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(callkey_, other->callkey_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveChannelRequest::GetTypeName() const {
  return "mimc.LeaveChannelRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int LeaveChannelResponse::kResultFieldNumber;
const int LeaveChannelResponse::kDescFieldNumber;
const int LeaveChannelResponse::kCallIdFieldNumber;
#endif  // !_MSC_VER

LeaveChannelResponse::LeaveChannelResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LeaveChannelResponse::InitAsDefaultInstance() {
}

LeaveChannelResponse::LeaveChannelResponse(const LeaveChannelResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LeaveChannelResponse::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveChannelResponse::~LeaveChannelResponse() {
  SharedDtor();
}

void LeaveChannelResponse::SharedDtor() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LeaveChannelResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveChannelResponse& LeaveChannelResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

LeaveChannelResponse* LeaveChannelResponse::default_instance_ = NULL;

LeaveChannelResponse* LeaveChannelResponse::New() const {
  return new LeaveChannelResponse;
}

void LeaveChannelResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
    callid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LeaveChannelResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.RTSResult result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::RTSResult_IsValid(value)) {
            set_result(static_cast< ::mimc::RTSResult >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_desc;
        break;
      }

      // optional string desc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_callId;
        break;
      }

      // optional uint64 callId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_callId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LeaveChannelResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.RTSResult result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string desc = 2;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->desc(), output);
  }

  // optional uint64 callId = 3;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->callid(), output);
  }

}

int LeaveChannelResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.RTSResult result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string desc = 2;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }

    // optional uint64 callId = 3;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveChannelResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveChannelResponse*>(&from));
}

void LeaveChannelResponse::MergeFrom(const LeaveChannelResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_callid()) {
      set_callid(from.callid());
    }
  }
}

void LeaveChannelResponse::CopyFrom(const LeaveChannelResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveChannelResponse::IsInitialized() const {

  return true;
}

void LeaveChannelResponse::Swap(LeaveChannelResponse* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(desc_, other->desc_);
    std::swap(callid_, other->callid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveChannelResponse::GetTypeName() const {
  return "mimc.LeaveChannelResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int UserJoinNotification::kCallIdFieldNumber;
const int UserJoinNotification::kCallKeyFieldNumber;
const int UserJoinNotification::kUserFieldNumber;
#endif  // !_MSC_VER

UserJoinNotification::UserJoinNotification()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserJoinNotification::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

UserJoinNotification::UserJoinNotification(const UserJoinNotification& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserJoinNotification::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserJoinNotification::~UserJoinNotification() {
  SharedDtor();
}

void UserJoinNotification::SharedDtor() {
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void UserJoinNotification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserJoinNotification& UserJoinNotification::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UserJoinNotification* UserJoinNotification::default_instance_ = NULL;

UserJoinNotification* UserJoinNotification::New() const {
  return new UserJoinNotification;
}

void UserJoinNotification::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserJoinNotification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_callKey;
        break;
      }

      // optional string callKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserJoinNotification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional string callKey = 2;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->callkey(), output);
  }

  // optional .mimc.UserInfo user = 3;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user(), output);
  }

}

int UserJoinNotification::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional string callKey = 2;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional .mimc.UserInfo user = 3;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserJoinNotification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserJoinNotification*>(&from));
}

void UserJoinNotification::MergeFrom(const UserJoinNotification& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void UserJoinNotification::CopyFrom(const UserJoinNotification& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserJoinNotification::IsInitialized() const {

  return true;
}

void UserJoinNotification::Swap(UserJoinNotification* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(callkey_, other->callkey_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserJoinNotification::GetTypeName() const {
  return "mimc.UserJoinNotification";
}


// ===================================================================

#ifndef _MSC_VER
const int UserLeaveNotification::kCallIdFieldNumber;
const int UserLeaveNotification::kCallKeyFieldNumber;
const int UserLeaveNotification::kUserFieldNumber;
#endif  // !_MSC_VER

UserLeaveNotification::UserLeaveNotification()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserLeaveNotification::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::UserInfo*>(
      ::mimc::UserInfo::internal_default_instance());
#else
  user_ = const_cast< ::mimc::UserInfo*>(&::mimc::UserInfo::default_instance());
#endif
}

UserLeaveNotification::UserLeaveNotification(const UserLeaveNotification& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserLeaveNotification::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  callkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserLeaveNotification::~UserLeaveNotification() {
  SharedDtor();
}

void UserLeaveNotification::SharedDtor() {
  if (callkey_ != &::google::protobuf::internal::kEmptyString) {
    delete callkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void UserLeaveNotification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserLeaveNotification& UserLeaveNotification::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UserLeaveNotification* UserLeaveNotification::default_instance_ = NULL;

UserLeaveNotification* UserLeaveNotification::New() const {
  return new UserLeaveNotification;
}

void UserLeaveNotification::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    if (has_callkey()) {
      if (callkey_ != &::google::protobuf::internal::kEmptyString) {
        callkey_->clear();
      }
    }
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::UserInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserLeaveNotification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_callKey;
        break;
      }

      // optional string callKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_user;
        break;
      }

      // optional .mimc.UserInfo user = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserLeaveNotification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional string callKey = 2;
  if (has_callkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->callkey(), output);
  }

  // optional .mimc.UserInfo user = 3;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user(), output);
  }

}

int UserLeaveNotification::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional string callKey = 2;
    if (has_callkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callkey());
    }

    // optional .mimc.UserInfo user = 3;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserLeaveNotification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserLeaveNotification*>(&from));
}

void UserLeaveNotification::MergeFrom(const UserLeaveNotification& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_callkey()) {
      set_callkey(from.callkey());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::UserInfo::MergeFrom(from.user());
    }
  }
}

void UserLeaveNotification::CopyFrom(const UserLeaveNotification& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserLeaveNotification::IsInitialized() const {

  return true;
}

void UserLeaveNotification::Swap(UserLeaveNotification* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(callkey_, other->callkey_);
    std::swap(user_, other->user_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserLeaveNotification::GetTypeName() const {
  return "mimc.UserLeaveNotification";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateCallInfo::kCallIdFieldNumber;
const int UpdateCallInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

UpdateCallInfo::UpdateCallInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateCallInfo::InitAsDefaultInstance() {
}

UpdateCallInfo::UpdateCallInfo(const UpdateCallInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateCallInfo::SharedCtor() {
  _cached_size_ = 0;
  callid_ = GOOGLE_ULONGLONG(0);
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateCallInfo::~UpdateCallInfo() {
  SharedDtor();
}

void UpdateCallInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateCallInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateCallInfo& UpdateCallInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_rts_5fsignal_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_rts_5fsignal_2eproto();
#endif
  return *default_instance_;
}

UpdateCallInfo* UpdateCallInfo::default_instance_ = NULL;

UpdateCallInfo* UpdateCallInfo::New() const {
  return new UpdateCallInfo;
}

void UpdateCallInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    callid_ = GOOGLE_ULONGLONG(0);
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateCallInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 callId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .mimc.UpdateType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::UpdateType_IsValid(value)) {
            set_type(static_cast< ::mimc::UpdateType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateCallInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->callid(), output);
  }

  // optional .mimc.UpdateType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

}

int UpdateCallInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 callId = 1;
    if (has_callid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->callid());
    }

    // optional .mimc.UpdateType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateCallInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateCallInfo*>(&from));
}

void UpdateCallInfo::MergeFrom(const UpdateCallInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void UpdateCallInfo::CopyFrom(const UpdateCallInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateCallInfo::IsInitialized() const {

  return true;
}

void UpdateCallInfo::Swap(UpdateCallInfo* other) {
  if (other != this) {
    std::swap(callid_, other->callid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateCallInfo::GetTypeName() const {
  return "mimc.UpdateCallInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

// @@protoc_insertion_point(global_scope)
