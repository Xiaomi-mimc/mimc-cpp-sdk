// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mimc.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mimc/mimc.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace mimc {

void protobuf_ShutdownFile_mimc_2eproto() {
  delete FilterRequest::default_instance_;
  delete FilterResponse::default_instance_;
  delete PullMessageRequest::default_instance_;
  delete TopicMessage::default_instance_;
  delete TransferTopicMessage::default_instance_;
  delete QueryAppinfoRequest::default_instance_;
  delete Appinfo::default_instance_;
  delete MIMCPacket::default_instance_;
  delete MIMCPacketList::default_instance_;
  delete MIMCPacketAck::default_instance_;
  delete MIMCP2PMessage::default_instance_;
  delete MIMCP2TMessage::default_instance_;
  delete MIMCSequenceAck::default_instance_;
  delete P2PPushMesage::default_instance_;
  delete P2TPushMesage::default_instance_;
  delete MIMCUser::default_instance_;
  delete MIMCGroup::default_instance_;
  delete UCGroup::default_instance_;
  delete GenerateIdRequest::default_instance_;
  delete GenerateIdResponse::default_instance_;
  delete UCPacket::default_instance_;
  delete UCExchange::default_instance_;
  delete UCJoin::default_instance_;
  delete UCJoinResp::default_instance_;
  delete UCQuit::default_instance_;
  delete UCQuitResp::default_instance_;
  delete UCPing::default_instance_;
  delete UCMessage::default_instance_;
  delete UCPushMessage::default_instance_;
  delete UCMessageList::default_instance_;
  delete UCSequenceAck::default_instance_;
  delete UCDismiss::default_instance_;
  delete UCQueryOnlineUsers::default_instance_;
  delete UCQueryOnlineUsersResp::default_instance_;
  delete FeInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_mimc_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_mimc_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  FilterRequest::default_instance_ = new FilterRequest();
  FilterResponse::default_instance_ = new FilterResponse();
  PullMessageRequest::default_instance_ = new PullMessageRequest();
  TopicMessage::default_instance_ = new TopicMessage();
  TransferTopicMessage::default_instance_ = new TransferTopicMessage();
  QueryAppinfoRequest::default_instance_ = new QueryAppinfoRequest();
  Appinfo::default_instance_ = new Appinfo();
  MIMCPacket::default_instance_ = new MIMCPacket();
  MIMCPacketList::default_instance_ = new MIMCPacketList();
  MIMCPacketAck::default_instance_ = new MIMCPacketAck();
  MIMCP2PMessage::default_instance_ = new MIMCP2PMessage();
  MIMCP2TMessage::default_instance_ = new MIMCP2TMessage();
  MIMCSequenceAck::default_instance_ = new MIMCSequenceAck();
  P2PPushMesage::default_instance_ = new P2PPushMesage();
  P2TPushMesage::default_instance_ = new P2TPushMesage();
  MIMCUser::default_instance_ = new MIMCUser();
  MIMCGroup::default_instance_ = new MIMCGroup();
  UCGroup::default_instance_ = new UCGroup();
  GenerateIdRequest::default_instance_ = new GenerateIdRequest();
  GenerateIdResponse::default_instance_ = new GenerateIdResponse();
  UCPacket::default_instance_ = new UCPacket();
  UCExchange::default_instance_ = new UCExchange();
  UCJoin::default_instance_ = new UCJoin();
  UCJoinResp::default_instance_ = new UCJoinResp();
  UCQuit::default_instance_ = new UCQuit();
  UCQuitResp::default_instance_ = new UCQuitResp();
  UCPing::default_instance_ = new UCPing();
  UCMessage::default_instance_ = new UCMessage();
  UCPushMessage::default_instance_ = new UCPushMessage();
  UCMessageList::default_instance_ = new UCMessageList();
  UCSequenceAck::default_instance_ = new UCSequenceAck();
  UCDismiss::default_instance_ = new UCDismiss();
  UCQueryOnlineUsers::default_instance_ = new UCQueryOnlineUsers();
  UCQueryOnlineUsersResp::default_instance_ = new UCQueryOnlineUsersResp();
  FeInfo::default_instance_ = new FeInfo();
  FilterRequest::default_instance_->InitAsDefaultInstance();
  FilterResponse::default_instance_->InitAsDefaultInstance();
  PullMessageRequest::default_instance_->InitAsDefaultInstance();
  TopicMessage::default_instance_->InitAsDefaultInstance();
  TransferTopicMessage::default_instance_->InitAsDefaultInstance();
  QueryAppinfoRequest::default_instance_->InitAsDefaultInstance();
  Appinfo::default_instance_->InitAsDefaultInstance();
  MIMCPacket::default_instance_->InitAsDefaultInstance();
  MIMCPacketList::default_instance_->InitAsDefaultInstance();
  MIMCPacketAck::default_instance_->InitAsDefaultInstance();
  MIMCP2PMessage::default_instance_->InitAsDefaultInstance();
  MIMCP2TMessage::default_instance_->InitAsDefaultInstance();
  MIMCSequenceAck::default_instance_->InitAsDefaultInstance();
  P2PPushMesage::default_instance_->InitAsDefaultInstance();
  P2TPushMesage::default_instance_->InitAsDefaultInstance();
  MIMCUser::default_instance_->InitAsDefaultInstance();
  MIMCGroup::default_instance_->InitAsDefaultInstance();
  UCGroup::default_instance_->InitAsDefaultInstance();
  GenerateIdRequest::default_instance_->InitAsDefaultInstance();
  GenerateIdResponse::default_instance_->InitAsDefaultInstance();
  UCPacket::default_instance_->InitAsDefaultInstance();
  UCExchange::default_instance_->InitAsDefaultInstance();
  UCJoin::default_instance_->InitAsDefaultInstance();
  UCJoinResp::default_instance_->InitAsDefaultInstance();
  UCQuit::default_instance_->InitAsDefaultInstance();
  UCQuitResp::default_instance_->InitAsDefaultInstance();
  UCPing::default_instance_->InitAsDefaultInstance();
  UCMessage::default_instance_->InitAsDefaultInstance();
  UCPushMessage::default_instance_->InitAsDefaultInstance();
  UCMessageList::default_instance_->InitAsDefaultInstance();
  UCSequenceAck::default_instance_->InitAsDefaultInstance();
  UCDismiss::default_instance_->InitAsDefaultInstance();
  UCQueryOnlineUsers::default_instance_->InitAsDefaultInstance();
  UCQueryOnlineUsersResp::default_instance_->InitAsDefaultInstance();
  FeInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mimc_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_mimc_2eproto_once_);
void protobuf_AddDesc_mimc_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_mimc_2eproto_once_,
                 &protobuf_AddDesc_mimc_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mimc_2eproto {
  StaticDescriptorInitializer_mimc_2eproto() {
    protobuf_AddDesc_mimc_2eproto();
  }
} static_descriptor_initializer_mimc_2eproto_;
#endif
bool ErrorCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool MIMC_MSG_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

bool MIMC_PUSH_STATUS_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool UC_MSG_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int FilterRequest::kIdFieldNumber;
const int FilterRequest::kPacketFieldNumber;
#endif  // !_MSC_VER

FilterRequest::FilterRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FilterRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  packet_ = const_cast< ::mimc::MIMCPacket*>(
      ::mimc::MIMCPacket::internal_default_instance());
#else
  packet_ = const_cast< ::mimc::MIMCPacket*>(&::mimc::MIMCPacket::default_instance());
#endif
}

FilterRequest::FilterRequest(const FilterRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FilterRequest::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  packet_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterRequest::~FilterRequest() {
  SharedDtor();
}

void FilterRequest::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete packet_;
  }
}

void FilterRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FilterRequest& FilterRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

FilterRequest* FilterRequest::default_instance_ = NULL;

FilterRequest* FilterRequest::New() const {
  return new FilterRequest;
}

void FilterRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    if (has_packet()) {
      if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FilterRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_packet;
        break;
      }

      // required .mimc.MIMCPacket packet = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packet:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packet()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilterRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->id(), output);
  }

  // required .mimc.MIMCPacket packet = 2;
  if (has_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->packet(), output);
  }

}

int FilterRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // required .mimc.MIMCPacket packet = 2;
    if (has_packet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->packet());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FilterRequest*>(&from));
}

void FilterRequest::MergeFrom(const FilterRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_packet()) {
      mutable_packet()->::mimc::MIMCPacket::MergeFrom(from.packet());
    }
  }
}

void FilterRequest::CopyFrom(const FilterRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void FilterRequest::Swap(FilterRequest* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(packet_, other->packet_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FilterRequest::GetTypeName() const {
  return "mimc.FilterRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int FilterResponse::kIdFieldNumber;
const int FilterResponse::kTypeFieldNumber;
const int FilterResponse::kErrorCodeFieldNumber;
const int FilterResponse::kIsFilterFieldNumber;
#endif  // !_MSC_VER

FilterResponse::FilterResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FilterResponse::InitAsDefaultInstance() {
}

FilterResponse::FilterResponse(const FilterResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FilterResponse::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 1;
  errorcode_ = 0;
  isfilter_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterResponse::~FilterResponse() {
  SharedDtor();
}

void FilterResponse::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FilterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FilterResponse& FilterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

FilterResponse* FilterResponse::default_instance_ = NULL;

FilterResponse* FilterResponse::New() const {
  return new FilterResponse;
}

void FilterResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    type_ = 1;
    errorcode_ = 0;
    isfilter_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FilterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .mimc.MIMC_MSG_TYPE type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::MIMC_MSG_TYPE_IsValid(value)) {
            set_type(static_cast< ::mimc::MIMC_MSG_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_errorCode;
        break;
      }

      // optional .mimc.ErrorCode errorCode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_errorCode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::ErrorCode_IsValid(value)) {
            set_errorcode(static_cast< ::mimc::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isFilter;
        break;
      }

      // optional bool isFilter = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isFilter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isfilter_)));
          set_has_isfilter();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->id(), output);
  }

  // optional .mimc.MIMC_MSG_TYPE type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mimc.ErrorCode errorCode = 3;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->errorcode(), output);
  }

  // optional bool isFilter = 4;
  if (has_isfilter()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isfilter(), output);
  }

}

int FilterResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional .mimc.MIMC_MSG_TYPE type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mimc.ErrorCode errorCode = 3;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->errorcode());
    }

    // optional bool isFilter = 4;
    if (has_isfilter()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FilterResponse*>(&from));
}

void FilterResponse::MergeFrom(const FilterResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_isfilter()) {
      set_isfilter(from.isfilter());
    }
  }
}

void FilterResponse::CopyFrom(const FilterResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FilterResponse::Swap(FilterResponse* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(errorcode_, other->errorcode_);
    std::swap(isfilter_, other->isfilter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FilterResponse::GetTypeName() const {
  return "mimc.FilterResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PullMessageRequest::kUuidFieldNumber;
const int PullMessageRequest::kResourceFieldNumber;
const int PullMessageRequest::kAppIdFieldNumber;
#endif  // !_MSC_VER

PullMessageRequest::PullMessageRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PullMessageRequest::InitAsDefaultInstance() {
}

PullMessageRequest::PullMessageRequest(const PullMessageRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PullMessageRequest::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  appid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PullMessageRequest::~PullMessageRequest() {
  SharedDtor();
}

void PullMessageRequest::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PullMessageRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PullMessageRequest& PullMessageRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

PullMessageRequest* PullMessageRequest::default_instance_ = NULL;

PullMessageRequest* PullMessageRequest::New() const {
  return new PullMessageRequest;
}

void PullMessageRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    appid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PullMessageRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_resource;
        break;
      }

      // required string resource = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_appId;
        break;
      }

      // optional uint64 appId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PullMessageRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uuid(), output);
  }

  // required string resource = 2;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->resource(), output);
  }

  // optional uint64 appId = 3;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->appid(), output);
  }

}

int PullMessageRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // required string resource = 2;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional uint64 appId = 3;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PullMessageRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PullMessageRequest*>(&from));
}

void PullMessageRequest::MergeFrom(const PullMessageRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_appid()) {
      set_appid(from.appid());
    }
  }
}

void PullMessageRequest::CopyFrom(const PullMessageRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PullMessageRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PullMessageRequest::Swap(PullMessageRequest* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(appid_, other->appid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PullMessageRequest::GetTypeName() const {
  return "mimc.PullMessageRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int TopicMessage::kTopicIdFieldNumber;
const int TopicMessage::kPacketFieldNumber;
const int TopicMessage::kUuidFieldNumber;
const int TopicMessage::kResourceFieldNumber;
const int TopicMessage::kIsSystemMsgFieldNumber;
#endif  // !_MSC_VER

TopicMessage::TopicMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopicMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  packet_ = const_cast< ::mimc::MIMCPacket*>(
      ::mimc::MIMCPacket::internal_default_instance());
#else
  packet_ = const_cast< ::mimc::MIMCPacket*>(&::mimc::MIMCPacket::default_instance());
#endif
}

TopicMessage::TopicMessage(const TopicMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopicMessage::SharedCtor() {
  _cached_size_ = 0;
  topicid_ = GOOGLE_ULONGLONG(0);
  packet_ = NULL;
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  issystemmsg_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopicMessage::~TopicMessage() {
  SharedDtor();
}

void TopicMessage::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete packet_;
  }
}

void TopicMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopicMessage& TopicMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

TopicMessage* TopicMessage::default_instance_ = NULL;

TopicMessage* TopicMessage::New() const {
  return new TopicMessage;
}

void TopicMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    topicid_ = GOOGLE_ULONGLONG(0);
    if (has_packet()) {
      if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
    }
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    issystemmsg_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopicMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 topicId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &topicid_)));
          set_has_topicid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_packet;
        break;
      }

      // required .mimc.MIMCPacket packet = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packet:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packet()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_uuid;
        break;
      }

      // optional uint64 uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_resource;
        break;
      }

      // optional string resource = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isSystemMsg;
        break;
      }

      // optional bool isSystemMsg = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isSystemMsg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issystemmsg_)));
          set_has_issystemmsg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopicMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 topicId = 1;
  if (has_topicid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->topicid(), output);
  }

  // required .mimc.MIMCPacket packet = 2;
  if (has_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->packet(), output);
  }

  // optional uint64 uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->uuid(), output);
  }

  // optional string resource = 4;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->resource(), output);
  }

  // optional bool isSystemMsg = 5;
  if (has_issystemmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->issystemmsg(), output);
  }

}

int TopicMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 topicId = 1;
    if (has_topicid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->topicid());
    }

    // required .mimc.MIMCPacket packet = 2;
    if (has_packet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->packet());
    }

    // optional uint64 uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // optional string resource = 4;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional bool isSystemMsg = 5;
    if (has_issystemmsg()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopicMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopicMessage*>(&from));
}

void TopicMessage::MergeFrom(const TopicMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_topicid()) {
      set_topicid(from.topicid());
    }
    if (from.has_packet()) {
      mutable_packet()->::mimc::MIMCPacket::MergeFrom(from.packet());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_issystemmsg()) {
      set_issystemmsg(from.issystemmsg());
    }
  }
}

void TopicMessage::CopyFrom(const TopicMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopicMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TopicMessage::Swap(TopicMessage* other) {
  if (other != this) {
    std::swap(topicid_, other->topicid_);
    std::swap(packet_, other->packet_);
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(issystemmsg_, other->issystemmsg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopicMessage::GetTypeName() const {
  return "mimc.TopicMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int TransferTopicMessage::kPacketFieldNumber;
const int TransferTopicMessage::kUuidListFieldNumber;
const int TransferTopicMessage::kTypeFieldNumber;
const int TransferTopicMessage::kAppIdFieldNumber;
#endif  // !_MSC_VER

TransferTopicMessage::TransferTopicMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransferTopicMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  packet_ = const_cast< ::mimc::MIMCPacket*>(
      ::mimc::MIMCPacket::internal_default_instance());
#else
  packet_ = const_cast< ::mimc::MIMCPacket*>(&::mimc::MIMCPacket::default_instance());
#endif
}

TransferTopicMessage::TransferTopicMessage(const TransferTopicMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransferTopicMessage::SharedCtor() {
  _cached_size_ = 0;
  packet_ = NULL;
  type_ = 1;
  appid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransferTopicMessage::~TransferTopicMessage() {
  SharedDtor();
}

void TransferTopicMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete packet_;
  }
}

void TransferTopicMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransferTopicMessage& TransferTopicMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

TransferTopicMessage* TransferTopicMessage::default_instance_ = NULL;

TransferTopicMessage* TransferTopicMessage::New() const {
  return new TransferTopicMessage;
}

void TransferTopicMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_packet()) {
      if (packet_ != NULL) packet_->::mimc::MIMCPacket::Clear();
    }
    type_ = 1;
    appid_ = GOOGLE_ULONGLONG(0);
  }
  uuidlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransferTopicMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.MIMCPacket packet = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packet()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uuidList;
        break;
      }

      // repeated uint64 uuidList = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuidList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_uuidlist())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_uuidlist())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uuidList;
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .mimc.MIMC_MSG_TYPE type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::MIMC_MSG_TYPE_IsValid(value)) {
            set_type(static_cast< ::mimc::MIMC_MSG_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_appId;
        break;
      }

      // optional uint64 appId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransferTopicMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.MIMCPacket packet = 1;
  if (has_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->packet(), output);
  }

  // repeated uint64 uuidList = 2;
  for (int i = 0; i < this->uuidlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->uuidlist(i), output);
  }

  // optional .mimc.MIMC_MSG_TYPE type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional uint64 appId = 4;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->appid(), output);
  }

}

int TransferTopicMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.MIMCPacket packet = 1;
    if (has_packet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->packet());
    }

    // optional .mimc.MIMC_MSG_TYPE type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 appId = 4;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

  }
  // repeated uint64 uuidList = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->uuidlist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->uuidlist(i));
    }
    total_size += 1 * this->uuidlist_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransferTopicMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransferTopicMessage*>(&from));
}

void TransferTopicMessage::MergeFrom(const TransferTopicMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  uuidlist_.MergeFrom(from.uuidlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_packet()) {
      mutable_packet()->::mimc::MIMCPacket::MergeFrom(from.packet());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_appid()) {
      set_appid(from.appid());
    }
  }
}

void TransferTopicMessage::CopyFrom(const TransferTopicMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransferTopicMessage::IsInitialized() const {

  return true;
}

void TransferTopicMessage::Swap(TransferTopicMessage* other) {
  if (other != this) {
    std::swap(packet_, other->packet_);
    uuidlist_.Swap(&other->uuidlist_);
    std::swap(type_, other->type_);
    std::swap(appid_, other->appid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransferTopicMessage::GetTypeName() const {
  return "mimc.TransferTopicMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int QueryAppinfoRequest::kAppIdFieldNumber;
const int QueryAppinfoRequest::kContextFieldNumber;
#endif  // !_MSC_VER

QueryAppinfoRequest::QueryAppinfoRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QueryAppinfoRequest::InitAsDefaultInstance() {
}

QueryAppinfoRequest::QueryAppinfoRequest(const QueryAppinfoRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QueryAppinfoRequest::SharedCtor() {
  _cached_size_ = 0;
  appid_ = GOOGLE_ULONGLONG(0);
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryAppinfoRequest::~QueryAppinfoRequest() {
  SharedDtor();
}

void QueryAppinfoRequest::SharedDtor() {
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QueryAppinfoRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QueryAppinfoRequest& QueryAppinfoRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

QueryAppinfoRequest* QueryAppinfoRequest::default_instance_ = NULL;

QueryAppinfoRequest* QueryAppinfoRequest::New() const {
  return new QueryAppinfoRequest;
}

void QueryAppinfoRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    appid_ = GOOGLE_ULONGLONG(0);
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::kEmptyString) {
        context_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QueryAppinfoRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 appId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_context;
        break;
      }

      // optional string context = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryAppinfoRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 appId = 1;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->appid(), output);
  }

  // optional string context = 2;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->context(), output);
  }

}

int QueryAppinfoRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 appId = 1;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional string context = 2;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->context());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryAppinfoRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QueryAppinfoRequest*>(&from));
}

void QueryAppinfoRequest::MergeFrom(const QueryAppinfoRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
  }
}

void QueryAppinfoRequest::CopyFrom(const QueryAppinfoRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryAppinfoRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void QueryAppinfoRequest::Swap(QueryAppinfoRequest* other) {
  if (other != this) {
    std::swap(appid_, other->appid_);
    std::swap(context_, other->context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QueryAppinfoRequest::GetTypeName() const {
  return "mimc.QueryAppinfoRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int Appinfo::kAppIdFieldNumber;
const int Appinfo::kMsgCallbackUrlFieldNumber;
const int Appinfo::kOfflineMsgCallbackUrlFieldNumber;
const int Appinfo::kUuidTTLFieldNumber;
const int Appinfo::kContextFieldNumber;
const int Appinfo::kMessageFilterFieldNumber;
const int Appinfo::kEnableBlacklistFieldNumber;
const int Appinfo::kTopicMemberCountFieldNumber;
const int Appinfo::kEnableAntiSpamFieldNumber;
const int Appinfo::kMsgStorageTimeFieldNumber;
const int Appinfo::kContactExpireTimeFieldNumber;
const int Appinfo::kP2PMaxQpsFieldNumber;
const int Appinfo::kP2TMaxQpsFieldNumber;
const int Appinfo::kUcMaxQpsFieldNumber;
const int Appinfo::kOfflineResourceCallbackUrlFieldNumber;
const int Appinfo::kOfflineMsgMaxCountFieldNumber;
#endif  // !_MSC_VER

Appinfo::Appinfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Appinfo::InitAsDefaultInstance() {
}

Appinfo::Appinfo(const Appinfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Appinfo::SharedCtor() {
  _cached_size_ = 0;
  appid_ = GOOGLE_ULONGLONG(0);
  msgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  offlinemsgcallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  uuidttl_ = GOOGLE_ULONGLONG(0);
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  messagefilter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  enableblacklist_ = false;
  topicmembercount_ = GOOGLE_LONGLONG(0);
  enableantispam_ = false;
  msgstoragetime_ = 0;
  contactexpiretime_ = 0;
  p2pmaxqps_ = 0;
  p2tmaxqps_ = 0;
  ucmaxqps_ = 0;
  offlineresourcecallbackurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  offlinemsgmaxcount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Appinfo::~Appinfo() {
  SharedDtor();
}

void Appinfo::SharedDtor() {
  if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcallbackurl_;
  }
  if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete offlinemsgcallbackurl_;
  }
  if (context_ != &::google::protobuf::internal::kEmptyString) {
    delete context_;
  }
  if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
    delete messagefilter_;
  }
  if (offlineresourcecallbackurl_ != &::google::protobuf::internal::kEmptyString) {
    delete offlineresourcecallbackurl_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Appinfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Appinfo& Appinfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

Appinfo* Appinfo::default_instance_ = NULL;

Appinfo* Appinfo::New() const {
  return new Appinfo;
}

void Appinfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    appid_ = GOOGLE_ULONGLONG(0);
    if (has_msgcallbackurl()) {
      if (msgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
        msgcallbackurl_->clear();
      }
    }
    if (has_offlinemsgcallbackurl()) {
      if (offlinemsgcallbackurl_ != &::google::protobuf::internal::kEmptyString) {
        offlinemsgcallbackurl_->clear();
      }
    }
    uuidttl_ = GOOGLE_ULONGLONG(0);
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::kEmptyString) {
        context_->clear();
      }
    }
    if (has_messagefilter()) {
      if (messagefilter_ != &::google::protobuf::internal::kEmptyString) {
        messagefilter_->clear();
      }
    }
    enableblacklist_ = false;
    topicmembercount_ = GOOGLE_LONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    enableantispam_ = false;
    msgstoragetime_ = 0;
    contactexpiretime_ = 0;
    p2pmaxqps_ = 0;
    p2tmaxqps_ = 0;
    ucmaxqps_ = 0;
    if (has_offlineresourcecallbackurl()) {
      if (offlineresourcecallbackurl_ != &::google::protobuf::internal::kEmptyString) {
        offlineresourcecallbackurl_->clear();
      }
    }
    offlinemsgmaxcount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Appinfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 appId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_msgCallbackUrl;
        break;
      }

      // optional string msgCallbackUrl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msgCallbackUrl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msgcallbackurl()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_offlineMsgCallbackUrl;
        break;
      }

      // optional string offlineMsgCallbackUrl = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offlineMsgCallbackUrl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_offlinemsgcallbackurl()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_uuidTTL;
        break;
      }

      // optional uint64 uuidTTL = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuidTTL:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuidttl_)));
          set_has_uuidttl();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_context;
        break;
      }

      // optional string context = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_context()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_messageFilter;
        break;
      }

      // optional string messageFilter = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_messageFilter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_messagefilter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_enableBlacklist;
        break;
      }

      // optional bool enableBlacklist = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enableBlacklist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enableblacklist_)));
          set_has_enableblacklist();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_topicMemberCount;
        break;
      }

      // optional int64 topicMemberCount = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_topicMemberCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &topicmembercount_)));
          set_has_topicmembercount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_enableAntiSpam;
        break;
      }

      // optional bool enableAntiSpam = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enableAntiSpam:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enableantispam_)));
          set_has_enableantispam();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_msgStorageTime;
        break;
      }

      // optional int32 msgStorageTime = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_msgStorageTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &msgstoragetime_)));
          set_has_msgstoragetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_contactExpireTime;
        break;
      }

      // optional int32 contactExpireTime = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contactExpireTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contactexpiretime_)));
          set_has_contactexpiretime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_p2pMaxQps;
        break;
      }

      // optional int32 p2pMaxQps = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_p2pMaxQps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &p2pmaxqps_)));
          set_has_p2pmaxqps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_p2tMaxQps;
        break;
      }

      // optional int32 p2tMaxQps = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_p2tMaxQps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &p2tmaxqps_)));
          set_has_p2tmaxqps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_ucMaxQps;
        break;
      }

      // optional int32 ucMaxQps = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ucMaxQps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ucmaxqps_)));
          set_has_ucmaxqps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_offlineResourceCallbackUrl;
        break;
      }

      // optional string offlineResourceCallbackUrl = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offlineResourceCallbackUrl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_offlineresourcecallbackurl()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_offlineMsgMaxCount;
        break;
      }

      // optional int32 offlineMsgMaxCount = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offlineMsgMaxCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &offlinemsgmaxcount_)));
          set_has_offlinemsgmaxcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Appinfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 appId = 1;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->appid(), output);
  }

  // optional string msgCallbackUrl = 2;
  if (has_msgcallbackurl()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->msgcallbackurl(), output);
  }

  // optional string offlineMsgCallbackUrl = 3;
  if (has_offlinemsgcallbackurl()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->offlinemsgcallbackurl(), output);
  }

  // optional uint64 uuidTTL = 4;
  if (has_uuidttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->uuidttl(), output);
  }

  // optional string context = 5;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->context(), output);
  }

  // optional string messageFilter = 6;
  if (has_messagefilter()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->messagefilter(), output);
  }

  // optional bool enableBlacklist = 7;
  if (has_enableblacklist()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->enableblacklist(), output);
  }

  // optional int64 topicMemberCount = 8;
  if (has_topicmembercount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->topicmembercount(), output);
  }

  // optional bool enableAntiSpam = 9;
  if (has_enableantispam()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->enableantispam(), output);
  }

  // optional int32 msgStorageTime = 10;
  if (has_msgstoragetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->msgstoragetime(), output);
  }

  // optional int32 contactExpireTime = 11;
  if (has_contactexpiretime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->contactexpiretime(), output);
  }

  // optional int32 p2pMaxQps = 12;
  if (has_p2pmaxqps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->p2pmaxqps(), output);
  }

  // optional int32 p2tMaxQps = 13;
  if (has_p2tmaxqps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->p2tmaxqps(), output);
  }

  // optional int32 ucMaxQps = 14;
  if (has_ucmaxqps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->ucmaxqps(), output);
  }

  // optional string offlineResourceCallbackUrl = 15;
  if (has_offlineresourcecallbackurl()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->offlineresourcecallbackurl(), output);
  }

  // optional int32 offlineMsgMaxCount = 16;
  if (has_offlinemsgmaxcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->offlinemsgmaxcount(), output);
  }

}

int Appinfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 appId = 1;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional string msgCallbackUrl = 2;
    if (has_msgcallbackurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msgcallbackurl());
    }

    // optional string offlineMsgCallbackUrl = 3;
    if (has_offlinemsgcallbackurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->offlinemsgcallbackurl());
    }

    // optional uint64 uuidTTL = 4;
    if (has_uuidttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuidttl());
    }

    // optional string context = 5;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->context());
    }

    // optional string messageFilter = 6;
    if (has_messagefilter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->messagefilter());
    }

    // optional bool enableBlacklist = 7;
    if (has_enableblacklist()) {
      total_size += 1 + 1;
    }

    // optional int64 topicMemberCount = 8;
    if (has_topicmembercount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->topicmembercount());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool enableAntiSpam = 9;
    if (has_enableantispam()) {
      total_size += 1 + 1;
    }

    // optional int32 msgStorageTime = 10;
    if (has_msgstoragetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->msgstoragetime());
    }

    // optional int32 contactExpireTime = 11;
    if (has_contactexpiretime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contactexpiretime());
    }

    // optional int32 p2pMaxQps = 12;
    if (has_p2pmaxqps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->p2pmaxqps());
    }

    // optional int32 p2tMaxQps = 13;
    if (has_p2tmaxqps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->p2tmaxqps());
    }

    // optional int32 ucMaxQps = 14;
    if (has_ucmaxqps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ucmaxqps());
    }

    // optional string offlineResourceCallbackUrl = 15;
    if (has_offlineresourcecallbackurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->offlineresourcecallbackurl());
    }

    // optional int32 offlineMsgMaxCount = 16;
    if (has_offlinemsgmaxcount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->offlinemsgmaxcount());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Appinfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Appinfo*>(&from));
}

void Appinfo::MergeFrom(const Appinfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_msgcallbackurl()) {
      set_msgcallbackurl(from.msgcallbackurl());
    }
    if (from.has_offlinemsgcallbackurl()) {
      set_offlinemsgcallbackurl(from.offlinemsgcallbackurl());
    }
    if (from.has_uuidttl()) {
      set_uuidttl(from.uuidttl());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_messagefilter()) {
      set_messagefilter(from.messagefilter());
    }
    if (from.has_enableblacklist()) {
      set_enableblacklist(from.enableblacklist());
    }
    if (from.has_topicmembercount()) {
      set_topicmembercount(from.topicmembercount());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_enableantispam()) {
      set_enableantispam(from.enableantispam());
    }
    if (from.has_msgstoragetime()) {
      set_msgstoragetime(from.msgstoragetime());
    }
    if (from.has_contactexpiretime()) {
      set_contactexpiretime(from.contactexpiretime());
    }
    if (from.has_p2pmaxqps()) {
      set_p2pmaxqps(from.p2pmaxqps());
    }
    if (from.has_p2tmaxqps()) {
      set_p2tmaxqps(from.p2tmaxqps());
    }
    if (from.has_ucmaxqps()) {
      set_ucmaxqps(from.ucmaxqps());
    }
    if (from.has_offlineresourcecallbackurl()) {
      set_offlineresourcecallbackurl(from.offlineresourcecallbackurl());
    }
    if (from.has_offlinemsgmaxcount()) {
      set_offlinemsgmaxcount(from.offlinemsgmaxcount());
    }
  }
}

void Appinfo::CopyFrom(const Appinfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Appinfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Appinfo::Swap(Appinfo* other) {
  if (other != this) {
    std::swap(appid_, other->appid_);
    std::swap(msgcallbackurl_, other->msgcallbackurl_);
    std::swap(offlinemsgcallbackurl_, other->offlinemsgcallbackurl_);
    std::swap(uuidttl_, other->uuidttl_);
    std::swap(context_, other->context_);
    std::swap(messagefilter_, other->messagefilter_);
    std::swap(enableblacklist_, other->enableblacklist_);
    std::swap(topicmembercount_, other->topicmembercount_);
    std::swap(enableantispam_, other->enableantispam_);
    std::swap(msgstoragetime_, other->msgstoragetime_);
    std::swap(contactexpiretime_, other->contactexpiretime_);
    std::swap(p2pmaxqps_, other->p2pmaxqps_);
    std::swap(p2tmaxqps_, other->p2tmaxqps_);
    std::swap(ucmaxqps_, other->ucmaxqps_);
    std::swap(offlineresourcecallbackurl_, other->offlineresourcecallbackurl_);
    std::swap(offlinemsgmaxcount_, other->offlinemsgmaxcount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Appinfo::GetTypeName() const {
  return "mimc.Appinfo";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCPacket::kPacketIdFieldNumber;
const int MIMCPacket::kPackageFieldNumber;
const int MIMCPacket::kSequenceFieldNumber;
const int MIMCPacket::kTypeFieldNumber;
const int MIMCPacket::kPayloadFieldNumber;
const int MIMCPacket::kTimestampFieldNumber;
const int MIMCPacket::kConversationFieldNumber;
const int MIMCPacket::kConvIndexFieldNumber;
#endif  // !_MSC_VER

MIMCPacket::MIMCPacket()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCPacket::InitAsDefaultInstance() {
}

MIMCPacket::MIMCPacket(const MIMCPacket& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCPacket::SharedCtor() {
  _cached_size_ = 0;
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = GOOGLE_LONGLONG(0);
  type_ = 1;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  timestamp_ = GOOGLE_LONGLONG(0);
  conversation_ = false;
  convindex_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCPacket::~MIMCPacket() {
  SharedDtor();
}

void MIMCPacket::SharedDtor() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCPacket& MIMCPacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCPacket* MIMCPacket::default_instance_ = NULL;

MIMCPacket* MIMCPacket::New() const {
  return new MIMCPacket;
}

void MIMCPacket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
    if (has_package()) {
      if (package_ != &::google::protobuf::internal::kEmptyString) {
        package_->clear();
      }
    }
    sequence_ = GOOGLE_LONGLONG(0);
    type_ = 1;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    timestamp_ = GOOGLE_LONGLONG(0);
    conversation_ = false;
    convindex_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string packetId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_package;
        break;
      }

      // optional string package = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sequence;
        break;
      }

      // optional int64 sequence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .mimc.MIMC_MSG_TYPE type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::MIMC_MSG_TYPE_IsValid(value)) {
            set_type(static_cast< ::mimc::MIMC_MSG_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_payload;
        break;
      }

      // optional bytes payload = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_conversation;
        break;
      }

      // optional bool conversation = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_conversation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &conversation_)));
          set_has_conversation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_convIndex;
        break;
      }

      // optional int64 convIndex = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_convIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &convindex_)));
          set_has_convindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string packetId = 1;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->packetid(), output);
  }

  // optional string package = 2;
  if (has_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->package(), output);
  }

  // optional int64 sequence = 3;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->sequence(), output);
  }

  // optional .mimc.MIMC_MSG_TYPE type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional bytes payload = 5;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->payload(), output);
  }

  // optional int64 timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->timestamp(), output);
  }

  // optional bool conversation = 7;
  if (has_conversation()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->conversation(), output);
  }

  // optional int64 convIndex = 8;
  if (has_convindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->convindex(), output);
  }

}

int MIMCPacket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string packetId = 1;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

    // optional string package = 2;
    if (has_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package());
    }

    // optional int64 sequence = 3;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence());
    }

    // optional .mimc.MIMC_MSG_TYPE type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bytes payload = 5;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional int64 timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional bool conversation = 7;
    if (has_conversation()) {
      total_size += 1 + 1;
    }

    // optional int64 convIndex = 8;
    if (has_convindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->convindex());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCPacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCPacket*>(&from));
}

void MIMCPacket::MergeFrom(const MIMCPacket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
    if (from.has_package()) {
      set_package(from.package());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_conversation()) {
      set_conversation(from.conversation());
    }
    if (from.has_convindex()) {
      set_convindex(from.convindex());
    }
  }
}

void MIMCPacket::CopyFrom(const MIMCPacket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCPacket::IsInitialized() const {

  return true;
}

void MIMCPacket::Swap(MIMCPacket* other) {
  if (other != this) {
    std::swap(packetid_, other->packetid_);
    std::swap(package_, other->package_);
    std::swap(sequence_, other->sequence_);
    std::swap(type_, other->type_);
    std::swap(payload_, other->payload_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(conversation_, other->conversation_);
    std::swap(convindex_, other->convindex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCPacket::GetTypeName() const {
  return "mimc.MIMCPacket";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCPacketList::kUuidFieldNumber;
const int MIMCPacketList::kResourceFieldNumber;
const int MIMCPacketList::kMaxSequenceFieldNumber;
const int MIMCPacketList::kPacketsFieldNumber;
const int MIMCPacketList::kStatusFieldNumber;
#endif  // !_MSC_VER

MIMCPacketList::MIMCPacketList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCPacketList::InitAsDefaultInstance() {
}

MIMCPacketList::MIMCPacketList(const MIMCPacketList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCPacketList::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  maxsequence_ = GOOGLE_LONGLONG(0);
  status_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCPacketList::~MIMCPacketList() {
  SharedDtor();
}

void MIMCPacketList::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCPacketList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCPacketList& MIMCPacketList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCPacketList* MIMCPacketList::default_instance_ = NULL;

MIMCPacketList* MIMCPacketList::New() const {
  return new MIMCPacketList;
}

void MIMCPacketList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    maxsequence_ = GOOGLE_LONGLONG(0);
    status_ = 1;
  }
  packets_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCPacketList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_resource;
        break;
      }

      // optional string resource = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_maxSequence;
        break;
      }

      // optional int64 maxSequence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxSequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxsequence_)));
          set_has_maxsequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_packets;
        break;
      }

      // repeated .mimc.MIMCPacket packets = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_packets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_packets;
        if (input->ExpectTag(40)) goto parse_status;
        break;
      }

      // optional .mimc.MIMC_PUSH_STATUS status = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::MIMC_PUSH_STATUS_IsValid(value)) {
            set_status(static_cast< ::mimc::MIMC_PUSH_STATUS >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCPacketList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uuid(), output);
  }

  // optional string resource = 2;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->resource(), output);
  }

  // optional int64 maxSequence = 3;
  if (has_maxsequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->maxsequence(), output);
  }

  // repeated .mimc.MIMCPacket packets = 4;
  for (int i = 0; i < this->packets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->packets(i), output);
  }

  // optional .mimc.MIMC_PUSH_STATUS status = 5;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->status(), output);
  }

}

int MIMCPacketList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // optional string resource = 2;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional int64 maxSequence = 3;
    if (has_maxsequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxsequence());
    }

    // optional .mimc.MIMC_PUSH_STATUS status = 5;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  // repeated .mimc.MIMCPacket packets = 4;
  total_size += 1 * this->packets_size();
  for (int i = 0; i < this->packets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->packets(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCPacketList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCPacketList*>(&from));
}

void MIMCPacketList::MergeFrom(const MIMCPacketList& from) {
  GOOGLE_CHECK_NE(&from, this);
  packets_.MergeFrom(from.packets_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_maxsequence()) {
      set_maxsequence(from.maxsequence());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void MIMCPacketList::CopyFrom(const MIMCPacketList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCPacketList::IsInitialized() const {

  return true;
}

void MIMCPacketList::Swap(MIMCPacketList* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(maxsequence_, other->maxsequence_);
    packets_.Swap(&other->packets_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCPacketList::GetTypeName() const {
  return "mimc.MIMCPacketList";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCPacketAck::kPacketIdFieldNumber;
const int MIMCPacketAck::kUuidFieldNumber;
const int MIMCPacketAck::kResourceFieldNumber;
const int MIMCPacketAck::kSequenceFieldNumber;
const int MIMCPacketAck::kTimestampFieldNumber;
const int MIMCPacketAck::kPackageFieldNumber;
const int MIMCPacketAck::kErrorMsgFieldNumber;
const int MIMCPacketAck::kCodeFieldNumber;
const int MIMCPacketAck::kConvIndexFieldNumber;
#endif  // !_MSC_VER

MIMCPacketAck::MIMCPacketAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCPacketAck::InitAsDefaultInstance() {
}

MIMCPacketAck::MIMCPacketAck(const MIMCPacketAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCPacketAck::SharedCtor() {
  _cached_size_ = 0;
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = GOOGLE_LONGLONG(0);
  timestamp_ = GOOGLE_LONGLONG(0);
  package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  code_ = 0;
  convindex_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCPacketAck::~MIMCPacketAck() {
  SharedDtor();
}

void MIMCPacketAck::SharedDtor() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errormsg_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCPacketAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCPacketAck& MIMCPacketAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCPacketAck* MIMCPacketAck::default_instance_ = NULL;

MIMCPacketAck* MIMCPacketAck::New() const {
  return new MIMCPacketAck;
}

void MIMCPacketAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    sequence_ = GOOGLE_LONGLONG(0);
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_package()) {
      if (package_ != &::google::protobuf::internal::kEmptyString) {
        package_->clear();
      }
    }
    if (has_errormsg()) {
      if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
        errormsg_->clear();
      }
    }
    code_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    convindex_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCPacketAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string packetId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_uuid;
        break;
      }

      // optional uint64 uuid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_resource;
        break;
      }

      // optional string resource = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sequence;
        break;
      }

      // optional int64 sequence = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_package;
        break;
      }

      // optional string package = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_errorMsg;
        break;
      }

      // optional string errorMsg = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_errorMsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errormsg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_code;
        break;
      }

      // optional int32 code = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_convIndex;
        break;
      }

      // optional int64 convIndex = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_convIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &convindex_)));
          set_has_convindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCPacketAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string packetId = 1;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->packetid(), output);
  }

  // optional uint64 uuid = 2;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->uuid(), output);
  }

  // optional string resource = 3;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->resource(), output);
  }

  // optional int64 sequence = 4;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->sequence(), output);
  }

  // optional int64 timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->timestamp(), output);
  }

  // optional string package = 6;
  if (has_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->package(), output);
  }

  // optional string errorMsg = 7;
  if (has_errormsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->errormsg(), output);
  }

  // optional int32 code = 8;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->code(), output);
  }

  // optional int64 convIndex = 9;
  if (has_convindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->convindex(), output);
  }

}

int MIMCPacketAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string packetId = 1;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

    // optional uint64 uuid = 2;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // optional string resource = 3;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional int64 sequence = 4;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence());
    }

    // optional int64 timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional string package = 6;
    if (has_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package());
    }

    // optional string errorMsg = 7;
    if (has_errormsg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errormsg());
    }

    // optional int32 code = 8;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 convIndex = 9;
    if (has_convindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->convindex());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCPacketAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCPacketAck*>(&from));
}

void MIMCPacketAck::MergeFrom(const MIMCPacketAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_package()) {
      set_package(from.package());
    }
    if (from.has_errormsg()) {
      set_errormsg(from.errormsg());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_convindex()) {
      set_convindex(from.convindex());
    }
  }
}

void MIMCPacketAck::CopyFrom(const MIMCPacketAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCPacketAck::IsInitialized() const {

  return true;
}

void MIMCPacketAck::Swap(MIMCPacketAck* other) {
  if (other != this) {
    std::swap(packetid_, other->packetid_);
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(sequence_, other->sequence_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(package_, other->package_);
    std::swap(errormsg_, other->errormsg_);
    std::swap(code_, other->code_);
    std::swap(convindex_, other->convindex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCPacketAck::GetTypeName() const {
  return "mimc.MIMCPacketAck";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCP2PMessage::kFromFieldNumber;
const int MIMCP2PMessage::kToFieldNumber;
const int MIMCP2PMessage::kPayloadFieldNumber;
const int MIMCP2PMessage::kIsStoreFieldNumber;
const int MIMCP2PMessage::kBizTypeFieldNumber;
#endif  // !_MSC_VER

MIMCP2PMessage::MIMCP2PMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCP2PMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  from_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  from_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  to_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  to_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

MIMCP2PMessage::MIMCP2PMessage(const MIMCP2PMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCP2PMessage::SharedCtor() {
  _cached_size_ = 0;
  from_ = NULL;
  to_ = NULL;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isstore_ = false;
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCP2PMessage::~MIMCP2PMessage() {
  SharedDtor();
}

void MIMCP2PMessage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete from_;
    delete to_;
  }
}

void MIMCP2PMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCP2PMessage& MIMCP2PMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCP2PMessage* MIMCP2PMessage::default_instance_ = NULL;

MIMCP2PMessage* MIMCP2PMessage::New() const {
  return new MIMCP2PMessage;
}

void MIMCP2PMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
    }
    if (has_to()) {
      if (to_ != NULL) to_->::mimc::MIMCUser::Clear();
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    isstore_ = false;
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCP2PMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.MIMCUser from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // optional .mimc.MIMCUser to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // optional bytes payload = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bizType;
        break;
      }

      // optional string bizType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCP2PMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.MIMCUser from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->from(), output);
  }

  // optional .mimc.MIMCUser to = 2;
  if (has_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->to(), output);
  }

  // optional bytes payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payload(), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional string bizType = 5;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->biztype(), output);
  }

}

int MIMCP2PMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.MIMCUser from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from());
    }

    // optional .mimc.MIMCUser to = 2;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->to());
    }

    // optional bytes payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional string bizType = 5;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCP2PMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCP2PMessage*>(&from));
}

void MIMCP2PMessage::MergeFrom(const MIMCP2PMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      mutable_from()->::mimc::MIMCUser::MergeFrom(from.from());
    }
    if (from.has_to()) {
      mutable_to()->::mimc::MIMCUser::MergeFrom(from.to());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
  }
}

void MIMCP2PMessage::CopyFrom(const MIMCP2PMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCP2PMessage::IsInitialized() const {

  return true;
}

void MIMCP2PMessage::Swap(MIMCP2PMessage* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(to_, other->to_);
    std::swap(payload_, other->payload_);
    std::swap(isstore_, other->isstore_);
    std::swap(biztype_, other->biztype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCP2PMessage::GetTypeName() const {
  return "mimc.MIMCP2PMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCP2TMessage::kFromFieldNumber;
const int MIMCP2TMessage::kToFieldNumber;
const int MIMCP2TMessage::kPayloadFieldNumber;
const int MIMCP2TMessage::kIsStoreFieldNumber;
const int MIMCP2TMessage::kBizTypeFieldNumber;
#endif  // !_MSC_VER

MIMCP2TMessage::MIMCP2TMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCP2TMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  from_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  from_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  to_ = const_cast< ::mimc::MIMCGroup*>(
      ::mimc::MIMCGroup::internal_default_instance());
#else
  to_ = const_cast< ::mimc::MIMCGroup*>(&::mimc::MIMCGroup::default_instance());
#endif
}

MIMCP2TMessage::MIMCP2TMessage(const MIMCP2TMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCP2TMessage::SharedCtor() {
  _cached_size_ = 0;
  from_ = NULL;
  to_ = NULL;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isstore_ = false;
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCP2TMessage::~MIMCP2TMessage() {
  SharedDtor();
}

void MIMCP2TMessage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete from_;
    delete to_;
  }
}

void MIMCP2TMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCP2TMessage& MIMCP2TMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCP2TMessage* MIMCP2TMessage::default_instance_ = NULL;

MIMCP2TMessage* MIMCP2TMessage::New() const {
  return new MIMCP2TMessage;
}

void MIMCP2TMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
    }
    if (has_to()) {
      if (to_ != NULL) to_->::mimc::MIMCGroup::Clear();
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    isstore_ = false;
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCP2TMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.MIMCUser from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // optional .mimc.MIMCGroup to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // optional bytes payload = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bizType;
        break;
      }

      // optional string bizType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCP2TMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.MIMCUser from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->from(), output);
  }

  // optional .mimc.MIMCGroup to = 2;
  if (has_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->to(), output);
  }

  // optional bytes payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payload(), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional string bizType = 5;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->biztype(), output);
  }

}

int MIMCP2TMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.MIMCUser from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from());
    }

    // optional .mimc.MIMCGroup to = 2;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->to());
    }

    // optional bytes payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional string bizType = 5;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCP2TMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCP2TMessage*>(&from));
}

void MIMCP2TMessage::MergeFrom(const MIMCP2TMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      mutable_from()->::mimc::MIMCUser::MergeFrom(from.from());
    }
    if (from.has_to()) {
      mutable_to()->::mimc::MIMCGroup::MergeFrom(from.to());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
  }
}

void MIMCP2TMessage::CopyFrom(const MIMCP2TMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCP2TMessage::IsInitialized() const {

  return true;
}

void MIMCP2TMessage::Swap(MIMCP2TMessage* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    std::swap(to_, other->to_);
    std::swap(payload_, other->payload_);
    std::swap(isstore_, other->isstore_);
    std::swap(biztype_, other->biztype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCP2TMessage::GetTypeName() const {
  return "mimc.MIMCP2TMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCSequenceAck::kUuidFieldNumber;
const int MIMCSequenceAck::kResourceFieldNumber;
const int MIMCSequenceAck::kSequenceFieldNumber;
const int MIMCSequenceAck::kAppIdFieldNumber;
#endif  // !_MSC_VER

MIMCSequenceAck::MIMCSequenceAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCSequenceAck::InitAsDefaultInstance() {
}

MIMCSequenceAck::MIMCSequenceAck(const MIMCSequenceAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCSequenceAck::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = GOOGLE_LONGLONG(0);
  appid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCSequenceAck::~MIMCSequenceAck() {
  SharedDtor();
}

void MIMCSequenceAck::SharedDtor() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCSequenceAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCSequenceAck& MIMCSequenceAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCSequenceAck* MIMCSequenceAck::default_instance_ = NULL;

MIMCSequenceAck* MIMCSequenceAck::New() const {
  return new MIMCSequenceAck;
}

void MIMCSequenceAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
    sequence_ = GOOGLE_LONGLONG(0);
    appid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCSequenceAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_resource;
        break;
      }

      // optional string resource = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sequence;
        break;
      }

      // optional int64 sequence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_appId;
        break;
      }

      // optional uint64 appId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCSequenceAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uuid(), output);
  }

  // optional string resource = 2;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->resource(), output);
  }

  // optional int64 sequence = 3;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->sequence(), output);
  }

  // optional uint64 appId = 4;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->appid(), output);
  }

}

int MIMCSequenceAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // optional string resource = 2;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

    // optional int64 sequence = 3;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence());
    }

    // optional uint64 appId = 4;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCSequenceAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCSequenceAck*>(&from));
}

void MIMCSequenceAck::MergeFrom(const MIMCSequenceAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_appid()) {
      set_appid(from.appid());
    }
  }
}

void MIMCSequenceAck::CopyFrom(const MIMCSequenceAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCSequenceAck::IsInitialized() const {

  return true;
}

void MIMCSequenceAck::Swap(MIMCSequenceAck* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(sequence_, other->sequence_);
    std::swap(appid_, other->appid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCSequenceAck::GetTypeName() const {
  return "mimc.MIMCSequenceAck";
}


// ===================================================================

#ifndef _MSC_VER
const int P2PPushMesage::kFromFieldNumber;
const int P2PPushMesage::kToFieldNumber;
const int P2PPushMesage::kPayloadFieldNumber;
const int P2PPushMesage::kIsStoreFieldNumber;
const int P2PPushMesage::kBizTypeFieldNumber;
const int P2PPushMesage::kIsSystemMsgFieldNumber;
#endif  // !_MSC_VER

P2PPushMesage::P2PPushMesage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void P2PPushMesage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  from_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  from_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

P2PPushMesage::P2PPushMesage(const P2PPushMesage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void P2PPushMesage::SharedCtor() {
  _cached_size_ = 0;
  from_ = NULL;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isstore_ = false;
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  issystemmsg_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2PPushMesage::~P2PPushMesage() {
  SharedDtor();
}

void P2PPushMesage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete from_;
  }
}

void P2PPushMesage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const P2PPushMesage& P2PPushMesage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

P2PPushMesage* P2PPushMesage::default_instance_ = NULL;

P2PPushMesage* P2PPushMesage::New() const {
  return new P2PPushMesage;
}

void P2PPushMesage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    isstore_ = false;
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
    issystemmsg_ = false;
  }
  to_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool P2PPushMesage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.MIMCUser from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // repeated .mimc.MIMCUser to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // optional bytes payload = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bizType;
        break;
      }

      // optional string bizType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_isSystemMsg;
        break;
      }

      // optional bool isSystemMsg = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isSystemMsg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issystemmsg_)));
          set_has_issystemmsg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2PPushMesage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.MIMCUser from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->from(), output);
  }

  // repeated .mimc.MIMCUser to = 2;
  for (int i = 0; i < this->to_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->to(i), output);
  }

  // optional bytes payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payload(), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional string bizType = 5;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->biztype(), output);
  }

  // optional bool isSystemMsg = 6;
  if (has_issystemmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->issystemmsg(), output);
  }

}

int P2PPushMesage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.MIMCUser from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from());
    }

    // optional bytes payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional string bizType = 5;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

    // optional bool isSystemMsg = 6;
    if (has_issystemmsg()) {
      total_size += 1 + 1;
    }

  }
  // repeated .mimc.MIMCUser to = 2;
  total_size += 1 * this->to_size();
  for (int i = 0; i < this->to_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->to(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PPushMesage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const P2PPushMesage*>(&from));
}

void P2PPushMesage::MergeFrom(const P2PPushMesage& from) {
  GOOGLE_CHECK_NE(&from, this);
  to_.MergeFrom(from.to_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      mutable_from()->::mimc::MIMCUser::MergeFrom(from.from());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
    if (from.has_issystemmsg()) {
      set_issystemmsg(from.issystemmsg());
    }
  }
}

void P2PPushMesage::CopyFrom(const P2PPushMesage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PPushMesage::IsInitialized() const {

  return true;
}

void P2PPushMesage::Swap(P2PPushMesage* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    to_.Swap(&other->to_);
    std::swap(payload_, other->payload_);
    std::swap(isstore_, other->isstore_);
    std::swap(biztype_, other->biztype_);
    std::swap(issystemmsg_, other->issystemmsg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string P2PPushMesage::GetTypeName() const {
  return "mimc.P2PPushMesage";
}


// ===================================================================

#ifndef _MSC_VER
const int P2TPushMesage::kFromFieldNumber;
const int P2TPushMesage::kToFieldNumber;
const int P2TPushMesage::kPayloadFieldNumber;
const int P2TPushMesage::kIsStoreFieldNumber;
const int P2TPushMesage::kBizTypeFieldNumber;
const int P2TPushMesage::kIsSystemMsgFieldNumber;
#endif  // !_MSC_VER

P2TPushMesage::P2TPushMesage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void P2TPushMesage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  from_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  from_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

P2TPushMesage::P2TPushMesage(const P2TPushMesage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void P2TPushMesage::SharedCtor() {
  _cached_size_ = 0;
  from_ = NULL;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isstore_ = false;
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  issystemmsg_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2TPushMesage::~P2TPushMesage() {
  SharedDtor();
}

void P2TPushMesage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete from_;
  }
}

void P2TPushMesage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const P2TPushMesage& P2TPushMesage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

P2TPushMesage* P2TPushMesage::default_instance_ = NULL;

P2TPushMesage* P2TPushMesage::New() const {
  return new P2TPushMesage;
}

void P2TPushMesage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from()) {
      if (from_ != NULL) from_->::mimc::MIMCUser::Clear();
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    isstore_ = false;
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
    issystemmsg_ = false;
  }
  to_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool P2TPushMesage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.MIMCUser from = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        break;
      }

      // repeated .mimc.MIMCGroup to = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_to()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to;
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // optional bytes payload = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_bizType;
        break;
      }

      // optional string bizType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_isSystemMsg;
        break;
      }

      // optional bool isSystemMsg = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isSystemMsg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issystemmsg_)));
          set_has_issystemmsg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2TPushMesage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.MIMCUser from = 1;
  if (has_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->from(), output);
  }

  // repeated .mimc.MIMCGroup to = 2;
  for (int i = 0; i < this->to_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->to(i), output);
  }

  // optional bytes payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payload(), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional string bizType = 5;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->biztype(), output);
  }

  // optional bool isSystemMsg = 6;
  if (has_issystemmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->issystemmsg(), output);
  }

}

int P2TPushMesage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.MIMCUser from = 1;
    if (has_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from());
    }

    // optional bytes payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional string bizType = 5;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

    // optional bool isSystemMsg = 6;
    if (has_issystemmsg()) {
      total_size += 1 + 1;
    }

  }
  // repeated .mimc.MIMCGroup to = 2;
  total_size += 1 * this->to_size();
  for (int i = 0; i < this->to_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->to(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2TPushMesage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const P2TPushMesage*>(&from));
}

void P2TPushMesage::MergeFrom(const P2TPushMesage& from) {
  GOOGLE_CHECK_NE(&from, this);
  to_.MergeFrom(from.to_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from()) {
      mutable_from()->::mimc::MIMCUser::MergeFrom(from.from());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
    if (from.has_issystemmsg()) {
      set_issystemmsg(from.issystemmsg());
    }
  }
}

void P2TPushMesage::CopyFrom(const P2TPushMesage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2TPushMesage::IsInitialized() const {

  return true;
}

void P2TPushMesage::Swap(P2TPushMesage* other) {
  if (other != this) {
    std::swap(from_, other->from_);
    to_.Swap(&other->to_);
    std::swap(payload_, other->payload_);
    std::swap(isstore_, other->isstore_);
    std::swap(biztype_, other->biztype_);
    std::swap(issystemmsg_, other->issystemmsg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string P2TPushMesage::GetTypeName() const {
  return "mimc.P2TPushMesage";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCUser::kAppIdFieldNumber;
const int MIMCUser::kAppAccountFieldNumber;
const int MIMCUser::kUuidFieldNumber;
const int MIMCUser::kResourceFieldNumber;
#endif  // !_MSC_VER

MIMCUser::MIMCUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCUser::InitAsDefaultInstance() {
}

MIMCUser::MIMCUser(const MIMCUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCUser::SharedCtor() {
  _cached_size_ = 0;
  appid_ = GOOGLE_ULONGLONG(0);
  appaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  uuid_ = GOOGLE_ULONGLONG(0);
  resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCUser::~MIMCUser() {
  SharedDtor();
}

void MIMCUser::SharedDtor() {
  if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
    delete appaccount_;
  }
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCUser& MIMCUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCUser* MIMCUser::default_instance_ = NULL;

MIMCUser* MIMCUser::New() const {
  return new MIMCUser;
}

void MIMCUser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    appid_ = GOOGLE_ULONGLONG(0);
    if (has_appaccount()) {
      if (appaccount_ != &::google::protobuf::internal::kEmptyString) {
        appaccount_->clear();
      }
    }
    uuid_ = GOOGLE_ULONGLONG(0);
    if (has_resource()) {
      if (resource_ != &::google::protobuf::internal::kEmptyString) {
        resource_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 appId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_appAccount;
        break;
      }

      // optional string appAccount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_appAccount:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_appaccount()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_uuid;
        break;
      }

      // optional uint64 uuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_resource;
        break;
      }

      // optional string resource = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 appId = 1;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->appid(), output);
  }

  // optional string appAccount = 2;
  if (has_appaccount()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->appaccount(), output);
  }

  // optional uint64 uuid = 3;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->uuid(), output);
  }

  // optional string resource = 4;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->resource(), output);
  }

}

int MIMCUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 appId = 1;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional string appAccount = 2;
    if (has_appaccount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->appaccount());
    }

    // optional uint64 uuid = 3;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uuid());
    }

    // optional string resource = 4;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resource());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCUser*>(&from));
}

void MIMCUser::MergeFrom(const MIMCUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_appaccount()) {
      set_appaccount(from.appaccount());
    }
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_resource()) {
      set_resource(from.resource());
    }
  }
}

void MIMCUser::CopyFrom(const MIMCUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCUser::IsInitialized() const {

  return true;
}

void MIMCUser::Swap(MIMCUser* other) {
  if (other != this) {
    std::swap(appid_, other->appid_);
    std::swap(appaccount_, other->appaccount_);
    std::swap(uuid_, other->uuid_);
    std::swap(resource_, other->resource_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCUser::GetTypeName() const {
  return "mimc.MIMCUser";
}


// ===================================================================

#ifndef _MSC_VER
const int MIMCGroup::kAppIdFieldNumber;
const int MIMCGroup::kTopicIdFieldNumber;
#endif  // !_MSC_VER

MIMCGroup::MIMCGroup()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MIMCGroup::InitAsDefaultInstance() {
}

MIMCGroup::MIMCGroup(const MIMCGroup& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MIMCGroup::SharedCtor() {
  _cached_size_ = 0;
  appid_ = GOOGLE_ULONGLONG(0);
  topicid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MIMCGroup::~MIMCGroup() {
  SharedDtor();
}

void MIMCGroup::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MIMCGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MIMCGroup& MIMCGroup::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

MIMCGroup* MIMCGroup::default_instance_ = NULL;

MIMCGroup* MIMCGroup::New() const {
  return new MIMCGroup;
}

void MIMCGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    appid_ = GOOGLE_ULONGLONG(0);
    topicid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MIMCGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 appId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_topicId;
        break;
      }

      // optional uint64 topicId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_topicId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &topicid_)));
          set_has_topicid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MIMCGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 appId = 1;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->appid(), output);
  }

  // optional uint64 topicId = 2;
  if (has_topicid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->topicid(), output);
  }

}

int MIMCGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 appId = 1;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional uint64 topicId = 2;
    if (has_topicid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->topicid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MIMCGroup::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MIMCGroup*>(&from));
}

void MIMCGroup::MergeFrom(const MIMCGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_topicid()) {
      set_topicid(from.topicid());
    }
  }
}

void MIMCGroup::CopyFrom(const MIMCGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MIMCGroup::IsInitialized() const {

  return true;
}

void MIMCGroup::Swap(MIMCGroup* other) {
  if (other != this) {
    std::swap(appid_, other->appid_);
    std::swap(topicid_, other->topicid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MIMCGroup::GetTypeName() const {
  return "mimc.MIMCGroup";
}


// ===================================================================

#ifndef _MSC_VER
const int UCGroup::kAppIdFieldNumber;
const int UCGroup::kTopicIdFieldNumber;
#endif  // !_MSC_VER

UCGroup::UCGroup()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCGroup::InitAsDefaultInstance() {
}

UCGroup::UCGroup(const UCGroup& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCGroup::SharedCtor() {
  _cached_size_ = 0;
  appid_ = GOOGLE_ULONGLONG(0);
  topicid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCGroup::~UCGroup() {
  SharedDtor();
}

void UCGroup::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UCGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCGroup& UCGroup::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCGroup* UCGroup::default_instance_ = NULL;

UCGroup* UCGroup::New() const {
  return new UCGroup;
}

void UCGroup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    appid_ = GOOGLE_ULONGLONG(0);
    topicid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 appId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_topicId;
        break;
      }

      // optional uint64 topicId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_topicId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &topicid_)));
          set_has_topicid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 appId = 1;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->appid(), output);
  }

  // optional uint64 topicId = 2;
  if (has_topicid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->topicid(), output);
  }

}

int UCGroup::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 appId = 1;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional uint64 topicId = 2;
    if (has_topicid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->topicid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCGroup::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCGroup*>(&from));
}

void UCGroup::MergeFrom(const UCGroup& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_topicid()) {
      set_topicid(from.topicid());
    }
  }
}

void UCGroup::CopyFrom(const UCGroup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCGroup::IsInitialized() const {

  return true;
}

void UCGroup::Swap(UCGroup* other) {
  if (other != this) {
    std::swap(appid_, other->appid_);
    std::swap(topicid_, other->topicid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCGroup::GetTypeName() const {
  return "mimc.UCGroup";
}


// ===================================================================

#ifndef _MSC_VER
const int GenerateIdRequest::kRequestIdFieldNumber;
const int GenerateIdRequest::kBussinessTypeFieldNumber;
#endif  // !_MSC_VER

GenerateIdRequest::GenerateIdRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GenerateIdRequest::InitAsDefaultInstance() {
}

GenerateIdRequest::GenerateIdRequest(const GenerateIdRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GenerateIdRequest::SharedCtor() {
  _cached_size_ = 0;
  requestid_ = GOOGLE_ULONGLONG(0);
  bussinesstype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenerateIdRequest::~GenerateIdRequest() {
  SharedDtor();
}

void GenerateIdRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GenerateIdRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GenerateIdRequest& GenerateIdRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

GenerateIdRequest* GenerateIdRequest::default_instance_ = NULL;

GenerateIdRequest* GenerateIdRequest::New() const {
  return new GenerateIdRequest;
}

void GenerateIdRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    requestid_ = GOOGLE_ULONGLONG(0);
    bussinesstype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GenerateIdRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 requestId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requestid_)));
          set_has_requestid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bussinessType;
        break;
      }

      // required int32 bussinessType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bussinessType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bussinesstype_)));
          set_has_bussinesstype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenerateIdRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 requestId = 1;
  if (has_requestid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->requestid(), output);
  }

  // required int32 bussinessType = 2;
  if (has_bussinesstype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bussinesstype(), output);
  }

}

int GenerateIdRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 requestId = 1;
    if (has_requestid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requestid());
    }

    // required int32 bussinessType = 2;
    if (has_bussinesstype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bussinesstype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenerateIdRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GenerateIdRequest*>(&from));
}

void GenerateIdRequest::MergeFrom(const GenerateIdRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_requestid()) {
      set_requestid(from.requestid());
    }
    if (from.has_bussinesstype()) {
      set_bussinesstype(from.bussinesstype());
    }
  }
}

void GenerateIdRequest::CopyFrom(const GenerateIdRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateIdRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GenerateIdRequest::Swap(GenerateIdRequest* other) {
  if (other != this) {
    std::swap(requestid_, other->requestid_);
    std::swap(bussinesstype_, other->bussinesstype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GenerateIdRequest::GetTypeName() const {
  return "mimc.GenerateIdRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int GenerateIdResponse::kRequestIdFieldNumber;
const int GenerateIdResponse::kIdFieldNumber;
#endif  // !_MSC_VER

GenerateIdResponse::GenerateIdResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GenerateIdResponse::InitAsDefaultInstance() {
}

GenerateIdResponse::GenerateIdResponse(const GenerateIdResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GenerateIdResponse::SharedCtor() {
  _cached_size_ = 0;
  requestid_ = GOOGLE_ULONGLONG(0);
  id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenerateIdResponse::~GenerateIdResponse() {
  SharedDtor();
}

void GenerateIdResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GenerateIdResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GenerateIdResponse& GenerateIdResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

GenerateIdResponse* GenerateIdResponse::default_instance_ = NULL;

GenerateIdResponse* GenerateIdResponse::New() const {
  return new GenerateIdResponse;
}

void GenerateIdResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    requestid_ = GOOGLE_ULONGLONG(0);
    id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GenerateIdResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 requestId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requestid_)));
          set_has_requestid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required uint64 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenerateIdResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 requestId = 1;
  if (has_requestid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->requestid(), output);
  }

  // required uint64 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->id(), output);
  }

}

int GenerateIdResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 requestId = 1;
    if (has_requestid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requestid());
    }

    // required uint64 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenerateIdResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GenerateIdResponse*>(&from));
}

void GenerateIdResponse::MergeFrom(const GenerateIdResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_requestid()) {
      set_requestid(from.requestid());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void GenerateIdResponse::CopyFrom(const GenerateIdResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateIdResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GenerateIdResponse::Swap(GenerateIdResponse* other) {
  if (other != this) {
    std::swap(requestid_, other->requestid_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GenerateIdResponse::GetTypeName() const {
  return "mimc.GenerateIdResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int UCPacket::kUserFieldNumber;
const int UCPacket::kTypeFieldNumber;
const int UCPacket::kPayloadFieldNumber;
const int UCPacket::kPacketIdFieldNumber;
#endif  // !_MSC_VER

UCPacket::UCPacket()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCPacket::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  user_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

UCPacket::UCPacket(const UCPacket& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCPacket::SharedCtor() {
  _cached_size_ = 0;
  user_ = NULL;
  type_ = 1;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCPacket::~UCPacket() {
  SharedDtor();
}

void UCPacket::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void UCPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCPacket& UCPacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCPacket* UCPacket::default_instance_ = NULL;

UCPacket* UCPacket::New() const {
  return new UCPacket;
}

void UCPacket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
    }
    type_ = 1;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.MIMCUser user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mimc.UC_MSG_TYPE type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mimc::UC_MSG_TYPE_IsValid(value)) {
            set_type(static_cast< ::mimc::UC_MSG_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_payload;
        break;
      }

      // required bytes payload = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_packetId;
        break;
      }

      // required string packetId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packetId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.MIMCUser user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user(), output);
  }

  // required .mimc.UC_MSG_TYPE type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required bytes payload = 3;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payload(), output);
  }

  // required string packetId = 4;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->packetid(), output);
  }

}

int UCPacket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.MIMCUser user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

    // required .mimc.UC_MSG_TYPE type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required bytes payload = 3;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // required string packetId = 4;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCPacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCPacket*>(&from));
}

void UCPacket::MergeFrom(const UCPacket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      mutable_user()->::mimc::MIMCUser::MergeFrom(from.user());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
  }
}

void UCPacket::CopyFrom(const UCPacket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCPacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void UCPacket::Swap(UCPacket* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    std::swap(type_, other->type_);
    std::swap(payload_, other->payload_);
    std::swap(packetid_, other->packetid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCPacket::GetTypeName() const {
  return "mimc.UCPacket";
}


// ===================================================================

#ifndef _MSC_VER
const int UCExchange::kFeInfoFieldNumber;
const int UCExchange::kPacketFieldNumber;
const int UCExchange::kPackageFieldNumber;
#endif  // !_MSC_VER

UCExchange::UCExchange()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCExchange::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  feinfo_ = const_cast< ::mimc::FeInfo*>(
      ::mimc::FeInfo::internal_default_instance());
#else
  feinfo_ = const_cast< ::mimc::FeInfo*>(&::mimc::FeInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  packet_ = const_cast< ::mimc::UCPacket*>(
      ::mimc::UCPacket::internal_default_instance());
#else
  packet_ = const_cast< ::mimc::UCPacket*>(&::mimc::UCPacket::default_instance());
#endif
}

UCExchange::UCExchange(const UCExchange& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCExchange::SharedCtor() {
  _cached_size_ = 0;
  feinfo_ = NULL;
  packet_ = NULL;
  package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCExchange::~UCExchange() {
  SharedDtor();
}

void UCExchange::SharedDtor() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    delete package_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete feinfo_;
    delete packet_;
  }
}

void UCExchange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCExchange& UCExchange::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCExchange* UCExchange::default_instance_ = NULL;

UCExchange* UCExchange::New() const {
  return new UCExchange;
}

void UCExchange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_feinfo()) {
      if (feinfo_ != NULL) feinfo_->::mimc::FeInfo::Clear();
    }
    if (has_packet()) {
      if (packet_ != NULL) packet_->::mimc::UCPacket::Clear();
    }
    if (has_package()) {
      if (package_ != &::google::protobuf::internal::kEmptyString) {
        package_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCExchange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mimc.FeInfo feInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_feinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_packet;
        break;
      }

      // required .mimc.UCPacket packet = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packet:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packet()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_package;
        break;
      }

      // required string package = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCExchange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mimc.FeInfo feInfo = 1;
  if (has_feinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->feinfo(), output);
  }

  // required .mimc.UCPacket packet = 2;
  if (has_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->packet(), output);
  }

  // required string package = 3;
  if (has_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->package(), output);
  }

}

int UCExchange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mimc.FeInfo feInfo = 1;
    if (has_feinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->feinfo());
    }

    // required .mimc.UCPacket packet = 2;
    if (has_packet()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->packet());
    }

    // required string package = 3;
    if (has_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCExchange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCExchange*>(&from));
}

void UCExchange::MergeFrom(const UCExchange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_feinfo()) {
      mutable_feinfo()->::mimc::FeInfo::MergeFrom(from.feinfo());
    }
    if (from.has_packet()) {
      mutable_packet()->::mimc::UCPacket::MergeFrom(from.packet());
    }
    if (from.has_package()) {
      set_package(from.package());
    }
  }
}

void UCExchange::CopyFrom(const UCExchange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCExchange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_packet()) {
    if (!this->packet().IsInitialized()) return false;
  }
  return true;
}

void UCExchange::Swap(UCExchange* other) {
  if (other != this) {
    std::swap(feinfo_, other->feinfo_);
    std::swap(packet_, other->packet_);
    std::swap(package_, other->package_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCExchange::GetTypeName() const {
  return "mimc.UCExchange";
}


// ===================================================================

#ifndef _MSC_VER
const int UCJoin::kGroupFieldNumber;
#endif  // !_MSC_VER

UCJoin::UCJoin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCJoin::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCJoin::UCJoin(const UCJoin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCJoin::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCJoin::~UCJoin() {
  SharedDtor();
}

void UCJoin::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCJoin& UCJoin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCJoin* UCJoin::default_instance_ = NULL;

UCJoin* UCJoin::New() const {
  return new UCJoin;
}

void UCJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

}

int UCJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCJoin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCJoin*>(&from));
}

void UCJoin::MergeFrom(const UCJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
  }
}

void UCJoin::CopyFrom(const UCJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UCJoin::Swap(UCJoin* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCJoin::GetTypeName() const {
  return "mimc.UCJoin";
}


// ===================================================================

#ifndef _MSC_VER
const int UCJoinResp::kGroupFieldNumber;
const int UCJoinResp::kCodeFieldNumber;
const int UCJoinResp::kMessageFieldNumber;
#endif  // !_MSC_VER

UCJoinResp::UCJoinResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCJoinResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCJoinResp::UCJoinResp(const UCJoinResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCJoinResp::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  code_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCJoinResp::~UCJoinResp() {
  SharedDtor();
}

void UCJoinResp::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCJoinResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCJoinResp& UCJoinResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCJoinResp* UCJoinResp::default_instance_ = NULL;

UCJoinResp* UCJoinResp::New() const {
  return new UCJoinResp;
}

void UCJoinResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    code_ = 0;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCJoinResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required int32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }

      // optional string message = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCJoinResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // required int32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->code(), output);
  }

  // optional string message = 3;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->message(), output);
  }

}

int UCJoinResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // required int32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional string message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCJoinResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCJoinResp*>(&from));
}

void UCJoinResp::MergeFrom(const UCJoinResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
}

void UCJoinResp::CopyFrom(const UCJoinResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCJoinResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UCJoinResp::Swap(UCJoinResp* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(code_, other->code_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCJoinResp::GetTypeName() const {
  return "mimc.UCJoinResp";
}


// ===================================================================

#ifndef _MSC_VER
const int UCQuit::kGroupFieldNumber;
#endif  // !_MSC_VER

UCQuit::UCQuit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCQuit::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCQuit::UCQuit(const UCQuit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCQuit::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCQuit::~UCQuit() {
  SharedDtor();
}

void UCQuit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCQuit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCQuit& UCQuit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCQuit* UCQuit::default_instance_ = NULL;

UCQuit* UCQuit::New() const {
  return new UCQuit;
}

void UCQuit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCQuit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCQuit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

}

int UCQuit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCQuit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCQuit*>(&from));
}

void UCQuit::MergeFrom(const UCQuit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
  }
}

void UCQuit::CopyFrom(const UCQuit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCQuit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UCQuit::Swap(UCQuit* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCQuit::GetTypeName() const {
  return "mimc.UCQuit";
}


// ===================================================================

#ifndef _MSC_VER
const int UCQuitResp::kGroupFieldNumber;
const int UCQuitResp::kCodeFieldNumber;
const int UCQuitResp::kMessageFieldNumber;
#endif  // !_MSC_VER

UCQuitResp::UCQuitResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCQuitResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCQuitResp::UCQuitResp(const UCQuitResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCQuitResp::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  code_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCQuitResp::~UCQuitResp() {
  SharedDtor();
}

void UCQuitResp::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCQuitResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCQuitResp& UCQuitResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCQuitResp* UCQuitResp::default_instance_ = NULL;

UCQuitResp* UCQuitResp::New() const {
  return new UCQuitResp;
}

void UCQuitResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    code_ = 0;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCQuitResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_code;
        break;
      }

      // required int32 code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }

      // optional string message = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCQuitResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // required int32 code = 2;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->code(), output);
  }

  // optional string message = 3;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->message(), output);
  }

}

int UCQuitResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // required int32 code = 2;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional string message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCQuitResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCQuitResp*>(&from));
}

void UCQuitResp::MergeFrom(const UCQuitResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
}

void UCQuitResp::CopyFrom(const UCQuitResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCQuitResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UCQuitResp::Swap(UCQuitResp* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(code_, other->code_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCQuitResp::GetTypeName() const {
  return "mimc.UCQuitResp";
}


// ===================================================================

#ifndef _MSC_VER
const int UCPing::kGroupFieldNumber;
#endif  // !_MSC_VER

UCPing::UCPing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCPing::InitAsDefaultInstance() {
}

UCPing::UCPing(const UCPing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCPing::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCPing::~UCPing() {
  SharedDtor();
}

void UCPing::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UCPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCPing& UCPing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCPing* UCPing::default_instance_ = NULL;

UCPing* UCPing::New() const {
  return new UCPing;
}

void UCPing::Clear() {
  group_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_group;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .mimc.UCGroup group = 1;
  for (int i = 0; i < this->group_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(i), output);
  }

}

int UCPing::ByteSize() const {
  int total_size = 0;

  // repeated .mimc.UCGroup group = 1;
  total_size += 1 * this->group_size();
  for (int i = 0; i < this->group_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCPing*>(&from));
}

void UCPing::MergeFrom(const UCPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_.MergeFrom(from.group_);
}

void UCPing::CopyFrom(const UCPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCPing::IsInitialized() const {

  return true;
}

void UCPing::Swap(UCPing* other) {
  if (other != this) {
    group_.Swap(&other->group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCPing::GetTypeName() const {
  return "mimc.UCPing";
}


// ===================================================================

#ifndef _MSC_VER
const int UCMessage::kGroupFieldNumber;
const int UCMessage::kPayloadFieldNumber;
const int UCMessage::kSequenceFieldNumber;
const int UCMessage::kIsStoreFieldNumber;
const int UCMessage::kUserFieldNumber;
const int UCMessage::kTimestampFieldNumber;
const int UCMessage::kPacketIdFieldNumber;
const int UCMessage::kBizTypeFieldNumber;
#endif  // !_MSC_VER

UCMessage::UCMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  user_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

UCMessage::UCMessage(const UCMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCMessage::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = GOOGLE_LONGLONG(0);
  isstore_ = false;
  user_ = NULL;
  timestamp_ = GOOGLE_LONGLONG(0);
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCMessage::~UCMessage() {
  SharedDtor();
}

void UCMessage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
    delete user_;
  }
}

void UCMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCMessage& UCMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCMessage* UCMessage::default_instance_ = NULL;

UCMessage* UCMessage::New() const {
  return new UCMessage;
}

void UCMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    sequence_ = GOOGLE_LONGLONG(0);
    isstore_ = false;
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
    }
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }

      // required bytes payload = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sequence;
        break;
      }

      // optional int64 sequence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_user;
        break;
      }

      // optional .mimc.MIMCUser user = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_packetId;
        break;
      }

      // optional string packetId = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packetId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_bizType;
        break;
      }

      // optional string bizType = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // required bytes payload = 2;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->payload(), output);
  }

  // optional int64 sequence = 3;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->sequence(), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional .mimc.MIMCUser user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->user(), output);
  }

  // optional int64 timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->timestamp(), output);
  }

  // optional string packetId = 7;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->packetid(), output);
  }

  // optional string bizType = 8;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->biztype(), output);
  }

}

int UCMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // required bytes payload = 2;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional int64 sequence = 3;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional .mimc.MIMCUser user = 5;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

    // optional int64 timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional string packetId = 7;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

    // optional string bizType = 8;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCMessage*>(&from));
}

void UCMessage::MergeFrom(const UCMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_user()) {
      mutable_user()->::mimc::MIMCUser::MergeFrom(from.user());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
  }
}

void UCMessage::CopyFrom(const UCMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UCMessage::Swap(UCMessage* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(payload_, other->payload_);
    std::swap(sequence_, other->sequence_);
    std::swap(isstore_, other->isstore_);
    std::swap(user_, other->user_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(packetid_, other->packetid_);
    std::swap(biztype_, other->biztype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCMessage::GetTypeName() const {
  return "mimc.UCMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int UCPushMessage::kUserFieldNumber;
const int UCPushMessage::kGroupFieldNumber;
const int UCPushMessage::kPayloadsFieldNumber;
const int UCPushMessage::kIsStoreFieldNumber;
const int UCPushMessage::kTimestampFieldNumber;
const int UCPushMessage::kPacketIdFieldNumber;
const int UCPushMessage::kBizTypeFieldNumber;
#endif  // !_MSC_VER

UCPushMessage::UCPushMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCPushMessage::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_ = const_cast< ::mimc::MIMCUser*>(
      ::mimc::MIMCUser::internal_default_instance());
#else
  user_ = const_cast< ::mimc::MIMCUser*>(&::mimc::MIMCUser::default_instance());
#endif
}

UCPushMessage::UCPushMessage(const UCPushMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCPushMessage::SharedCtor() {
  _cached_size_ = 0;
  user_ = NULL;
  isstore_ = false;
  timestamp_ = GOOGLE_LONGLONG(0);
  packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  biztype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCPushMessage::~UCPushMessage() {
  SharedDtor();
}

void UCPushMessage::SharedDtor() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    delete packetid_;
  }
  if (biztype_ != &::google::protobuf::internal::kEmptyString) {
    delete biztype_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_;
  }
}

void UCPushMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCPushMessage& UCPushMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCPushMessage* UCPushMessage::default_instance_ = NULL;

UCPushMessage* UCPushMessage::New() const {
  return new UCPushMessage;
}

void UCPushMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_user()) {
      if (user_ != NULL) user_->::mimc::MIMCUser::Clear();
    }
    isstore_ = false;
    timestamp_ = GOOGLE_LONGLONG(0);
    if (has_packetid()) {
      if (packetid_ != &::google::protobuf::internal::kEmptyString) {
        packetid_->clear();
      }
    }
    if (has_biztype()) {
      if (biztype_ != &::google::protobuf::internal::kEmptyString) {
        biztype_->clear();
      }
    }
  }
  group_.Clear();
  payloads_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCPushMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.MIMCUser user = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_group;
        break;
      }

      // repeated .mimc.UCGroup group = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_group;
        if (input->ExpectTag(26)) goto parse_payloads;
        break;
      }

      // repeated bytes payloads = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payloads:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_payloads()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_payloads;
        if (input->ExpectTag(32)) goto parse_isStore;
        break;
      }

      // optional bool isStore = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isStore:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isstore_)));
          set_has_isstore();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_packetId;
        break;
      }

      // optional string packetId = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_packetId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_packetid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_bizType;
        break;
      }

      // optional string bizType = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bizType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_biztype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCPushMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.MIMCUser user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user(), output);
  }

  // repeated .mimc.UCGroup group = 2;
  for (int i = 0; i < this->group_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->group(i), output);
  }

  // repeated bytes payloads = 3;
  for (int i = 0; i < this->payloads_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->payloads(i), output);
  }

  // optional bool isStore = 4;
  if (has_isstore()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isstore(), output);
  }

  // optional int64 timestamp = 5;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->timestamp(), output);
  }

  // optional string packetId = 6;
  if (has_packetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->packetid(), output);
  }

  // optional string bizType = 7;
  if (has_biztype()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->biztype(), output);
  }

}

int UCPushMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.MIMCUser user = 1;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user());
    }

    // optional bool isStore = 4;
    if (has_isstore()) {
      total_size += 1 + 1;
    }

    // optional int64 timestamp = 5;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

    // optional string packetId = 6;
    if (has_packetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->packetid());
    }

    // optional string bizType = 7;
    if (has_biztype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->biztype());
    }

  }
  // repeated .mimc.UCGroup group = 2;
  total_size += 1 * this->group_size();
  for (int i = 0; i < this->group_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->group(i));
  }

  // repeated bytes payloads = 3;
  total_size += 1 * this->payloads_size();
  for (int i = 0; i < this->payloads_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->payloads(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCPushMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCPushMessage*>(&from));
}

void UCPushMessage::MergeFrom(const UCPushMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_.MergeFrom(from.group_);
  payloads_.MergeFrom(from.payloads_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      mutable_user()->::mimc::MIMCUser::MergeFrom(from.user());
    }
    if (from.has_isstore()) {
      set_isstore(from.isstore());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_packetid()) {
      set_packetid(from.packetid());
    }
    if (from.has_biztype()) {
      set_biztype(from.biztype());
    }
  }
}

void UCPushMessage::CopyFrom(const UCPushMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCPushMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UCPushMessage::Swap(UCPushMessage* other) {
  if (other != this) {
    std::swap(user_, other->user_);
    group_.Swap(&other->group_);
    payloads_.Swap(&other->payloads_);
    std::swap(isstore_, other->isstore_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(packetid_, other->packetid_);
    std::swap(biztype_, other->biztype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCPushMessage::GetTypeName() const {
  return "mimc.UCPushMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int UCMessageList::kGroupFieldNumber;
const int UCMessageList::kMessageFieldNumber;
const int UCMessageList::kMaxSequenceFieldNumber;
#endif  // !_MSC_VER

UCMessageList::UCMessageList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCMessageList::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCMessageList::UCMessageList(const UCMessageList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCMessageList::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  maxsequence_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCMessageList::~UCMessageList() {
  SharedDtor();
}

void UCMessageList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCMessageList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCMessageList& UCMessageList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCMessageList* UCMessageList::default_instance_ = NULL;

UCMessageList* UCMessageList::New() const {
  return new UCMessageList;
}

void UCMessageList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    maxsequence_ = GOOGLE_LONGLONG(0);
  }
  message_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCMessageList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // repeated .mimc.UCMessage message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        if (input->ExpectTag(24)) goto parse_maxSequence;
        break;
      }

      // optional int64 maxSequence = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxSequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxsequence_)));
          set_has_maxsequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCMessageList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // repeated .mimc.UCMessage message = 2;
  for (int i = 0; i < this->message_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->message(i), output);
  }

  // optional int64 maxSequence = 3;
  if (has_maxsequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->maxsequence(), output);
  }

}

int UCMessageList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // optional int64 maxSequence = 3;
    if (has_maxsequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxsequence());
    }

  }
  // repeated .mimc.UCMessage message = 2;
  total_size += 1 * this->message_size();
  for (int i = 0; i < this->message_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->message(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCMessageList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCMessageList*>(&from));
}

void UCMessageList::MergeFrom(const UCMessageList& from) {
  GOOGLE_CHECK_NE(&from, this);
  message_.MergeFrom(from.message_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_maxsequence()) {
      set_maxsequence(from.maxsequence());
    }
  }
}

void UCMessageList::CopyFrom(const UCMessageList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCMessageList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < message_size(); i++) {
    if (!this->message(i).IsInitialized()) return false;
  }
  return true;
}

void UCMessageList::Swap(UCMessageList* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    message_.Swap(&other->message_);
    std::swap(maxsequence_, other->maxsequence_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCMessageList::GetTypeName() const {
  return "mimc.UCMessageList";
}


// ===================================================================

#ifndef _MSC_VER
const int UCSequenceAck::kGroupFieldNumber;
const int UCSequenceAck::kSequenceFieldNumber;
#endif  // !_MSC_VER

UCSequenceAck::UCSequenceAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCSequenceAck::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCSequenceAck::UCSequenceAck(const UCSequenceAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCSequenceAck::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  sequence_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCSequenceAck::~UCSequenceAck() {
  SharedDtor();
}

void UCSequenceAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCSequenceAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCSequenceAck& UCSequenceAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCSequenceAck* UCSequenceAck::default_instance_ = NULL;

UCSequenceAck* UCSequenceAck::New() const {
  return new UCSequenceAck;
}

void UCSequenceAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    sequence_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCSequenceAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sequence;
        break;
      }

      // required int64 sequence = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCSequenceAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // required int64 sequence = 2;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->sequence(), output);
  }

}

int UCSequenceAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // required int64 sequence = 2;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sequence());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCSequenceAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCSequenceAck*>(&from));
}

void UCSequenceAck::MergeFrom(const UCSequenceAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
  }
}

void UCSequenceAck::CopyFrom(const UCSequenceAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCSequenceAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UCSequenceAck::Swap(UCSequenceAck* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(sequence_, other->sequence_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCSequenceAck::GetTypeName() const {
  return "mimc.UCSequenceAck";
}


// ===================================================================

#ifndef _MSC_VER
const int UCDismiss::kGroupFieldNumber;
#endif  // !_MSC_VER

UCDismiss::UCDismiss()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCDismiss::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCDismiss::UCDismiss(const UCDismiss& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCDismiss::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCDismiss::~UCDismiss() {
  SharedDtor();
}

void UCDismiss::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCDismiss::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCDismiss& UCDismiss::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCDismiss* UCDismiss::default_instance_ = NULL;

UCDismiss* UCDismiss::New() const {
  return new UCDismiss;
}

void UCDismiss::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCDismiss::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCDismiss::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

}

int UCDismiss::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCDismiss::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCDismiss*>(&from));
}

void UCDismiss::MergeFrom(const UCDismiss& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
  }
}

void UCDismiss::CopyFrom(const UCDismiss& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCDismiss::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UCDismiss::Swap(UCDismiss* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCDismiss::GetTypeName() const {
  return "mimc.UCDismiss";
}


// ===================================================================

#ifndef _MSC_VER
const int UCQueryOnlineUsers::kGroupFieldNumber;
#endif  // !_MSC_VER

UCQueryOnlineUsers::UCQueryOnlineUsers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCQueryOnlineUsers::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCQueryOnlineUsers::UCQueryOnlineUsers(const UCQueryOnlineUsers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCQueryOnlineUsers::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCQueryOnlineUsers::~UCQueryOnlineUsers() {
  SharedDtor();
}

void UCQueryOnlineUsers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCQueryOnlineUsers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCQueryOnlineUsers& UCQueryOnlineUsers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCQueryOnlineUsers* UCQueryOnlineUsers::default_instance_ = NULL;

UCQueryOnlineUsers* UCQueryOnlineUsers::New() const {
  return new UCQueryOnlineUsers;
}

void UCQueryOnlineUsers::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCQueryOnlineUsers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCQueryOnlineUsers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

}

int UCQueryOnlineUsers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCQueryOnlineUsers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCQueryOnlineUsers*>(&from));
}

void UCQueryOnlineUsers::MergeFrom(const UCQueryOnlineUsers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
  }
}

void UCQueryOnlineUsers::CopyFrom(const UCQueryOnlineUsers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCQueryOnlineUsers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UCQueryOnlineUsers::Swap(UCQueryOnlineUsers* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCQueryOnlineUsers::GetTypeName() const {
  return "mimc.UCQueryOnlineUsers";
}


// ===================================================================

#ifndef _MSC_VER
const int UCQueryOnlineUsersResp::kGroupFieldNumber;
const int UCQueryOnlineUsersResp::kUserCountFieldNumber;
#endif  // !_MSC_VER

UCQueryOnlineUsersResp::UCQueryOnlineUsersResp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UCQueryOnlineUsersResp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  group_ = const_cast< ::mimc::UCGroup*>(
      ::mimc::UCGroup::internal_default_instance());
#else
  group_ = const_cast< ::mimc::UCGroup*>(&::mimc::UCGroup::default_instance());
#endif
}

UCQueryOnlineUsersResp::UCQueryOnlineUsersResp(const UCQueryOnlineUsersResp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UCQueryOnlineUsersResp::SharedCtor() {
  _cached_size_ = 0;
  group_ = NULL;
  usercount_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UCQueryOnlineUsersResp::~UCQueryOnlineUsersResp() {
  SharedDtor();
}

void UCQueryOnlineUsersResp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete group_;
  }
}

void UCQueryOnlineUsersResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UCQueryOnlineUsersResp& UCQueryOnlineUsersResp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

UCQueryOnlineUsersResp* UCQueryOnlineUsersResp::default_instance_ = NULL;

UCQueryOnlineUsersResp* UCQueryOnlineUsersResp::New() const {
  return new UCQueryOnlineUsersResp;
}

void UCQueryOnlineUsersResp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_group()) {
      if (group_ != NULL) group_->::mimc::UCGroup::Clear();
    }
    usercount_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UCQueryOnlineUsersResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mimc.UCGroup group = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_group()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_userCount;
        break;
      }

      // required int64 userCount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_userCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &usercount_)));
          set_has_usercount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UCQueryOnlineUsersResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mimc.UCGroup group = 1;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->group(), output);
  }

  // required int64 userCount = 2;
  if (has_usercount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->usercount(), output);
  }

}

int UCQueryOnlineUsersResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mimc.UCGroup group = 1;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->group());
    }

    // required int64 userCount = 2;
    if (has_usercount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->usercount());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UCQueryOnlineUsersResp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UCQueryOnlineUsersResp*>(&from));
}

void UCQueryOnlineUsersResp::MergeFrom(const UCQueryOnlineUsersResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group()) {
      mutable_group()->::mimc::UCGroup::MergeFrom(from.group());
    }
    if (from.has_usercount()) {
      set_usercount(from.usercount());
    }
  }
}

void UCQueryOnlineUsersResp::CopyFrom(const UCQueryOnlineUsersResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UCQueryOnlineUsersResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UCQueryOnlineUsersResp::Swap(UCQueryOnlineUsersResp* other) {
  if (other != this) {
    std::swap(group_, other->group_);
    std::swap(usercount_, other->usercount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UCQueryOnlineUsersResp::GetTypeName() const {
  return "mimc.UCQueryOnlineUsersResp";
}


// ===================================================================

#ifndef _MSC_VER
const int FeInfo::kFeSrcIpFieldNumber;
const int FeInfo::kFeSrcPortFieldNumber;
const int FeInfo::kFeThreadIdFieldNumber;
const int FeInfo::kFeUcidFieldNumber;
const int FeInfo::kFeSidFieldNumber;
const int FeInfo::kFeSeqnoFieldNumber;
#endif  // !_MSC_VER

FeInfo::FeInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FeInfo::InitAsDefaultInstance() {
}

FeInfo::FeInfo(const FeInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FeInfo::SharedCtor() {
  _cached_size_ = 0;
  fe_src_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fe_src_port_ = 0;
  fe_thread_id_ = 0;
  fe_ucid_ = GOOGLE_ULONGLONG(0);
  fe_sid_ = GOOGLE_ULONGLONG(0);
  fe_seqno_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FeInfo::~FeInfo() {
  SharedDtor();
}

void FeInfo::SharedDtor() {
  if (fe_src_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete fe_src_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FeInfo& FeInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mimc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mimc_2eproto();
#endif
  return *default_instance_;
}

FeInfo* FeInfo::default_instance_ = NULL;

FeInfo* FeInfo::New() const {
  return new FeInfo;
}

void FeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_fe_src_ip()) {
      if (fe_src_ip_ != &::google::protobuf::internal::kEmptyString) {
        fe_src_ip_->clear();
      }
    }
    fe_src_port_ = 0;
    fe_thread_id_ = 0;
    fe_ucid_ = GOOGLE_ULONGLONG(0);
    fe_sid_ = GOOGLE_ULONGLONG(0);
    fe_seqno_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string fe_src_ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fe_src_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fe_src_port;
        break;
      }

      // optional int32 fe_src_port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fe_src_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fe_src_port_)));
          set_has_fe_src_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fe_thread_id;
        break;
      }

      // optional int32 fe_thread_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fe_thread_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fe_thread_id_)));
          set_has_fe_thread_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_fe_ucid;
        break;
      }

      // optional uint64 fe_ucid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fe_ucid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fe_ucid_)));
          set_has_fe_ucid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fe_sid;
        break;
      }

      // optional uint64 fe_sid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fe_sid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fe_sid_)));
          set_has_fe_sid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_fe_seqno;
        break;
      }

      // optional uint64 fe_seqno = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fe_seqno:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fe_seqno_)));
          set_has_fe_seqno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string fe_src_ip = 1;
  if (has_fe_src_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->fe_src_ip(), output);
  }

  // optional int32 fe_src_port = 2;
  if (has_fe_src_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->fe_src_port(), output);
  }

  // optional int32 fe_thread_id = 3;
  if (has_fe_thread_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->fe_thread_id(), output);
  }

  // optional uint64 fe_ucid = 4;
  if (has_fe_ucid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->fe_ucid(), output);
  }

  // optional uint64 fe_sid = 5;
  if (has_fe_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->fe_sid(), output);
  }

  // optional uint64 fe_seqno = 6;
  if (has_fe_seqno()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->fe_seqno(), output);
  }

}

int FeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string fe_src_ip = 1;
    if (has_fe_src_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fe_src_ip());
    }

    // optional int32 fe_src_port = 2;
    if (has_fe_src_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fe_src_port());
    }

    // optional int32 fe_thread_id = 3;
    if (has_fe_thread_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fe_thread_id());
    }

    // optional uint64 fe_ucid = 4;
    if (has_fe_ucid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fe_ucid());
    }

    // optional uint64 fe_sid = 5;
    if (has_fe_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fe_sid());
    }

    // optional uint64 fe_seqno = 6;
    if (has_fe_seqno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fe_seqno());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FeInfo*>(&from));
}

void FeInfo::MergeFrom(const FeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fe_src_ip()) {
      set_fe_src_ip(from.fe_src_ip());
    }
    if (from.has_fe_src_port()) {
      set_fe_src_port(from.fe_src_port());
    }
    if (from.has_fe_thread_id()) {
      set_fe_thread_id(from.fe_thread_id());
    }
    if (from.has_fe_ucid()) {
      set_fe_ucid(from.fe_ucid());
    }
    if (from.has_fe_sid()) {
      set_fe_sid(from.fe_sid());
    }
    if (from.has_fe_seqno()) {
      set_fe_seqno(from.fe_seqno());
    }
  }
}

void FeInfo::CopyFrom(const FeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeInfo::IsInitialized() const {

  return true;
}

void FeInfo::Swap(FeInfo* other) {
  if (other != this) {
    std::swap(fe_src_ip_, other->fe_src_ip_);
    std::swap(fe_src_port_, other->fe_src_port_);
    std::swap(fe_thread_id_, other->fe_thread_id_);
    std::swap(fe_ucid_, other->fe_ucid_);
    std::swap(fe_sid_, other->fe_sid_);
    std::swap(fe_seqno_, other->fe_seqno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FeInfo::GetTypeName() const {
  return "mimc.FeInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mimc

// @@protoc_insertion_point(global_scope)
